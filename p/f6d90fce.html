<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/img/favicon.png"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="没有天生的大牛，更没有永远的菜鸟求知若饥 , 虚心若愚"><meta name="author" content="iceH"><meta name="keywords" content=""><title>Golang学习之基本类型与流程控制 - iceH’s Blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/css/gundongtiao.css# 滚动条颜色.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/css/shubiao.css# 鼠标指针.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/css/valine.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"www.secice.cn",root:"/",version:"1.8.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},copy_btn:!0,image_zoom:{enable:!0},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="iceH’s Blog" type="application/atom+xml">
</head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>iceH's Blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 博文</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档 </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类 </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></div></li><li class="nav-item"><a class="nav-link" href="/playlist/"><i class="iconfont icon-music"></i> 音乐</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/img/background1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Golang学习之基本类型与流程控制"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-01-05 08:35" pubdate>2021年1月5日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 208 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Golang学习之基本类型与流程控制</h1><div class="markdown-body"><p><strong>Golang环境：</strong><a target="_blank" rel="noopener" href="https://studygolang.com/dl">https://studygolang.com/dl</a></p><p><strong>LiteIde：</strong><a target="_blank" rel="noopener" href="http://liteide.org/cn/">http://liteide.org/cn/</a></p><p><strong>Golang标准库文档：</strong><a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p><strong>命令行下使用基础</strong></p><pre><code class="hljs go"><span class="hljs-keyword">go</span> version 			<span class="hljs-comment">//查看go版本</span>
<span class="hljs-keyword">go</span> env 			    <span class="hljs-comment">//查看环境信息</span>
<span class="hljs-keyword">go</span> build xx.<span class="hljs-keyword">go</span>		<span class="hljs-comment">//编译代码，生成可执行的exe文件</span>
<span class="hljs-keyword">go</span> run xx.<span class="hljs-keyword">go</span>		<span class="hljs-comment">//运行go文件</span></code></pre><h2 id="一、第一个-Go-程序"><a href="#一、第一个-Go-程序" class="headerlink" title="一、第一个 Go 程序"></a>一、第一个 Go 程序</h2><pre><code class="hljs go"><span class="hljs-comment">// 1.go语言以包作为管理单位</span>
<span class="hljs-comment">// 2.每个go文件都必须在非注释的第一行代码中声明包名</span>
<span class="hljs-comment">// 3.liteide下，一个文件夹（目录）下，只能有一个main包</span>
<span class="hljs-comment">// 4.main包中有且只有一个main()函数</span>
<span class="hljs-keyword">package</span> main <span class="hljs-comment">// main 表示包的标识</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-comment">// 程序的入口，是从这里开始调用的</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//左括号必须和函数名同行</span>
	<span class="hljs-comment">//打印</span>
	<span class="hljs-comment">//&quot;hello go&quot;打印到屏幕，Println()会自动换行</span>
	<span class="hljs-comment">//调用函数，大部分都需要导入包</span>
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">		这也是注释，这是块注释</span>
<span class="hljs-comment">	*/</span>
	fmt.Println(<span class="hljs-string">&quot;hello go&quot;</span>) <span class="hljs-comment">//go语言语句结尾是没有分号的</span>

	fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)
&#125;</code></pre><p>注意：关键字 <code>import</code> 后面的最后一个元素是目录名，而不是包名。Golang 编译器在这个路径下寻找包。</p><h3 id="1-1-入口"><a href="#1-1-入口" class="headerlink" title="1.1 入口"></a>1.1 入口</h3><p>**一个 go 工程有且只有一个入口函数 main()**。<br>注意：<code>main()</code> 函数不能有任何参数和返回值。</p><h3 id="1-2-Golang-保留的关键字"><a href="#1-2-Golang-保留的关键字" class="headerlink" title="1.2 Golang 保留的关键字"></a>1.2 Golang 保留的关键字</h3><pre><code class="hljs go">包管理（<span class="hljs-number">2</span>个）：
	<span class="hljs-keyword">import</span>	<span class="hljs-keyword">package</span>

程序实体声明与定义（<span class="hljs-number">8</span>个）：
	<span class="hljs-keyword">chan</span>	<span class="hljs-keyword">const</span>	<span class="hljs-function"><span class="hljs-keyword">func</span>	<span class="hljs-title">interface</span>	<span class="hljs-title">map</span>	<span class="hljs-title">struct</span>	<span class="hljs-title">type</span>	<span class="hljs-title">var</span></span>

程序流程控制（<span class="hljs-number">15</span>个）：
	<span class="hljs-keyword">break</span>	<span class="hljs-keyword">case</span>	<span class="hljs-keyword">continue</span>	<span class="hljs-keyword">default</span>	<span class="hljs-keyword">defer</span>	<span class="hljs-keyword">else</span>	<span class="hljs-keyword">fallthrough</span>	
	<span class="hljs-keyword">for</span>		<span class="hljs-keyword">go</span>		<span class="hljs-keyword">goto</span>		<span class="hljs-keyword">if</span>		<span class="hljs-keyword">range</span>	<span class="hljs-keyword">return</span>	<span class="hljs-keyword">select</span>		<span class="hljs-keyword">switch</span></code></pre><h3 id="1-3-Golang预定义标识符"><a href="#1-3-Golang预定义标识符" class="headerlink" title="1.3 Golang预定义标识符"></a>1.3 Golang预定义标识符</h3><pre><code class="hljs go">常量:
<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">nil</span>

类型:
<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>, <span class="hljs-keyword">uint</span>,
<span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>, <span class="hljs-keyword">uintptr</span>,
<span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span>, <span class="hljs-keyword">complex128</span>, <span class="hljs-keyword">complex64</span>,
<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">byte</span>, <span class="hljs-keyword">rune</span>, <span class="hljs-keyword">string</span>

函数:
<span class="hljs-built_in">make</span>, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>, <span class="hljs-built_in">new</span>, <span class="hljs-built_in">append</span>, <span class="hljs-built_in">copy</span>, <span class="hljs-built_in">close</span>, 
<span class="hljs-built_in">delete</span>, <span class="hljs-built_in">complex</span>, <span class="hljs-built_in">real</span>, <span class="hljs-built_in">imag</span>, <span class="hljs-built_in">panic</span>, <span class="hljs-built_in">recover</span></code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>类型表示同一类的数据，计算机用来计算，计算前需要把数据存储起来，那么如何存储数据？</p><h3 id="2-1-数据类型的作用"><a href="#2-1-数据类型的作用" class="headerlink" title="2.1 数据类型的作用"></a>2.1 数据类型的作用</h3><p>告诉编译器，这个数据应该以多大的内存进行存储，方便内存分配空间。<br>例如：写了一个数字 10，以 byte 类型存储，在内存中就占 1 个字节的大小；以 int 类型存储，在内存中就占4个字节。</p><h3 id="2-2-数据类型的命名规则"><a href="#2-2-数据类型的命名规则" class="headerlink" title="2.2 数据类型的命名规则"></a>2.2 数据类型的命名规则</h3><p>1.由字母、下划线、数字构成<br>2.不能以数字开头<br>3.不能使用关键字<br>4.<strong>严格区分大小写</strong></p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><h4 id="2-3-1-何为变量"><a href="#2-3-1-何为变量" class="headerlink" title="2.3.1 何为变量"></a>2.3.1 何为变量</h4><p>程序运行期间，可以改变的量。简而言之：一开始给它一个值，之后可以改变它的值。</p><h4 id="2-3-2-声明变量"><a href="#2-3-2-声明变量" class="headerlink" title="2.3.2 声明变量"></a>2.3.2 声明变量</h4><p><strong>变量在使用前（赋值、打印等操作），必须先声明</strong>！<br>语法：<code>var 变量名 数据类型</code><br>1.声明一个变量 <code>var a int</code><br>2.同时声明多个变量 <code>var b, c int</code></p><h4 id="2-3-3-变量的声明及赋值"><a href="#2-3-3-变量的声明及赋值" class="headerlink" title="2.3.3 变量的声明及赋值"></a>2.3.3 变量的声明及赋值</h4><p>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>
a = <span class="hljs-number">10</span></code></pre><h4 id="2-3-4-变量的初始化"><a href="#2-3-4-变量的初始化" class="headerlink" title="2.3.4 变量的初始化"></a>2.3.4 变量的初始化</h4><p>所谓变量的初始化就是：声明变量的时候同时赋值。<br>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 声明变量时，同时赋值（一步到位）</span>
<span class="hljs-comment">// int是可以省略不写的</span></code></pre><p>例2：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span>
b = <span class="hljs-number">20</span>
<span class="hljs-comment">// 此例中分了两步走：</span>
<span class="hljs-comment">// 1.先声明</span>
<span class="hljs-comment">// 2.后赋值</span></code></pre><h4 id="2-3-5-自动推导类型"><a href="#2-3-5-自动推导类型" class="headerlink" title="2.3.5 自动推导类型"></a>2.3.5 自动推导类型</h4><p>注意：<strong>自动推导类型必须给初始化值，它是通过这个值来确定具体的数据类型</strong>！<br>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	c := <span class="hljs-number">30</span> <span class="hljs-comment">// 编译器会根据 30 这个值来推导对应的数据类型</span>
	<span class="hljs-comment">// %T 打印变量所属的类型</span>
	fmt.Printf(<span class="hljs-string">&quot;c type is : %T\n&quot;</span>, c)
	<span class="hljs-comment">// 运行结果：</span>
	<span class="hljs-comment">// c type is : int</span>
&#125;</code></pre><p>自动推导类型的大致流程：先声明 c 的类型，再给 c 赋值为整数值 30。<br>注意：<strong>海象运算符 := 前面，必须要有新的变量，不然就会报错</strong>。因为海象运算符的流程是先声明变量的类型，再给变量赋值（几乎同时发生），如果没有新的变量，那么就会变成重复声明了。</p><h4 id="2-3-6-多重赋值"><a href="#2-3-6-多重赋值" class="headerlink" title="2.3.6 多重赋值"></a>2.3.6 多重赋值</h4><h5 id="2-3-6-1-var-包裹起来的多重声明"><a href="#2-3-6-1-var-包裹起来的多重声明" class="headerlink" title="2.3.6.1 var() 包裹起来的多重声明"></a>2.3.6.1 <code>var()</code> 包裹起来的多重声明</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> (
		a <span class="hljs-keyword">int</span>
		b <span class="hljs-keyword">float64</span>
	) <span class="hljs-comment">// 关键字var+()，把多个变量包裹起来</span>
	a = <span class="hljs-number">10</span>
	b = <span class="hljs-number">3.14</span>

	fmt.Println(a, b) <span class="hljs-comment">// 10 3.14</span>
&#125;</code></pre><h5 id="2-3-6-2-自动推导类型（官方推荐写法）"><a href="#2-3-6-2-自动推导类型（官方推荐写法）" class="headerlink" title="2.3.6.2 自动推导类型（官方推荐写法）"></a>2.3.6.2 自动推导类型（官方推荐写法）</h5><p>使用海象运算符 <code>:=</code>：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	a, b := <span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>
	fmt.Println(a, b) <span class="hljs-comment">// 10 3.14</span>
&#125;</code></pre><h4 id="2-3-7-匿名变量"><a href="#2-3-7-匿名变量" class="headerlink" title="2.3.7 匿名变量"></a>2.3.7 匿名变量</h4><p>使用单个下划线 <code>_</code> 表示匿名变量，丢弃数据且不处理，也不会占用内存空间。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	i, j := <span class="hljs-number">10</span>, <span class="hljs-number">20</span>
	tmp, _ := i, j <span class="hljs-comment">// 这里，j就被丢弃掉了，不会处理j这个变量了</span>
	fmt.Println(tmp, j) <span class="hljs-comment">// 打印j的值依然是用之前的20</span>
&#125;</code></pre><h4 id="2-3-8-变量的输入"><a href="#2-3-8-变量的输入" class="headerlink" title="2.3.8 变量的输入"></a>2.3.8 变量的输入</h4><p>使用内建 <code>fmt</code> 包下的 <code>Scan()</code> 函数：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>
	fmt.Printf(<span class="hljs-string">&quot;输入变量a的值：&quot;</span>)

	fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) <span class="hljs-comment">// 取a的地址，此处会阻塞等待用户的输入</span>
	<span class="hljs-comment">// 或者下面更加简便的等价的写法：</span>
	<span class="hljs-comment">// fmt.Scan(&amp;a) // 别忘了取地址</span>
	fmt.Printf(<span class="hljs-string">&quot;刚才输入的值，a=%d\n&quot;</span>, a)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">输入变量a的值：11</span>
<span class="hljs-comment">刚才输入的值，a=11</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="2-3-9-变量使用注意事项"><a href="#2-3-9-变量使用注意事项" class="headerlink" title="2.3.9 变量使用注意事项"></a>2.3.9 变量使用注意事项</h4><p>1.函数外的每个语句都必须以关键字开始。（<code>var</code>、<code>const</code>、<code>func</code> 等）<br>2.海象运算符 <code>:=</code> 不能在函数外使用。<br>3.下划线 <code>_</code> 多用于占位，不会占用内存空间，表示丢弃该值。</p><h3 id="2-4-常量"><a href="#2-4-常量" class="headerlink" title="2.4 常量"></a>2.4 常量</h3><h4 id="2-4-1-何为常量"><a href="#2-4-1-何为常量" class="headerlink" title="2.4.1 何为常量"></a>2.4.1 何为常量</h4><p>程序运行期间，不能改变的量。一开始给了值，就不允许再改变了！</p><h4 id="2-4-2-初始化常量"><a href="#2-4-2-初始化常量" class="headerlink" title="2.4.2 初始化常量"></a>2.4.2 初始化常量</h4><p>常量必须给值，所以就是直接初始化常量了，声明和赋值一步完成。</p><h5 id="2-4-2-1-语法"><a href="#2-4-2-1-语法" class="headerlink" title="2.4.2.1 语法"></a>2.4.2.1 语法</h5><p><code>const 常量名 [数据类型] = 值</code></p><h5 id="2-4-2-2-例1，单个初始化"><a href="#2-4-2-2-例1，单个初始化" class="headerlink" title="2.4.2.2 例1，单个初始化"></a>2.4.2.2 例1，单个初始化</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-number">10</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(a, b)
&#125;</code></pre><h5 id="2-4-2-3-例2，包裹起来一起初始化"><a href="#2-4-2-3-例2，包裹起来一起初始化" class="headerlink" title="2.4.2.3 例2，包裹起来一起初始化"></a>2.4.2.3 例2，包裹起来一起初始化</h5><p>把例1的常量声明，用括号括起来，写在一起：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (
	a = <span class="hljs-number">10</span>
	b = <span class="hljs-number">10</span>
)</code></pre><h5 id="2-4-2-4-例3，多重初始化"><a href="#2-4-2-4-例3，多重初始化" class="headerlink" title="2.4.2.4 例3，多重初始化"></a>2.4.2.4 例3，多重初始化</h5><pre><code class="hljs go"><span class="hljs-keyword">const</span> a, b = <span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(a, b) <span class="hljs-comment">//10 3.14</span>
&#125;</code></pre><h4 id="2-4-3-iota枚举"><a href="#2-4-3-iota枚举" class="headerlink" title="2.4.3 iota枚举"></a>2.4.3 iota枚举</h4><h5 id="2-4-3-1-iota的特性1"><a href="#2-4-3-1-iota的特性1" class="headerlink" title="2.4.3.1 iota的特性1"></a>2.4.3.1 iota的特性1</h5><p><code>iota</code> 是常量自动生成器，每一行，自动累加1。</p><h5 id="2-4-3-2-iota的特性2"><a href="#2-4-3-2-iota的特性2" class="headerlink" title="2.4.3.2 iota的特性2"></a>2.4.3.2 iota的特性2</h5><p><code>iota</code> 只能在常量表达式中使用（只能在 <code>const</code> 中使用）。<br>特性1 + 特性2的示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">const</span> (
	a = <span class="hljs-literal">iota</span>
	b = <span class="hljs-literal">iota</span>
	c = <span class="hljs-literal">iota</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c) <span class="hljs-comment">//a = 0, b = 1, c = 2</span>
&#125;</code></pre><h5 id="2-4-3-3-iota的特性3"><a href="#2-4-3-3-iota的特性3" class="headerlink" title="2.4.3.3 iota的特性3"></a>2.4.3.3 iota的特性3</h5><p>遇到另一个 <code>const</code>，<code>iota</code> 的值重新从 0 开始计算。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">const</span> (
	a = <span class="hljs-literal">iota</span>
	b
	c
)

<span class="hljs-keyword">const</span> (
	d = <span class="hljs-literal">iota</span>
	e
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">const</span> (
		f = <span class="hljs-literal">iota</span>
		g
		h
	)

	fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)
	fmt.Println(<span class="hljs-string">&quot;b=&quot;</span>, b)
	fmt.Println(<span class="hljs-string">&quot;c=&quot;</span>, c)
	fmt.Println(<span class="hljs-string">&quot;d=&quot;</span>, d)
	fmt.Println(<span class="hljs-string">&quot;e=&quot;</span>, e)
	fmt.Println(<span class="hljs-string">&quot;f=&quot;</span>, f)
	fmt.Println(<span class="hljs-string">&quot;g=&quot;</span>, g)
	fmt.Println(<span class="hljs-string">&quot;h=&quot;</span>, h)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">a= 0</span>
<span class="hljs-comment">b= 1</span>
<span class="hljs-comment">c= 2</span>
<span class="hljs-comment">d= 0</span>
<span class="hljs-comment">e= 1</span>
<span class="hljs-comment">f= 0</span>
<span class="hljs-comment">g= 1</span>
<span class="hljs-comment">h= 2</span>
<span class="hljs-comment">*/</span></code></pre><h5 id="2-4-3-4-iota的特性4"><a href="#2-4-3-4-iota的特性4" class="headerlink" title="2.4.3.4 iota的特性4"></a>2.4.3.4 iota的特性4</h5><p>同一块 <code>const</code> 内，可以只写一个 <code>iota</code> 预定义标识符。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">const</span> (
		a1 = <span class="hljs-literal">iota</span>
		b1
		c1
		d1
	)

	fmt.Printf(<span class="hljs-string">&quot;a1 = %d, b1 = %d, c1 = %d, d1 = %d\n&quot;</span>, a1, b1, c1, d1) <span class="hljs-comment">//a1 = 0, b1 = 1, c1 = 2, d1 = 3</span>
&#125;</code></pre><h5 id="2-4-3-5-iota的特性5"><a href="#2-4-3-5-iota的特性5" class="headerlink" title="2.4.3.5 iota的特性5"></a>2.4.3.5 iota的特性5</h5><p>如果是同一行，<code>iota</code> 值都一样。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">const</span> (
		i          = <span class="hljs-literal">iota</span>
		j1, j2, j3 = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>
		k          = <span class="hljs-literal">iota</span>
	)

	fmt.Printf(<span class="hljs-string">&quot;i=%d, j1=%d, j2=%d, j3=%d, k=%d\n&quot;</span>, i, j1, j2, j3, k) <span class="hljs-comment">//i=0, j1=1, j2=1, j3=1, k=2</span>
&#125;</code></pre><p>原因：<code>iota</code> 是每一行自动累加 <code>1</code>，在同一行内的 <code>iota</code> 值都是相同的。</p><h5 id="2-4-3-6-iota的特性6"><a href="#2-4-3-6-iota的特性6" class="headerlink" title="2.4.3.6 iota的特性6"></a>2.4.3.6 iota的特性6</h5><p><code>iota</code> 的值，只取决于它所在第几行（下标从 0 开始），可以理解成为：行索引。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">const</span> (
		i          = <span class="hljs-number">10</span>
		j1, j2, j3 = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>
		k          = <span class="hljs-number">20</span>
		l, m       = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>
		n          = <span class="hljs-string">&quot;abc&quot;</span>
		o          = <span class="hljs-literal">iota</span>
	)

	fmt.Printf(<span class="hljs-string">&quot;i=%d, j1=%d, j2=%d, j3=%d, k=%d, l=%d, m=%d, n=%s, o=%d\n&quot;</span>, i, j1, j2, j3, k, l, m, n, o)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">i=10, j1=1, j2=1, j3=1, k=20, l=3, m=3, n=abc, o=5</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="2-4-4-常量使用的注意事项"><a href="#2-4-4-常量使用的注意事项" class="headerlink" title="2.4.4 常量使用的注意事项"></a>2.4.4 常量使用的注意事项</h4><h5 id="2-4-4-1-初始化常量不允许使用海象运算符"><a href="#2-4-4-1-初始化常量不允许使用海象运算符" class="headerlink" title="2.4.4.1 初始化常量不允许使用海象运算符:="></a>2.4.4.1 初始化常量不允许使用海象运算符<code>:=</code></h5><pre><code class="hljs go"><span class="hljs-keyword">const</span> :b = <span class="hljs-number">10</span></code></pre><h5 id="2-4-4-2-常量不允许被修改"><a href="#2-4-4-2-常量不允许被修改" class="headerlink" title="2.4.4.2 常量不允许被修改"></a>2.4.4.2 常量不允许被修改</h5><p>下例中，对常量重新赋值就会报错：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>
a = <span class="hljs-number">20</span></code></pre><h5 id="2-4-4-3-常量必须给值"><a href="#2-4-4-3-常量必须给值" class="headerlink" title="2.4.4.3 常量必须给值"></a>2.4.4.3 常量必须给值</h5><p>常量表示不可变的值，不给初始值，怎么让编译器去常量化呢？</p><pre><code class="hljs go"><span class="hljs-keyword">const</span>(
	a <span class="hljs-keyword">int</span>
	b
)</code></pre><h2 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h2><p>指定数据类型是告诉编译器，这个值需要分配多大的内存空间。</p><h3 id="3-1-总述"><a href="#3-1-总述" class="headerlink" title="3.1 总述"></a>3.1 总述</h3><h4 id="3-1-1-Go-语言中的数据类型"><a href="#3-1-1-Go-语言中的数据类型" class="headerlink" title="3.1.1 Go 语言中的数据类型"></a>3.1.1 Go 语言中的数据类型</h4><p>以下是 Go 语言中的数据类型：</p><table><thead><tr><th>类型</th><th>名称</th><th>长度</th><th>零值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>1</td><td>false</td><td>其值不为真即为假，不可以用数字代表true或false</td></tr><tr><td>byte</td><td>字节型</td><td>1</td><td>0</td><td>uint8别名</td></tr><tr><td>rune</td><td>字符类型</td><td>4</td><td>0</td><td>专用于存储unicode编码，等价于uint32</td></tr><tr><td>int, uint</td><td>整型</td><td>4或8</td><td>0</td><td>32位或64位</td></tr><tr><td>int8, uint8</td><td>整型</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255</td></tr><tr><td>int16, uint16</td><td>整型</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>整型</td><td>4</td><td>0</td><td>-21亿 ~ 21 亿, 0 ~ 42 亿</td></tr><tr><td>int64, uint64</td><td>整型</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>浮点型</td><td>4</td><td>0.0</td><td>小数位精确到7位</td></tr><tr><td>float64</td><td>浮点型</td><td>8</td><td>0.0</td><td>小数位精确到15位</td></tr><tr><td>complex64 复数类型</td><td>8</td><td></td><td></td><td></td></tr><tr><td>complex128 复数类型</td><td>16</td><td></td><td></td><td></td></tr><tr><td>uintptr 整型</td><td>4或8</td><td></td><td></td><td>以存储指针的uint32或uint64整数</td></tr><tr><td>string</td><td>字符串</td><td>“”</td><td></td><td>utf-8字符串</td></tr></tbody></table><h4 id="3-1-2-Go-语言的数据类型分类"><a href="#3-1-2-Go-语言的数据类型分类" class="headerlink" title="3.1.2 Go 语言的数据类型分类"></a>3.1.2 Go 语言的数据类型分类</h4><p>1.基础类型（Basic Types）。包括了：数值类型（支持整型、浮点型、复数）、字符串类型、布尔类型。<br>2.符合类型（Aggregate Types）。包括了：数组、结构体。<br>3.引用类型（Reference Types）。包括了：指针、切片、map、channel、接口、函数。</p><h4 id="3-1-3-注意数据类型的溢出"><a href="#3-1-3-注意数据类型的溢出" class="headerlink" title="3.1.3 注意数据类型的溢出"></a>3.1.3 注意数据类型的溢出</h4><p>每个数据类型都有一个固定的取值范围，数据类型的值，不能超过这个范围。<br>数据类型的溢出有 2 种：编译时、运行时。</p><h5 id="3-1-3-1-数据类型编译时的溢出"><a href="#3-1-3-1-数据类型编译时的溢出" class="headerlink" title="3.1.3.1 数据类型编译时的溢出"></a>3.1.3.1 数据类型编译时的溢出</h5><p>以下示例会导致编译时就报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> i <span class="hljs-keyword">uint8</span>
	<span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">270</span>; i++ &#123;
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment"># command-line-arguments</span>
<span class="hljs-comment">.\main.go:5:15: constant 270 overflows uint8</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">Compilation finished with exit code 2</span>
<span class="hljs-comment">*/</span></code></pre><p>这个示例就相当于语法错误了，数值已经溢出了该数据类型，编译都编不过。<br>使用 IDE，就会提示错误：</p><h5 id="3-1-3-2-数据类型运行时的溢出"><a href="#3-1-3-2-数据类型运行时的溢出" class="headerlink" title="3.1.3.2 数据类型运行时的溢出"></a>3.1.3.2 数据类型运行时的溢出</h5><p>以下示例会导致运行时的溢出：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> myint <span class="hljs-keyword">uint8</span>
	myint = <span class="hljs-number">250</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++ &#123;
		fmt.Println(myint)
		myint++
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">250</span>
<span class="hljs-comment">251</span>
<span class="hljs-comment">252</span>
<span class="hljs-comment">253</span>
<span class="hljs-comment">254</span>
<span class="hljs-comment">255</span>
<span class="hljs-comment">0</span>
<span class="hljs-comment">1</span>
<span class="hljs-comment">2</span>
<span class="hljs-comment">3</span>
<span class="hljs-comment">4</span>
<span class="hljs-comment">5</span>
<span class="hljs-comment">6</span>
<span class="hljs-comment">7</span>
<span class="hljs-comment">8</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">Process finished with exit code 0</span>
<span class="hljs-comment">*/</span></code></pre><p>这个示例属于逻辑错误，不会报错，但是会影响到最终的结果。</p><h3 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a>3.2 浮点型</h3><p>下例中，f2 会被自动推导成为 <code>float64</code> 类型：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	f2 := <span class="hljs-number">3.14</span>
	fmt.Printf(<span class="hljs-string">&quot;f2 type is : %T\n&quot;</span>, f2) <span class="hljs-comment">//f2 type is : float64</span>
&#125;</code></pre><p><code>float64</code> 比 <code>float32</code> 更加准确。使用自动推导类型的时候，浮点数会被推导成为 <code>float64</code> 类型。</p><h3 id="3-3-字符类型"><a href="#3-3-字符类型" class="headerlink" title="3.3 字符类型"></a>3.3 字符类型</h3><p>字符只是数值的特殊用例，Golang 使用数值来表示一个字符。<br>Golang 中，使用 <code>byte</code>、<code>int32</code>、<code>rune</code> 类型，来代表一个字符，一个字符由一对单引号 <code>&#39;&#39;</code> 包裹起来。<br><code>byte</code> 类型（字节类型），它的本质是 <code>uint8</code> 类型，存储的时候会以一个 <code>uint8</code> 数值进行存储。<br><code>int32</code> 类型，代表一个 <code>UTF-8</code> 字符。它还有另外一个书写方式：<code>rune</code>，两者是完全等价的，只是书写方式的不同而已（就像本名和小名，<code>int32</code> 是本名，<code>rune</code> 是小名）。</p><h4 id="3-3-1-用byte表示一个单字符"><a href="#3-3-1-用byte表示一个单字符" class="headerlink" title="3.3.1 用byte表示一个单字符"></a>3.3.1 用byte表示一个单字符</h4><p><code>byte</code> 类型的本质是用 <code>uint8</code> 类型进行存储，<code>uint8</code> 的范围是 <code>[0~255]</code>。使用 <code>byte</code> 类型存储一个字符的时候，注意不要超出 <code>uint8</code> 的范围。</p><h5 id="3-3-1-1-byte类型的基本使用"><a href="#3-3-1-1-byte类型的基本使用" class="headerlink" title="3.3.1.1 byte类型的基本使用"></a>3.3.1.1 byte类型的基本使用</h5><p>可以把 <code>[0~255]</code> 范围内的任意整数赋值给一个 <code>byte</code> 类型。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>
	ch = <span class="hljs-number">97</span>
	fmt.Println(<span class="hljs-string">&quot;ch =&quot;</span>, ch)        <span class="hljs-comment">//打印出数字97，因为Golang是使用一个整型数值来表示一个字符</span>
	fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="hljs-comment">//%c，指定以字符方式打印</span>

	fmt.Println(<span class="hljs-string">&quot;--------------------------&quot;</span>)

	ch = <span class="hljs-string">&#x27;A&#x27;</span>
	fmt.Println(<span class="hljs-string">&quot;ch =&quot;</span>, ch)
	<span class="hljs-comment">//%v是万能匹配格式符，表示该变量本身的值</span>
	<span class="hljs-comment">//因为Golang是使用一个整型数值来表示一个字符，因此ch本身的值就是一个整型数值</span>
	fmt.Printf(<span class="hljs-string">&quot;%%v=%v, %%c=%c\n&quot;</span>, ch, ch)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">ch = 97</span>
<span class="hljs-comment">a, 97</span>
<span class="hljs-comment">--------------------------</span>
<span class="hljs-comment">ch = 65</span>
<span class="hljs-comment">%v=65, %c=A</span>
<span class="hljs-comment">*/</span></code></pre><p>输出时，如果想要看到一个完整的字符，需要指定以字符 <code>%c</code> 格式显示，否则字符类型是以它本质的 <code>uint8</code> 数值来显示的。</p><h5 id="3-3-1-2-使用自动推导时，一个字符会被推导成-int32-类型"><a href="#3-3-1-2-使用自动推导时，一个字符会被推导成-int32-类型" class="headerlink" title="3.3.1.2 使用自动推导时，一个字符会被推导成 int32 类型"></a>3.3.1.2 使用自动推导时，一个字符会被推导成 <code>int32</code> 类型</h5><p>使用自动推导类型的时候，一个字符会被推导成 <code>int32</code> 类型。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	ch := <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">//&#x27;a&#x27;是一个字符</span>
	fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch) <span class="hljs-comment">//自动推导成int32类型</span>
	fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)        <span class="hljs-comment">//%v万能匹配格式符，表示该变量本身的值</span>
	fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)        <span class="hljs-comment">//%c指定以字符输出</span>

	fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)

	ch = <span class="hljs-string">&#x27;中&#x27;</span>
	fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)

	fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)

	ch = <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-comment">//英文状态下的逗号</span>
	fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)

	ch = <span class="hljs-string">&#x27;，&#x27;</span> <span class="hljs-comment">//中文状态下的逗号</span>
	fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)

	fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)

	ch = <span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment">//换行符</span>
	fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;%%c = %c&quot;</span>, ch) <span class="hljs-comment">//换行符是控制字符，不会直接显示，但会产生换行效果</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">ch =  97</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">%v = 97</span>
<span class="hljs-comment">%c = a</span>
<span class="hljs-comment">----------------------</span>
<span class="hljs-comment">ch =  20013</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">%v = 20013</span>
<span class="hljs-comment">%c = 中</span>
<span class="hljs-comment">----------------------</span>
<span class="hljs-comment">ch =  44</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">%v = 44</span>
<span class="hljs-comment">%c = ,</span>
<span class="hljs-comment">ch =  65292</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">%v = 65292</span>
<span class="hljs-comment">%c = ，</span>
<span class="hljs-comment">----------------------</span>
<span class="hljs-comment">ch =  10</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">%v = 10</span>
<span class="hljs-comment">%c = </span>
<span class="hljs-comment">//&#x27;\n&#x27;会产生换行效果，即使fmt.Printf()格式化字符串中不在末尾写&#x27;\n&#x27;，也会发生换行</span>
<span class="hljs-comment">*/</span></code></pre><p>可以看到，无论是单字符还是复合字符，就算本身是个 ASCII 码字符。只要用了自动推导类型，那么这个字符就会被推导成 <code>int32</code> 类型。<br>我个人猜想，Golang 并不能很明确地确定（或者判定时会影响一点性能）这个字符到底是单字符还是复合字符。所以就用了 <code>int32</code> 类型来保证能够存储任何类型字符，<code>int32</code> 类型也可以书写成 <code>rune</code> 类型，<code>rune</code> 类型的本质是 <code>int32</code> 类型。</p><h4 id="3-3-2-案例"><a href="#3-3-2-案例" class="headerlink" title="3.3.2 案例"></a>3.3.2 案例</h4><h5 id="3-3-2-1-案例1：英文字母大小写转换"><a href="#3-3-2-1-案例1：英文字母大小写转换" class="headerlink" title="3.3.2.1 案例1：英文字母大小写转换"></a>3.3.2.1 案例1：英文字母大小写转换</h5><p><code>byte</code> 本质上是 <code>uint8</code> 类型，所以两者可以直接相互转换、运算。格式化时，用 <code>%c</code> 来表示一个字符，用 <code>%d</code> 来表示整型数值。<br>英文字母大小写转换时，使用字符类型进行操作会非常好用。大小写之间的规律：大小写相差 32，小写的数值大。（大写 A 是 65，小写 a 是 97）<br>例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">&quot;大写A:%d，小写a: %d\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">//大写A:65，小写a:97</span>
	fmt.Printf(<span class="hljs-string">&quot;大写A转小写a: %c\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">32</span>)     <span class="hljs-comment">//大写A转小写a: a</span>
	fmt.Printf(<span class="hljs-string">&quot;小写a转大写A：%c\n&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">-32</span>)      <span class="hljs-comment">//小写a转大写A：A</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">大写A:65，小写a: 97</span>
<span class="hljs-comment">大写A转小写a: a</span>
<span class="hljs-comment">小写a转大写A：A</span>
<span class="hljs-comment">*/</span></code></pre><h5 id="3-3-2-2-案例2：计算英文单词每个字母加起来的值"><a href="#3-3-2-2-案例2：计算英文单词每个字母加起来的值" class="headerlink" title="3.3.2.2 案例2：计算英文单词每个字母加起来的值"></a>3.3.2.2 案例2：计算英文单词每个字母加起来的值</h5><h6 id="3-3-2-2-1-题目描述"><a href="#3-3-2-2-1-题目描述" class="headerlink" title="3.3.2.2.1 题目描述"></a>3.3.2.2.1 题目描述</h6><p>英语 26 个字母分别代表 1 到 26 的数字，编写一段代码，计算出单词的每个字母加起来等于多少。<br>例如：<br>hardwork（勤奋）8+1+18+4+23+15+18+11=98<br>knowledge（知识）11+14+15+23+12+5+4+7+5=96<br>love（爱）12+15+22+5=54<br>luck（运气）12+21+3+11=47<br>attitude（态度）1+20+20+9+20+21+4+5=100</p><h6 id="3-3-2-2-2-实现方式"><a href="#3-3-2-2-2-实现方式" class="headerlink" title="3.3.2.2.2 实现方式"></a>3.3.2.2.2 实现方式</h6><p>实现方式有很多，这里采用：对字符本身的 Unicode 码值的运算来实现。<br>实现思路：<br>Golang 中，字符串的存储方式是：采用 UTF-8 编码格式下的 Unicode 码值，进行存储。遍历字符串中的每个字符，都将得到这个字符的 Unicode 码值。<br>假设，输入的都是正确的英文单词。那么单词中的每个字母，它就是一个字符，可以得到它本身的 Unicode 码值。<br>通过减值的方式来确定字母的大小写。大写字母的范围是 [65 ~ 90]， 小写字母的范围是 [97 ~ 122]，任何一个大写字母减去 96，都会小于 1，因此遇到大写字母，需要减去 64，刚好能够对应上 26 个字母，由 1 到 26 的数值排列。小写字母直接减去 96，就能对应上了。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-comment">// 计算一个英文单词中的每个字母之和</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">computeletters</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int64</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> i, char := <span class="hljs-keyword">range</span> s &#123;
		<span class="hljs-comment">// 非英文字母的情况</span>
		<span class="hljs-comment">// 空格的 ASCII 码值为 32，需要把空格的情况添加进去</span>
		<span class="hljs-keyword">if</span> char != <span class="hljs-number">32</span> &amp;&amp; !(char &gt;= <span class="hljs-number">65</span> &amp;&amp; char &lt;= <span class="hljs-number">90</span>) &amp;&amp; !(char &gt;= <span class="hljs-number">97</span> &amp;&amp; char &lt;= <span class="hljs-number">122</span>) &#123;
			fmt.Printf(<span class="hljs-string">&quot;char:%c, index:%d. does not an english letter.\n&quot;</span>, char, i)
			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
		&#125;

		<span class="hljs-keyword">if</span> char == <span class="hljs-number">32</span> &#123;
			<span class="hljs-comment">// 遇到空格，什么都不做</span>
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> char<span class="hljs-number">-96</span> &lt; <span class="hljs-number">1</span> &#123;
			<span class="hljs-comment">// Unicode 值减去 96，小于了 1，说明这个英文字母是大写的，大写应该减 64</span>
			sum += <span class="hljs-keyword">int64</span>(char - <span class="hljs-number">64</span>)
		&#125; <span class="hljs-keyword">else</span> &#123;
			sum += <span class="hljs-keyword">int64</span>(char - <span class="hljs-number">96</span>)
		&#125;
	&#125;

	<span class="hljs-keyword">return</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	arr := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hardwork&quot;</span>, <span class="hljs-string">&quot;knowledge&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;luck&quot;</span>, <span class="hljs-string">&quot;attitude&quot;</span>&#125;

	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;
		v := computeletters(arr[i])
		fmt.Printf(<span class="hljs-string">&quot;word: %s, total value is:%d\n&quot;</span>, arr[i], v)
	&#125;
&#125;


<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">word: hardwork, total value is:98</span>
<span class="hljs-comment">word: knowledge, total value is:96</span>
<span class="hljs-comment">word: love, total value is:54</span>
<span class="hljs-comment">word: luck, total value is:47</span>
<span class="hljs-comment">word: attitude, total value is:100</span>
<span class="hljs-comment">*/</span></code></pre><p><code>byte</code> 类型的本质是 <code>uint8</code> 类型，<code>uint8</code> 类型是一个整型数值，范围 <code>[0~255]</code> 的整数，所以它能与另一个整型数值进行运算。</p><h4 id="3-3-2-用int32类型存储一个复合字符"><a href="#3-3-2-用int32类型存储一个复合字符" class="headerlink" title="3.3.2 用int32类型存储一个复合字符"></a>3.3.2 用int32类型存储一个复合字符</h4><p>当处理中文、日文或者其他复合字符时，则需要用 <code>int32</code> 类型来处理 Unicode 文本。<br><code>int32</code> 类型也可以书写成 <code>rune</code>，<code>rune</code> 类型本质就是 <code>int32</code> 类型。</p><h5 id="3-3-2-1-存储一个中文字符的方式"><a href="#3-3-2-1-存储一个中文字符的方式" class="headerlink" title="3.3.2.1 存储一个中文字符的方式"></a>3.3.2.1 存储一个中文字符的方式</h5><p>先看一个错误的示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>
	ch = <span class="hljs-string">&#x27;中&#x27;</span> <span class="hljs-comment">//这行会报错：constant 20013 overflows byte，超出了ASCII码的范围</span>
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)
&#125;</code></pre><p>注意：<code>byte</code> 的范围是 <code>[0~255]</code>，20013 明显超出了范围！<br>接下来，使用自动推导的技巧来实现存储一个中文字符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	ch := <span class="hljs-string">&#x27;中&#x27;</span>
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch) <span class="hljs-comment">//int32</span>
	fmt.Printf(<span class="hljs-string">&quot;using %%v, ch = %v\n&quot;</span>, ch)
	fmt.Printf(<span class="hljs-string">&quot;using %%c, ch = %c\n&quot;</span>, ch)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">ch type is : int32</span>
<span class="hljs-comment">using %v, ch = 20013</span>
<span class="hljs-comment">using %c, ch = 中</span>
<span class="hljs-comment">*/</span></code></pre><p>与 3.3.1.2 中的示例演示一样：使用自动推导的时候，一个中文字符会被推导成为 <code>int32</code> 类型。</p><h4 id="3-3-4-int32和rune的关系以及区别"><a href="#3-3-4-int32和rune的关系以及区别" class="headerlink" title="3.3.4 int32和rune的关系以及区别"></a>3.3.4 int32和rune的关系以及区别</h4><h5 id="3-3-4-1-int32和rune之间的关系"><a href="#3-3-4-1-int32和rune之间的关系" class="headerlink" title="3.3.4.1 int32和rune之间的关系"></a>3.3.4.1 int32和rune之间的关系</h5><p>等价的关系。<code>rune</code> 只是 <code>int32</code> 的一个别名，在功能上完全等价。</p><h5 id="3-3-4-2-见名知意的区别"><a href="#3-3-4-2-见名知意的区别" class="headerlink" title="3.3.4.2 见名知意的区别"></a>3.3.4.2 见名知意的区别</h5><p>用于更好地让程序猿区分，这个变量是字节值还是无符号整数值。用 <code>rune</code> 来表示一个字符值，用 <code>int32</code> 来表示一个整数值。<br>让人一看这个数据类型就能知道，这个变量的最终用途是什么。<br>例如：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	chars := []<span class="hljs-keyword">rune</span>&#123;<span class="hljs-number">443</span>, <span class="hljs-number">27017</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">3306</span>&#125;
	fmt.Println(<span class="hljs-keyword">string</span>(chars)) <span class="hljs-comment">//最终作为字符来呈现</span>

	commonPorts := []<span class="hljs-keyword">int32</span>&#123;<span class="hljs-number">443</span>, <span class="hljs-number">27017</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">3306</span>&#125;
	fmt.Println(<span class="hljs-string">&quot;there are some common ports: &quot;</span>, commonPorts) <span class="hljs-comment">//最终作为数值来呈现</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">ƻ榉ᣫ೪</span>
<span class="hljs-comment">there are some common ports:  [443 27017 6379 3306]</span>
<span class="hljs-comment">*/</span></code></pre><p>看到 <code>rune</code> 就知道，最终呈现的是字符；看到 <code>int32</code> 就知道，最终显示数值。个人认为，<code>int32</code> 和 <code>rune</code> 的区别就是见名知意的作用：看它们的数据类型就知道了该数据的最终意图和呈现方式。</p><h4 id="3-3-5-转义字符"><a href="#3-3-5-转义字符" class="headerlink" title="3.3.5 转义字符"></a>3.3.5 转义字符</h4><p>有两种字符：一种是控制字符，另一种是可显示字符。<br>可显示字符就是可以输出，能看得到内容的字符。<br>控制字符就是转义字符，有特殊的含义，是不可见的。以反斜杠 <code>\</code> 开头的是转义字符。<br>例1：先看这个例子：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">&quot;hello go&quot;</span>)
	fmt.Printf(<span class="hljs-string">&quot;abcdefg&quot;</span>)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">hello goabcdefg</span>
<span class="hljs-comment">//没有换行符，内容会紧跟在上一行的内容后面</span>
<span class="hljs-comment">/*</span></code></pre><p>例2：<br><code>\n</code> 不会输出到屏幕上，是看不见的。但它会进行换行操作，属于功能性的字符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">&quot;hello go%c&quot;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)
	fmt.Printf(<span class="hljs-string">&quot;abcdefg&quot;</span>)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">hello go</span>
<span class="hljs-comment">abcdefg</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="3-3-6-注意事项"><a href="#3-3-6-注意事项" class="headerlink" title="3.3.6 注意事项"></a>3.3.6 注意事项</h4><h5 id="3-3-6-1-字符只能使用一对单引号包裹起来"><a href="#3-3-6-1-字符只能使用一对单引号包裹起来" class="headerlink" title="3.3.6.1 字符只能使用一对单引号包裹起来"></a>3.3.6.1 字符只能使用一对单引号包裹起来</h5><p>一个字符只能使用一对单引号<code>&#39;&#39;</code>包裹起来！<br>下例中，ch = “a” 这行代码会报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>
	ch = <span class="hljs-string">&quot;a&quot;</span>    <span class="hljs-comment">//报错：cannot use &quot;a&quot; (type string) as type byte in assignment（不能使用字符串作为byte字符的值）</span>
	fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch)
&#125;</code></pre><p>下例是能够正确运行的：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>
	ch = <span class="hljs-string">&#x27;a&#x27;</span>
	fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="hljs-comment">//a, 97</span>
&#125;</code></pre><h5 id="3-3-6-2-一对单引号-39-39-中，只能放一个字符"><a href="#3-3-6-2-一对单引号-39-39-中，只能放一个字符" class="headerlink" title="3.3.6.2 一对单引号 &#39;&#39; 中，只能放一个字符"></a>3.3.6.2 一对单引号 <code>&#39;&#39;</code> 中，只能放一个字符</h5><p><code>a := &#39;abc&#39;</code>会报错</p><h5 id="3-3-6-3-byte类型的范围"><a href="#3-3-6-3-byte类型的范围" class="headerlink" title="3.3.6.3 byte类型的范围"></a>3.3.6.3 byte类型的范围</h5><p><code>byte</code> 类型实质上是一个 <code>uint8</code> 类型，<code>uint8</code> 的范围是 <code>[0 ~ 255]</code>（0 和 255 都能被取到），不在这个范围就是值溢出，会报错！<br>数值不在 <code>uint8</code> 范围内的错误示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>
	ch = <span class="hljs-number">256</span>
	fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch)
	<span class="hljs-comment">/* 报错内容如下：</span>
<span class="hljs-comment">	# command-line-arguments</span>
<span class="hljs-comment">	.\main.go:7:7: constant 256 overflows byte</span>
<span class="hljs-comment">	*/</span>
&#125;</code></pre><h4 id="3-3-7-ASCII码参考表"><a href="#3-3-7-ASCII码参考表" class="headerlink" title="3.3.7 ASCII码参考表"></a>3.3.7 ASCII码参考表</h4><table><thead><tr><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><h3 id="3-4-字符串类型"><a href="#3-4-字符串类型" class="headerlink" title="3.4 字符串类型"></a>3.4 字符串类型</h3><p>由多个字符所组成的一串内容，被称为字符串。一个字符串需要用双引号 <code>&quot;&quot;</code> 包裹起来！<br>Golang 中的字符串以 <code>UTF-8</code> 编码方式存储，处理字符串也是采用 <code>UTF-8</code> 的编码方式，每个字符串都是 <code>Unicode</code> 字符集。</p><h4 id="3-4-1-rune-类型是数值类型，与字符串类型不兼容"><a href="#3-4-1-rune-类型是数值类型，与字符串类型不兼容" class="headerlink" title="3.4.1 rune 类型是数值类型，与字符串类型不兼容"></a>3.4.1 <code>rune</code> 类型是数值类型，与字符串类型不兼容</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> str1 <span class="hljs-keyword">string</span>
	str1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// 报错：Cannot use &#x27;&#x27;abc&#x27;&#x27; (type rune) as type string in assignment</span>
	fmt.Println(str1)
&#125;</code></pre><p><code>str1 = &#39;abc&#39;</code>这行会报错！字符只能使用单引号 <code>&#39;&#39;</code> 包裹起来，使用双引号 <code>&quot;&quot;</code> 包裹的是字符串！</p><h4 id="3-4-2-字符串的截取是以字节为单位"><a href="#3-4-2-字符串的截取是以字节为单位" class="headerlink" title="3.4.2 字符串的截取是以字节为单位"></a>3.4.2 字符串的截取是以字节为单位</h4><p>使用 <code>len()</code> 函数获取字符串长度时，获取到的是该 <code>UTF-8</code> 编码字符串的字节长度。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我是&quot;</span> <span class="hljs-comment">// 字符串中是两个中文汉字</span>

	fmt.Println(<span class="hljs-string">&quot;len(c)=&quot;</span>, <span class="hljs-built_in">len</span>(s))

	fmt.Printf(<span class="hljs-string">&quot;s[1], value=%v, char=%c\n&quot;</span>, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">1</span>])
	fmt.Println(<span class="hljs-string">&quot;s[:3]=&quot;</span>, s[:<span class="hljs-number">2</span>])
	fmt.Println(<span class="hljs-string">&quot;s[:3]=&quot;</span>, s[:<span class="hljs-number">3</span>])
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">len(c)= 6</span>
<span class="hljs-comment">s[1], value=136, char=ˆ</span>
<span class="hljs-comment">s[:3]= �</span>
<span class="hljs-comment">s[:3]= 我</span>
<span class="hljs-comment">*/</span></code></pre><p>在中文字符串中肆意乱截取，很大概率会输出乱码。<br>由 len(s) 可以得知，此例中字符串 s 的长度为 6，而字符串中只有 2 个汉字。因此，在 Golang 中，一个汉字占 3 个字节。一个汉字由 3 个字节编码而成，使用下标取值时，只是取到了某一个字节的值而已。</p><h4 id="3-4-3-对字符串的索引，只会一个-byte-值"><a href="#3-4-3-对字符串的索引，只会一个-byte-值" class="headerlink" title="3.4.3 对字符串的索引，只会一个 byte 值"></a>3.4.3 对字符串的索引，只会一个 <code>byte</code> 值</h4><p>Golang 使用 <code>UTF-8</code> 编码方式存储、处理字符串，最终是以 <code>Unicode</code> 字符集的形式来表现字符串。<code>Unicode</code> 字符集最终也是用整数数值的方式来呈现的。<br>因此，对字符串的索引操作，会返回一个 <code>byte</code> 值，而不是一个具体显示内容的字符。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我是gopher&quot;</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;
		fmt.Printf(<span class="hljs-string">&quot;s[%d], %%d=%d, %%c=%c\n&quot;</span>, i, s[i], s[i])
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">s[0], %d=230, %c=æ</span>
<span class="hljs-comment">s[1], %d=136, %c=ˆ</span>
<span class="hljs-comment">s[2], %d=145, %c=‘</span>
<span class="hljs-comment">s[3], %d=230, %c=æ</span>
<span class="hljs-comment">s[4], %d=152, %c=˜</span>
<span class="hljs-comment">s[5], %d=175, %c=¯</span>
<span class="hljs-comment">s[6], %d=103, %c=g</span>
<span class="hljs-comment">s[7], %d=111, %c=o</span>
<span class="hljs-comment">s[8], %d=112, %c=p</span>
<span class="hljs-comment">s[9], %d=104, %c=h</span>
<span class="hljs-comment">s[10], %d=101, %c=e</span>
<span class="hljs-comment">s[11], %d=114, %c=r</span>
<span class="hljs-comment">*/</span></code></pre><p>如果字符串中含有中文字符（一个中文字符在 <code>UTF-8</code> 编码方式下，占 3 个字节）。因为是由 3 个字节编码而成，如果按照索引来取含有 <code>UTF-8</code> 编码的字符，就会出现乱码。</p><h4 id="3-4-4-遍历中英文混合字符串的示例"><a href="#3-4-4-遍历中英文混合字符串的示例" class="headerlink" title="3.4.4 遍历中英文混合字符串的示例"></a>3.4.4 遍历中英文混合字符串的示例</h4><p><code>UTF-8</code> 是一种变长的编码方式，字符长度从 1 个字节到 4 个字节不等。而 <code>byte</code> 类型只占 1 个字节。就算你想要使用多个 <code>byte</code> 进行表示，但也无从知晓要处理的 <code>UTF-8</code> 字符究竟占了几个字节。<br>利用 <code>[]int32()</code> 和 <code>[]rune()</code> 将字符串转为 <code>Unicode</code> 字符集（<code>Unicode</code> 的数值），再进行截取。这样就无需考虑字符串中是否含有 <code>UTF-8</code> 字符的情况了。</p><h5 id="3-4-4-1-int32-写法"><a href="#3-4-4-1-int32-写法" class="headerlink" title="3.4.4.1 []int32() 写法"></a>3.4.4.1 <code>[]int32()</code> 写法</h5><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我是gopher&quot;</span>

	fmt.Println(<span class="hljs-string">&quot;s=&quot;</span>, s) <span class="hljs-comment">//fmt.Print()系列函数是输出内容的本身</span>

	<span class="hljs-comment">//Golang使用UTF-8编码方式将字符串存储成Unicode字符集</span>
	<span class="hljs-comment">//UTF-8编码方式下，一个中文占3个字节</span>
	<span class="hljs-comment">//[:2]只是取到了前两个字节值而已，所以显示了乱码</span>
	fmt.Println(<span class="hljs-string">&quot;s[:2]=&quot;</span>, s[:<span class="hljs-number">2</span>])
	fmt.Println(<span class="hljs-string">&quot;s[1]=&quot;</span>, s[<span class="hljs-number">1</span>])

	<span class="hljs-comment">//遍历取到的是字符串中的每个字符。如果是中文字符，那么依然是占3个字节，遍历的时候也是取了3个字节</span>
	<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;
		<span class="hljs-comment">//格式化打印是直接显示原本的字符内容</span>
		fmt.Printf(<span class="hljs-string">&quot;s[%d] : unicode=%v, %%c=%c\n&quot;</span>, i, v, v)
	&#125;

	fmt.Println(<span class="hljs-string">&quot;----------------------------------------&quot;</span>)

	<span class="hljs-comment">//利用[]int32()将字符串存储为Unicode字符集</span>
	unicodeString := []<span class="hljs-keyword">int32</span>(s)
	fmt.Println(<span class="hljs-string">&quot;unicodeString value : &quot;</span>, unicodeString) <span class="hljs-comment">//显示的是Unicode字符的数值</span>
	fmt.Println(<span class="hljs-string">&quot;unicodeString[:3] : &quot;</span>, unicodeString[:<span class="hljs-number">3</span>])

	<span class="hljs-comment">//遍历的是Unicode字符集切片</span>
	<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> unicodeString &#123;
		fmt.Printf(<span class="hljs-string">&quot;s[%d] = %v\n&quot;</span>, i, v)
	&#125;

	<span class="hljs-comment">//截取到的是Unicode切片中的前2个值</span>
	<span class="hljs-comment">//将这2个值转换为字符串之后再输出</span>
	fmt.Println(<span class="hljs-keyword">string</span>(unicodeString[:<span class="hljs-number">2</span>]))
	fmt.Println(unicodeString[:<span class="hljs-number">2</span>]) <span class="hljs-comment">//不转换成字符串只会输出原本的内容。fmt.Print()系列函数是输出内容的本身</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">s= 我是gopher</span>
<span class="hljs-comment">s[:2]= �</span>
<span class="hljs-comment">s[1]= 136</span>
<span class="hljs-comment">s[0] : unicode=25105, %c=我</span>
<span class="hljs-comment">s[3] : unicode=26159, %c=是</span>
<span class="hljs-comment">s[6] : unicode=103, %c=g</span>
<span class="hljs-comment">s[7] : unicode=111, %c=o</span>
<span class="hljs-comment">s[8] : unicode=112, %c=p</span>
<span class="hljs-comment">s[9] : unicode=104, %c=h</span>
<span class="hljs-comment">s[10] : unicode=101, %c=e</span>
<span class="hljs-comment">s[11] : unicode=114, %c=r</span>
<span class="hljs-comment">----------------------------------------</span>
<span class="hljs-comment">unicodeString value :  [25105 26159 103 111 112 104 101 114]</span>
<span class="hljs-comment">unicodeString[:3] :  [25105 26159 103]</span>
<span class="hljs-comment">s[0] = 25105</span>
<span class="hljs-comment">s[1] = 26159</span>
<span class="hljs-comment">s[2] = 103</span>
<span class="hljs-comment">s[3] = 111</span>
<span class="hljs-comment">s[4] = 112</span>
<span class="hljs-comment">s[5] = 104</span>
<span class="hljs-comment">s[6] = 101</span>
<span class="hljs-comment">s[7] = 114</span>
<span class="hljs-comment">我是</span>
<span class="hljs-comment">[25105 26159]</span>
<span class="hljs-comment">*/</span></code></pre><h5 id="3-4-4-2-与-int32-等价的-rune-写法"><a href="#3-4-4-2-与-int32-等价的-rune-写法" class="headerlink" title="3.4.4.2 与 []int32() 等价的 []rune() 写法"></a>3.4.4.2 与 <code>[]int32()</code> 等价的 <code>[]rune()</code> 写法</h5><p><code>[]rune()</code> 将字符串转换为 <code>Unicode</code> 码点。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我爱 Golang！&quot;</span> <span class="hljs-comment">//感叹号是中文的</span>

	unicodeRune := []<span class="hljs-keyword">rune</span>(s)

	fmt.Println(<span class="hljs-string">&quot;unicode value : &quot;</span>, unicodeRune)
	fmt.Println(<span class="hljs-string">&quot;unicodeRune[:2], unicode value : &quot;</span>, unicodeRune[:<span class="hljs-number">2</span>])
	fmt.Println(<span class="hljs-string">&quot;string(unicodeRune[:2]) = &quot;</span>, <span class="hljs-keyword">string</span>(unicodeRune[:<span class="hljs-number">2</span>]))
	fmt.Println(<span class="hljs-string">&quot;string(unicodeRune) : &quot;</span>, <span class="hljs-keyword">string</span>(unicodeRune))
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">unicode value :  [25105 29233 32 71 111 108 97 110 103 65281]</span>
<span class="hljs-comment">unicodeRune[:2], unicode value :  [25105 29233]</span>
<span class="hljs-comment">string(unicodeRune[:2]) =  我爱</span>
<span class="hljs-comment">string(unicodeRune) :  我爱 Golang！</span>
<span class="hljs-comment">*/</span></code></pre><p>与 3.4.4.1 示例中的原理一致：<code>[]int32()</code> 和 <code>[]rune()</code> 都是将字符串转换成 <code>Unicode</code> 字符数值。无论是截取还是直接打印，得到的都将是 <code>Unicode</code> 数值。若想要看到正常的文字内容，需要将 <code>Unicode</code> 数值转换为字符串后再打印。<br>注：<code>Unicode</code> 和 <code>ASCII</code> 一样，都是一种字符集，<code>UTF-8</code> 是一种编码格式。</p><h5 id="3-4-4-3-range-遍历字符串"><a href="#3-4-4-3-range-遍历字符串" class="headerlink" title="3.4.4.3 range 遍历字符串"></a>3.4.4.3 <code>range</code> 遍历字符串</h5><p><code>range</code> 遍历字符串，得到的是 <code>rune</code> 类型的字符。</p><h6 id="3-4-4-3-1-获取下标的时候，得到的是-uint8-类型"><a href="#3-4-4-3-1-获取下标的时候，得到的是-uint8-类型" class="headerlink" title="3.4.4.3.1 获取下标的时候，得到的是 uint8 类型"></a>3.4.4.3.1 获取下标的时候，得到的是 <code>uint8</code> 类型</h6><p>使用 <code>range</code> 遍历字符串，通过下标去取字符串中的值，得到的是单个字符，字符的本质类型则是 <code>uint8</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我是gopher&quot;</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;
		fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, s[i])
	&#125;

	fmt.Println(<span class="hljs-string">&quot;-------- 以下示例为了区别 range 遍历 --------&quot;</span>)

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;
		fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, s[i])
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">current i=0, %d=230, %c=æ, %T=uint8</span>
<span class="hljs-comment">current i=3, %d=230, %c=æ, %T=uint8</span>
<span class="hljs-comment">current i=6, %d=103, %c=g, %T=uint8</span>
<span class="hljs-comment">current i=7, %d=111, %c=o, %T=uint8</span>
<span class="hljs-comment">current i=8, %d=112, %c=p, %T=uint8</span>
<span class="hljs-comment">current i=9, %d=104, %c=h, %T=uint8</span>
<span class="hljs-comment">current i=10, %d=101, %c=e, %T=uint8</span>
<span class="hljs-comment">current i=11, %d=114, %c=r, %T=uint8</span>
<span class="hljs-comment">-------- 以下示例为了区别 range 遍历 --------</span>
<span class="hljs-comment">current i=0, %d=230, %c=æ, %T=uint8</span>
<span class="hljs-comment">current i=1, %d=136, %c=ˆ, %T=uint8</span>
<span class="hljs-comment">current i=2, %d=145, %c=‘, %T=uint8</span>
<span class="hljs-comment">current i=3, %d=230, %c=æ, %T=uint8</span>
<span class="hljs-comment">current i=4, %d=152, %c=˜, %T=uint8</span>
<span class="hljs-comment">current i=5, %d=175, %c=¯, %T=uint8</span>
<span class="hljs-comment">current i=6, %d=103, %c=g, %T=uint8</span>
<span class="hljs-comment">current i=7, %d=111, %c=o, %T=uint8</span>
<span class="hljs-comment">current i=8, %d=112, %c=p, %T=uint8</span>
<span class="hljs-comment">current i=9, %d=104, %c=h, %T=uint8</span>
<span class="hljs-comment">current i=10, %d=101, %c=e, %T=uint8</span>
<span class="hljs-comment">current i=11, %d=114, %c=r, %T=uint8</span>
<span class="hljs-comment">*/</span></code></pre><p>两段代码有一点区别：<code>for i := range s</code> 只出现了 2 个乱码，而 <code>for i := 0; i &lt; len(s); i++</code> 出现了 6 个乱码。<br>原因：<br>Golang 中，字符串是以 <code>UTF-8</code> 编码格式存放的 <code>Unicode</code> 字符码点，一个中文占 3 个编码字节。<br><code>for i := range s</code> 的时候，虽然是以 <code>[]rune</code> 类型在遍历。但遇到了通过下标去获取字符串中的内容（相当于指定去取字符串中，某个下标值中的内容），只能取到对应下标中的字节码值。第一次，<code>i</code> 是初始值 <code>0</code>；第二次，<code>i</code> 的值则变成了 <code>3</code>。所以，只是对应地去取了这 2 个下标中的内容。<br>而 <code>for i := 0; i &lt; len(s); i++</code> 的时候，就不再是遍历 <code>[]rune</code> 类型了，是逐个逐个地遍历每一个字节，把字符串中的每个字节都遍历到了。</p><h6 id="3-4-4-3-2-获取值的时候，得到的是-int32-类型"><a href="#3-4-4-3-2-获取值的时候，得到的是-int32-类型" class="headerlink" title="3.4.4.3.2 获取值的时候，得到的是 int32 类型"></a>3.4.4.3.2 获取值的时候，得到的是 <code>int32</code> 类型</h6><p>使用 <code>range</code> 遍历字符串的时候，值的部分是 <code>int32</code> 类型。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s := <span class="hljs-string">&quot;我是gopher&quot;</span>

	<span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;
		fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, c)
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">current i=0, %d=25105, %c=我, %T=int32</span>
<span class="hljs-comment">current i=3, %d=26159, %c=是, %T=int32</span>
<span class="hljs-comment">current i=6, %d=103, %c=g, %T=int32</span>
<span class="hljs-comment">current i=7, %d=111, %c=o, %T=int32</span>
<span class="hljs-comment">current i=8, %d=112, %c=p, %T=int32</span>
<span class="hljs-comment">current i=9, %d=104, %c=h, %T=int32</span>
<span class="hljs-comment">current i=10, %d=101, %c=e, %T=int32</span>
<span class="hljs-comment">current i=11, %d=114, %c=r, %T=int32</span>
<span class="hljs-comment">*/</span></code></pre><p>使用 <code>range</code> 遍历字符串，分别得到下标和具体的值。因为一个中文字符在 Golang 的 <code>UTF-8</code> 编码下占 3 个字节，所以此例中，占用的下标就是 [0 ~ 2]、[3 ~ 5]。<br><code>rune</code> 是 <code>int32</code> 的别名，因此打印类型时，就显示了 <code>rune</code> 它本身的数据类型。</p><h5 id="3-4-4-4-参考文献"><a href="#3-4-4-4-参考文献" class="headerlink" title="3.4.4.4 参考文献"></a>3.4.4.4 参考文献</h5><blockquote><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903998634328078">https://juejin.im/post/6844903998634328078</a></p></blockquote><h4 id="3-4-5-如何修改字符串中的某个元素"><a href="#3-4-5-如何修改字符串中的某个元素" class="headerlink" title="3.4.5 如何修改字符串中的某个元素"></a>3.4.5 如何修改字符串中的某个元素</h4><p>我想要修改字符串中的某个元素，如何操作？</p><h5 id="3-4-5-1-错误警示"><a href="#3-4-5-1-错误警示" class="headerlink" title="3.4.5.1 错误警示"></a>3.4.5.1 错误警示</h5><p>直接对下标中的元素进行修改：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	str := <span class="hljs-string">&quot;hello&quot;</span>
	str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">//报错：cannot assign to str[0]</span>
	fmt.Println(str)
&#125;</code></pre><p>编译就通不过，直接报错。原因：<strong>在 Golang 中，字符串是不可变的</strong>。</p><h5 id="3-4-5-2-正确的操作"><a href="#3-4-5-2-正确的操作" class="headerlink" title="3.4.5.2 正确的操作"></a>3.4.5.2 正确的操作</h5><p>使用 <code>[]byte()</code> 或 <code>[]rune()</code>，先将一个字符串转换成字节切片类型，然后对某个下标中的元素进行修改，最后使用 <code>string()</code> 转换回字符串。</p><h6 id="3-4-5-2-1-单字符构成的字符串"><a href="#3-4-5-2-1-单字符构成的字符串" class="headerlink" title="3.4.5.2.1 单字符构成的字符串"></a>3.4.5.2.1 单字符构成的字符串</h6><p>如果这个字符串都是有单字符构成，那么先将这个字符串转换为 <code>[]byte</code> 类型后，再修改某个下标中的元素，最后将这个 <code>[]byte</code> 类型使用 <code>string()</code> 转换回来。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	str := <span class="hljs-string">&quot;hello&quot;</span>
	b := []<span class="hljs-keyword">byte</span>(str) <span class="hljs-comment">//先转换成 []byte 类型</span>
	fmt.Println(b)

	b[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>
	str = <span class="hljs-keyword">string</span>(b) <span class="hljs-comment">//再将 []byte 类型转换回字符串类型</span>
	fmt.Println(str)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">[104 101 108 108 111]</span>
<span class="hljs-comment">xello</span>
<span class="hljs-comment">*/</span></code></pre><h6 id="3-4-5-2-2-字符串中有复合字符"><a href="#3-4-5-2-2-字符串中有复合字符" class="headerlink" title="3.4.5.2.2 字符串中有复合字符"></a>3.4.5.2.2 字符串中有复合字符</h6><p>如果一个字符串有复合字符，那么就需要使用 <code>[]rune</code> 或 <code>[]int32</code> 来转换。转换成字节后才能修改，最后依然用 <code>string()</code> 转换回字符串。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	str := <span class="hljs-string">&quot;go 你好&quot;</span>
	b := []<span class="hljs-keyword">rune</span>(str) <span class="hljs-comment">// []int32() 也可以</span>
	fmt.Println(str, <span class="hljs-string">&quot;,&quot;</span>, b)

	fmt.Println(<span class="hljs-keyword">rune</span>(<span class="hljs-string">&#x27;很&#x27;</span>)) <span class="hljs-comment">//单个字符转换，也可以直接写成：fmt.Println(&#x27;很&#x27;)</span>

	b[<span class="hljs-number">3</span>] = <span class="hljs-number">24456</span>
	str = <span class="hljs-keyword">string</span>(b)
	fmt.Println(str)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">go 你好 , [103 111 32 20320 22909]</span>
<span class="hljs-comment">24456</span>
<span class="hljs-comment">go 很好</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="3-4-6-其他类型与字符串的转换"><a href="#3-4-6-其他类型与字符串的转换" class="headerlink" title="3.4.6 其他类型与字符串的转换"></a>3.4.6 其他类型与字符串的转换</h4><h5 id="3-4-6-1-十六进制转换为字符串"><a href="#3-4-6-1-十六进制转换为字符串" class="headerlink" title="3.4.6.1 十六进制转换为字符串"></a>3.4.6.1 十六进制转换为字符串</h5><p>有一个字符串切片，里面的每个元素都是以字符串形式保存的十六进制值。现在要将这些十六进制值，转换为其原本的明文字符内容。</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;strconv&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	original := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;30d7&quot;</span>, <span class="hljs-string">&quot;30ed&quot;</span>, <span class="hljs-string">&quot;30b0&quot;</span>, <span class="hljs-string">&quot;30e9&quot;</span>, <span class="hljs-string">&quot;30e0&quot;</span>&#125;

	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> original &#123;
		<span class="hljs-keyword">if</span> s, err := strconv.ParseInt(v, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>); err == <span class="hljs-literal">nil</span> &#123;
			fmt.Printf(<span class="hljs-string">&quot;%T\t%d\t%c\n&quot;</span>, v, s, s)
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-built_in">panic</span>(err)
		&#125;
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">string	12503	プ</span>
<span class="hljs-comment">string	12525	ロ</span>
<span class="hljs-comment">string	12464	グ</span>
<span class="hljs-comment">string	12521	ラ</span>
<span class="hljs-comment">string	12512	ム</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="3-4-7-高性能字符串拼接的几个方式"><a href="#3-4-7-高性能字符串拼接的几个方式" class="headerlink" title="3.4.7 高性能字符串拼接的几个方式"></a>3.4.7 高性能字符串拼接的几个方式</h4><p>将以下几个字符串拼接方式，都放入单独的函数中，最后使用 Go 语言自带的 <code>Benchmark</code> 进行简单的性能测试。<br>设置 1000 次拼接，因此：<code>const Loop = 1000</code></p><h5 id="3-4-7-1-使用-strings-Builder"><a href="#3-4-7-1-使用-strings-Builder" class="headerlink" title="3.4.7.1 使用 strings.Builder"></a>3.4.7.1 使用 <code>strings.Builder</code></h5><p>它使用零值、不拷贝零值、使用内存最小。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrBuilder</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> str strings.Builder

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		str.WriteString(<span class="hljs-string">&quot;a&quot;</span>)
	&#125;
&#125;</code></pre><p>注：<strong>不要拷贝 strings.Builder 的值</strong>。</p><h5 id="3-4-7-2-使用-bytes-Buffer"><a href="#3-4-7-2-使用-bytes-Buffer" class="headerlink" title="3.4.7.2 使用 bytes.Buffer"></a>3.4.7.2 使用 <code>bytes.Buffer</code></h5><p><code>bytes</code> 包的 <code>Buffer</code> 实现了 <code>io.Writer</code> 的接口，使用 <code>bytes.Buffer</code> 的 <code>WriteString()</code> 方法去拼接字符串，时间复杂度为 <code>O(n)</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BytesBuffer</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> buffer bytes.Buffer

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		buffer.WriteString(<span class="hljs-string">&quot;a&quot;</span>)
	&#125;
&#125;</code></pre><h5 id="3-4-7-3-使用内建函数-copy"><a href="#3-4-7-3-使用内建函数-copy" class="headerlink" title="3.4.7.3 使用内建函数 copy"></a>3.4.7.3 使用内建函数 <code>copy</code></h5><p>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GoCopy</span><span class="hljs-params">()</span></span> &#123;
	bs := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, Loop)
	bl := <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		bl += <span class="hljs-built_in">copy</span>(bs[bl:], <span class="hljs-string">&quot;a&quot;</span>)
	&#125;
&#125;</code></pre><h5 id="3-4-7-4-使用内建函数-append"><a href="#3-4-7-4-使用内建函数-append" class="headerlink" title="3.4.7.4 使用内建函数 append"></a>3.4.7.4 使用内建函数 <code>append</code></h5><p>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GoAppend</span><span class="hljs-params">()</span></span> &#123;
	bs := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, Loop)

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		bs = <span class="hljs-built_in">append</span>(bs, <span class="hljs-string">&#x27;a&#x27;</span>)
	&#125;
&#125;</code></pre><h5 id="3-4-7-5-加号拼接"><a href="#3-4-7-5-加号拼接" class="headerlink" title="3.4.7.5 加号拼接"></a>3.4.7.5 加号拼接</h5><p>使用加号 <code>+</code> 进行拼接。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrPlus</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> result <span class="hljs-keyword">string</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		result += <span class="hljs-string">&quot;a&quot;</span>
	&#125;
&#125;</code></pre><h5 id="3-4-7-6-使用-strings-Repeat"><a href="#3-4-7-6-使用-strings-Repeat" class="headerlink" title="3.4.7.6 使用 strings.Repeat"></a>3.4.7.6 使用 <code>strings.Repeat</code></h5><p>将 N 个字符串 s，连接成一个新的字符串。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrRepeat</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;
		strings.Repeat(<span class="hljs-string">&quot;a&quot;</span>, Loop)
	&#125;
&#125;</code></pre><h5 id="3-4-7-7-编写-Benchmark-测试代码"><a href="#3-4-7-7-编写-Benchmark-测试代码" class="headerlink" title="3.4.7.7 编写 Benchmark 测试代码"></a>3.4.7.7 编写 <code>Benchmark</code> 测试代码</h5><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrBuilder</span><span class="hljs-params">(b *testing.B)</span></span> &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		StrBuilder()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBytesBuffer</span><span class="hljs-params">(b *testing.B)</span></span> &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		BytesBuffer()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGoCopy</span><span class="hljs-params">(b *testing.B)</span></span> &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		GoCopy()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGoAppend</span><span class="hljs-params">(b *testing.B)</span></span> &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		GoAppend()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrPlus</span><span class="hljs-params">(b *testing.B)</span></span>  &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		StrPlus()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrRepeat</span><span class="hljs-params">(b *testing.B)</span></span> &#123;
	b.ResetTimer()

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;
		StrRepeat()
	&#125;
&#125;</code></pre><h5 id="3-4-7-8-总结"><a href="#3-4-7-8-总结" class="headerlink" title="3.4.7.8 总结"></a>3.4.7.8 总结</h5><p>在确切知道有多少内容的情况下，可以提前将 <code>append()</code> 和 <code>copy()</code> 这两个内建函数的容量值（也就是 <code>cap</code> ），给申请下来，避免了 <code>cap</code> 的重复检查、扩容。<br>因此，在事先知道字符串的长度时：<code>append()</code> 的性能最高。<code>copy()</code> 的开销最少。<br>如果无法确定字符串内容的多少，最佳的方案就是 <code>strings.Builder</code> 的 <code>WriteString()</code> 方法。</p><h5 id="3-4-7-9-参考文献"><a href="#3-4-7-9-参考文献" class="headerlink" title="3.4.7.9 参考文献"></a>3.4.7.9 参考文献</h5><blockquote><p><a target="_blank" rel="noopener" href="https://www.toutiao.com/a6736789153746256396">https://www.toutiao.com/a6736789153746256396</a></p></blockquote><h4 id="3-4-8-字符串不总是-UTF-8-文本"><a href="#3-4-8-字符串不总是-UTF-8-文本" class="headerlink" title="3.4.8 字符串不总是 UTF-8 文本"></a>3.4.8 字符串不总是 <code>UTF-8</code> 文本</h4><p>字符串的值可以包含任何字节，只有当字符串字面量（<code>string literal</code>）使用时，才会是 <code>UTF-8</code>。<br>验证一个字符串是否为 <code>UTF-8</code> 文本，可以使用 <code>unicode/utf8</code> 包下的 <code>utf8.ValidString()</code> 方法。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s1 := <span class="hljs-string">&quot;ABC&quot;</span>
	fmt.Println(utf8.ValidString(s1)) <span class="hljs-comment">// true</span>

	s2 := <span class="hljs-string">&quot;\xAF&quot;</span>
	fmt.Println(utf8.ValidString(s2)) <span class="hljs-comment">// false</span>
&#125;</code></pre><p>备注：来源于：<code>https://levy.at/blog/10</code>（字符串不总是UTF8文本）</p><h4 id="3-4-9-Go-字符串使用-byte-表示的原因"><a href="#3-4-9-Go-字符串使用-byte-表示的原因" class="headerlink" title="3.4.9 Go 字符串使用 byte 表示的原因"></a>3.4.9 Go 字符串使用 <code>byte</code> 表示的原因</h4><p>Go 字符串使用 <code>byte</code> 序列来表示，根本原因是因为各种语言的字符长度“飘忽不定”。<br>先看下面这段代码：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s1 := <span class="hljs-string">&quot;é&quot;</span> <span class="hljs-comment">// 这个是葡萄牙语，中译：它的</span>
	fmt.Printf(<span class="hljs-string">&quot;len(s1)=%d, []rune=%#v, []byte=%#v\n&quot;</span>, <span class="hljs-built_in">len</span>(s1), []<span class="hljs-keyword">rune</span>(s1), []<span class="hljs-keyword">byte</span>(s1))

	<span class="hljs-comment">// 既然在 byte 下占 3 个字节的长度，那么就可以对这个 byte 逐位修改</span>
	b_s1 := []<span class="hljs-keyword">byte</span>(s1)
	b_s1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>
	b_s1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>
	b_s1[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>
	fmt.Println(<span class="hljs-keyword">string</span>(b_s1))
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">len(s1)=3, []rune=[]int32&#123;101, 769&#125;, []byte=[]byte&#123;0x65, 0xcc, 0x81&#125;</span>
<span class="hljs-comment">abc</span>
<span class="hljs-comment">*/</span></code></pre><p>葡萄牙语的这个单词，在 <code>[]rune</code> 中，占 2 个字节长度；而在 <code>[]byte</code> 中，占了 3 个长度。<br>各国语言的字符，在不同的数据类型下（<code>[]rune</code> <code>[]byte</code>），长度不一等都一样。<br>下面看一个中文示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	s1 := <span class="hljs-string">&quot;中&quot;</span>
	fmt.Printf(<span class="hljs-string">&quot;len(s1)=%d, []rune=%#v, []byte=%#v\n&quot;</span>, <span class="hljs-built_in">len</span>(s1), []<span class="hljs-keyword">rune</span>(s1), []<span class="hljs-keyword">byte</span>(s1))
	fmt.Println(<span class="hljs-string">&quot;[]rune(s1) =&quot;</span>, <span class="hljs-built_in">len</span>([]<span class="hljs-keyword">rune</span>(s1)))
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">len(s1)=3, []rune=[]int32&#123;20013&#125;, []byte=[]byte&#123;0xe4, 0xb8, 0xad&#125;</span>
<span class="hljs-comment">[]rune(s1) = 1</span>
<span class="hljs-comment">*/</span></code></pre><p>字符串中只有一个元素”中”，<code>[]rune</code> 下，占 1 个字节长度；而在 <code>[]byte</code> 中，依然占了 3 个长度。<br>因为各个语言中的字符长度“飘忽不定”，因此只能采用一种统一的策略来进行管理，以免发生混乱。</p><h3 id="3-5-字符和字符串的区别"><a href="#3-5-字符和字符串的区别" class="headerlink" title="3.5 字符和字符串的区别"></a>3.5 字符和字符串的区别</h3><p>1.字符只能用单引号包裹起来，字符串需要双引号包裹起来。<br>2.字符只能是单个字符，字符串是能多个字符所构成。<br>有的转义字符只是看起来是由两个字符构成。比如 <code>\n</code>：肉眼看上去是 <code>\</code> 和 <code>n</code> 两个字符拼接在一起的，其实它是ASCII码 <code>10</code> 的另外一个书写形式。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>
	ch = <span class="hljs-number">10</span>
	fmt.Printf(<span class="hljs-string">&quot;aaa%cbbb&quot;</span>, ch)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">aaa</span>
<span class="hljs-comment">bbb</span>
<span class="hljs-comment">*/</span></code></pre><p>3.字符串的结尾都隐藏了一个结束符 <code>\0</code>。<br>在ASCII码中它的10进制值是<code>0</code>，它是一个空字符，是看不到的。<br><code>str1 := &quot;a&quot;</code>实则上是由<code>&#39;a&#39;</code>和<code>&#39;\0&#39;</code>组成了一个字符串。</p><h3 id="3-6-bool类型"><a href="#3-6-bool类型" class="headerlink" title="3.6 bool类型"></a>3.6 bool类型</h3><p><strong>Golang 中，布尔类型的值只能是预定义标识符：true 或 false</strong>。</p><h4 id="3-6-1-注意事项"><a href="#3-6-1-注意事项" class="headerlink" title="3.6.1 注意事项"></a>3.6.1 注意事项</h4><p>1.布尔类型变量的零值为 <code>false</code>。<br>2.Golang 中不允许将整型强制转换为布尔型。<br>3.布尔类型无法参与数值运算，也无法与其他类型进行转换。</p><h4 id="3-6-2-用数值来表示真假的错误示例"><a href="#3-6-2-用数值来表示真假的错误示例" class="headerlink" title="3.6.2 用数值来表示真假的错误示例"></a>3.6.2 用数值来表示真假的错误示例</h4><p>在 Golang 中，布尔类型的值只能是 <code>true</code> 或 <code>false</code>。<br>一些脚本编程语言或是一些弱类型编程语言中，数值 0 或 1 、空数组、空集合等也可以用来表真或假。但在 Golang 中，这是不允许的！Golang 中，<code>bool</code> 值只能是 <code>true</code> 或 <code>false</code>！<br>错误示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-number">0</span>

	<span class="hljs-keyword">if</span> a &#123; <span class="hljs-comment">//这行会报错：非布尔&#x27;a&#x27;(类型为int)用作条件</span>
		fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>)
	&#125;
&#125;</code></pre><h3 id="3-7-复数类型"><a href="#3-7-复数类型" class="headerlink" title="3.7 复数类型"></a>3.7 复数类型</h3><p>由实部和虚部构成。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> t1 <span class="hljs-keyword">complex128</span> <span class="hljs-comment">//声明</span>
	t1 = <span class="hljs-number">3</span> + <span class="hljs-number">5i</span>       <span class="hljs-comment">//赋值</span>
	fmt.Println(<span class="hljs-string">&quot;t1 = &quot;</span>, t1)

	t2 := <span class="hljs-number">7</span> + <span class="hljs-number">9.9i</span>
	fmt.Printf(<span class="hljs-string">&quot;t2 type is : %T\n&quot;</span>, t2)

	<span class="hljs-comment">//通过内建函数，取实部和虚部</span>
	fmt.Printf(<span class="hljs-string">&quot;real(t2)=%v, imag(t2)=%v\n&quot;</span>, <span class="hljs-built_in">real</span>(t2), <span class="hljs-built_in">imag</span>(t2))
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">t1 =  (3+5i)</span>
<span class="hljs-comment">t2 type is : complex128</span>
<span class="hljs-comment">real(t2)=7, imag(t2)=9.9</span>
<span class="hljs-comment">*/</span></code></pre><h3 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h3><p><strong>类型转换只能转换相互兼容的类型</strong>，比如 <code>byte</code> 类型转换成 <code>int</code> 类型。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//这种不能转换的类型，叫不兼容类型</span>
	<span class="hljs-keyword">var</span> flag <span class="hljs-keyword">bool</span>
	flag = <span class="hljs-literal">true</span>
	fmt.Printf(<span class="hljs-string">&quot;flag = %t\n&quot;</span>, flag)

	<span class="hljs-comment">//bool类型不能转换为int</span>
	<span class="hljs-comment">// fmt.Printf(&quot;flag = %d\n&quot;, int(flag))</span>

	<span class="hljs-comment">//其他语言中0就是假，非0就是真</span>
	<span class="hljs-comment">//整型也不能转换为bool</span>
	<span class="hljs-comment">//flag = bool</span>

	<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>
	ch = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">//字符类型本质上就是整型</span>
	<span class="hljs-keyword">var</span> t <span class="hljs-keyword">int</span>
	<span class="hljs-comment">// t = ch      //会报错</span>
	t = <span class="hljs-keyword">int</span>(ch) <span class="hljs-comment">//类型转换，把ch的值取出来，转换成整型</span>
	fmt.Println(<span class="hljs-string">&quot;t = &quot;</span>, t)
&#125;

<span class="hljs-comment">/**运行结果</span>
<span class="hljs-comment">flag = true</span>
<span class="hljs-comment">t =  97</span>
<span class="hljs-comment">**/</span></code></pre><h3 id="3-9-类型别名"><a href="#3-9-类型别名" class="headerlink" title="3.9 类型别名"></a>3.9 类型别名</h3><p>给一个数据类型起一个别名（小名），最常用的场景就是结构体 <code>struct</code>。<br>语法：<code>type 别名 数据类型</code><br>使用：<code>var 变量名 别名</code><br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//给int64这个数据类型起个别名叫bigint</span>
	<span class="hljs-keyword">type</span> bigint <span class="hljs-keyword">int64</span>
	<span class="hljs-keyword">var</span> a bigint                      <span class="hljs-comment">//a变量声明为bigint类型</span>
	fmt.Printf(<span class="hljs-string">&quot;a type is : %T\n&quot;</span>, a) <span class="hljs-comment">//指向了自定义的bigint类型</span>

	<span class="hljs-comment">//多个别名一起声明</span>
	<span class="hljs-keyword">type</span> (
		char <span class="hljs-keyword">byte</span>
		long <span class="hljs-keyword">int64</span>
	)
	<span class="hljs-comment">//声明变量为自定义类型</span>
	<span class="hljs-keyword">var</span> ch char
	<span class="hljs-keyword">var</span> ll long
	ch = <span class="hljs-string">&#x27;a&#x27;</span>
	ll = <span class="hljs-number">123456</span>
	fmt.Printf(<span class="hljs-string">&quot;ch=%v, ll=%v\n&quot;</span>, ch, ll)
	fmt.Printf(<span class="hljs-string">&quot;ch type is : %T, ll type is : %T\n&quot;</span>, ch, ll)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">a type is : main.bigint</span>
<span class="hljs-comment">ch=97, ll=123456</span>
<span class="hljs-comment">ch type is : main.char, ll type is : main.long</span>
<span class="hljs-comment">*/</span></code></pre><h3 id="3-10-格式化输出"><a href="#3-10-格式化输出" class="headerlink" title="3.10 格式化输出"></a>3.10 格式化输出</h3><table><thead><tr><th><strong>格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%%</td><td>一个%字面量</td></tr><tr><td>%b</td><td>一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数</td></tr><tr><td><strong>%c</strong></td><td><strong>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</strong></td></tr><tr><td><strong>%d</strong></td><td><strong>一个十进制数值(基数为10)</strong></td></tr><tr><td>%e</td><td>以科学记数法e表示的浮点数或者复数值</td></tr><tr><td>%E</td><td>以科学记数法E表示的浮点数或者复数值</td></tr><tr><td>%f</td><td>以标准记数法表示的浮点数或者复数值</td></tr><tr><td>%g</td><td>以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%G</td><td>以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%o</td><td>一个以八进制表示的数字(基数为8)</td></tr><tr><td>%p</td><td>以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示</td></tr><tr><td>%q</td><td>使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td></tr><tr><td>%s</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td></tr><tr><td>%t</td><td>以true或者false输出的布尔值</td></tr><tr><td><strong>%T</strong></td><td><strong>使用Go语法输出的值的类型</strong></td></tr><tr><td>%U</td><td>一个用Unicode表示法表示的整型码点，默认值为4个数字字符</td></tr><tr><td><strong>%v</strong></td><td><strong>使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话</strong></td></tr><tr><td>%x</td><td>以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示</td></tr><tr><td>%X</td><td>以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示</td></tr></tbody></table><p><code>%v</code> 属于万能格式，自动匹配格式输出。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-number">10</span>
	b := <span class="hljs-string">&quot;abc&quot;</span>
	c := <span class="hljs-string">&#x27;a&#x27;</span>
	d := <span class="hljs-number">3.14</span>

	<span class="hljs-comment">//%T操作变量所属类型</span>
	fmt.Printf(<span class="hljs-string">&quot;%T, %T, %T, %T\n&quot;</span>, a, b, c, d)

	<span class="hljs-comment">//%d	整型格式</span>
	<span class="hljs-comment">//%s	字符串格式</span>
	<span class="hljs-comment">//%c	字符格式</span>
	<span class="hljs-comment">//%f	浮点型格式</span>
	fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %s, c = %c, d = %f\n&quot;</span>, a, b, c, d)
	<span class="hljs-comment">//%v自动匹配格式输出</span>
	fmt.Printf(<span class="hljs-string">&quot;a = %v, b = %v, c = %v, d = %v&quot;</span>, a, b, c, d)
&#125;

<span class="hljs-comment">/**运行结果</span>
<span class="hljs-comment">int, string, int32, float64</span>
<span class="hljs-comment">a = 10, b = abc, c = a, d = 3.140000</span>
<span class="hljs-comment">a = 10, b = abc, c = 97, d = 3.14</span>
<span class="hljs-comment">**/</span></code></pre><h3 id="3-11-非十进制可选前缀"><a href="#3-11-非十进制可选前缀" class="headerlink" title="3.11 非十进制可选前缀"></a>3.11 非十进制可选前缀</h3><p>一个整数数值字面量无需带前缀，除非它是负数，或者自己想要添加一个加号。<br>非十进制可选前缀设置表示法：<br>二进制：<code>0b</code> 或 <code>0B</code><br>八进制：<code>0</code>, <code>0o</code> 或 <code>0O</code><br>十六进制：<code>0x</code> 或 <code>0X</code>; 在十六进制中，[a ~ f] 或 [A ~ F] 代表十进制值 10 ~ 15<br>只有单个 <code>0</code> 被认为是十进制的 <code>0</code>。</p><h3 id="3-12-增强数值的可读性"><a href="#3-12-增强数值的可读性" class="headerlink" title="3.12 _ 增强数值的可读性"></a>3.12 <code>_</code> 增强数值的可读性</h3><p>如果有一个特别大的数值，一眼看过去，一时半会儿看不清楚它是百亿还是千亿。那么在代码中，可以在这个数值中添加下划线 <code>_</code>，来增强数值的可读性。<br>例如：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	n := <span class="hljs-number">123</span>_456_789_000
	fmt.Printf(<span class="hljs-string">&quot;n type: %[1]T, value=%[1]v\n&quot;</span>, n)

	n += <span class="hljs-number">55</span>_55555_55555
	fmt.Printf(<span class="hljs-string">&quot;n type: %[1]T, value=%[1]v\n&quot;</span>, n)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">n type: int, value=123456789000</span>
<span class="hljs-comment">n type: int, value=679012344555</span>
<span class="hljs-comment">*/</span></code></pre><p>其实是个语法糖，<code>_</code> 被当做分隔符来使用了。自己看着怎么易读，就怎么分割。同样适用于十六进制的值以及小数中！</p><h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><h3 id="4-1-Golang内建的运算符"><a href="#4-1-Golang内建的运算符" class="headerlink" title="4.1 Golang内建的运算符"></a>4.1 Golang内建的运算符</h3><p>Golang 内建的运算符有：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符。</p><h3 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>相加</td><td>10 + 3</td><td>13</td></tr><tr><td>-</td><td>相减</td><td>10 - 3</td><td>7</td></tr><tr><td>*</td><td>相乘</td><td>10 * 3</td><td>30</td></tr><tr><td>/</td><td>相除</td><td>10 / 3</td><td>3</td></tr><tr><td>%</td><td>取余</td><td>10 % 3</td><td>1</td></tr></tbody></table><p><strong>Golang 中自增自减的注意</strong>：<br>在 Golang 中，<code>++</code>（自增）和 <code>--</code>（自减）是单独的语句，并不是运算符。<br>而且自增自减必须是单独一行（单独的语句），下例中的自增是非法的：</p><pre><code class="hljs go">i := <span class="hljs-number">1</span>
j = i++ <span class="hljs-comment">//此处的 i++ 是非法的，i++ 必须是单独的语句</span></code></pre><h3 id="4-3-关系运算符"><a href="#4-3-关系运算符" class="headerlink" title="4.3 关系运算符"></a>4.3 关系运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>false</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 3</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>false</td></tr></tbody></table><h3 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与, 两边都为真, 则结果为真; 其余为假</td><td>true &amp;&amp; true</td><td>true</td></tr><tr><td>||</td><td>逻辑或, 两边都为假, 则结果为假; 其余为真</td><td>true || false</td><td>true</td></tr><tr><td>!</td><td>逻辑非, 条件为真, 则结果为假; 条件为假, 则结果为真</td><td>!true</td><td>false</td></tr></tbody></table><h3 id="4-5-位运算符"><a href="#4-5-位运算符" class="headerlink" title="4.5 位运算符"></a>4.5 位运算符</h3><p>位运算符是对整数在内存中的二进制位进行操作。用得不多</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><p>示例1：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> size = <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">4</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(<span class="hljs-string">&quot;2 &lt;&lt; 10 = &quot;</span>, <span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">10</span>)     <span class="hljs-comment">//表示：2*2**10，2乘以2的10次方</span>
	fmt.Println(<span class="hljs-string">&quot;1024 &gt;&gt; 2 = &quot;</span>, <span class="hljs-number">1024</span>&gt;&gt;<span class="hljs-number">2</span>) <span class="hljs-comment">//表示：1024/2**2，1024除以2的2次方</span>
	fmt.Println(<span class="hljs-string">&quot;const size = &quot;</span>, size)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运算结果：</span>
<span class="hljs-comment">2 &lt;&lt; 10 =  2048</span>
<span class="hljs-comment">1024 &gt;&gt; 2 =  256</span>
<span class="hljs-comment">const size =  32</span>
<span class="hljs-comment">*/</span></code></pre><h3 id="4-6-赋值运算符"><a href="#4-6-赋值运算符" class="headerlink" title="4.6 赋值运算符"></a>4.6 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><h3 id="4-7-运算符优先级"><a href="#4-7-运算符优先级" class="headerlink" title="4.7 运算符优先级"></a>4.7 运算符优先级</h3><p>优先级：从上往下由高到低</p><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td><code>^</code> <code>!</code></td></tr><tr><td>6</td><td><code>*</code> <code>/</code> <code>%</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;&amp;</code> <code>^</code></td></tr><tr><td>5</td><td><code>+</code> <code>-</code> `</td></tr><tr><td>4</td><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td></tr><tr><td>3</td><td><code>&lt;-</code></td></tr><tr><td>2</td><td><code>&amp;&amp;</code></td></tr><tr><td>1</td><td>`</td></tr></tbody></table><p>使用小括号<code>()</code>把一个表达式包裹起来可以提升优先级。</p><h3 id="4-8-Golang中，不能使用复合表达式"><a href="#4-8-Golang中，不能使用复合表达式" class="headerlink" title="4.8 Golang中，不能使用复合表达式"></a>4.8 Golang中，不能使用复合表达式</h3><p>其他编程语言中，比较一个数即要大于某个数同时也要小于某个数（比如：当 a=7 时，判断：a 是否大于等于 0 并且 a 是否小于等于 10），那么就会用到复合布尔表达式（例如：0 &lt;= a &lt;= 10）。<br>但在 Golang 中就会报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-number">7</span>
	fmt.Println(<span class="hljs-string">&quot;0 &lt;= a &lt;= 10 的结果：&quot;</span>, <span class="hljs-number">0</span> &lt;= a &lt;= <span class="hljs-number">10</span>)
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">		cannot convert 10 (type untyped number) to type bool</span>
<span class="hljs-comment">		invalid operation: 0 &lt;= a &lt;= 10 (mismatched types bool and int)</span>
<span class="hljs-comment">		不匹配的类型bool和int</span>
<span class="hljs-comment">	*/</span>
&#125;</code></pre><p><strong>golang的int类型与bool类型不兼容</strong>！<code>0 &lt;= a</code> 得出的结果是一个 bool 类型的值 <code>true</code>，<code>true &lt;= 10</code>。10是一个 int 类型，true 是 bool 类型，两者的类型在 golang 中不兼容，因此报错！<br>需要使用<code>与</code>（<code>&amp;&amp;</code>）运算符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-number">7</span>
	fmt.Println(<span class="hljs-string">&quot;0 &lt;= a &lt;= 10 的结果：&quot;</span>, <span class="hljs-number">0</span> &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">10</span>)
	<span class="hljs-comment">//0 &lt;= a &lt;= 10 的结果： true</span>
&#125;</code></pre><h2 id="五、流程控制"><a href="#五、流程控制" class="headerlink" title="五、流程控制"></a>五、流程控制</h2><p>对程序做出逻辑性控制。</p><h3 id="5-1-Golang最基本的三种程序运行控制"><a href="#5-1-Golang最基本的三种程序运行控制" class="headerlink" title="5.1 Golang最基本的三种程序运行控制"></a>5.1 Golang最基本的三种程序运行控制</h3><h4 id="5-1-1-顺序控制"><a href="#5-1-1-顺序控制" class="headerlink" title="5.1.1 顺序控制"></a>5.1.1 顺序控制</h4><p>程序按顺序运行，流水账从上往下运行，不发生跳转。</p><h4 id="5-1-2-选择控制"><a href="#5-1-2-选择控制" class="headerlink" title="5.1.2 选择控制"></a>5.1.2 选择控制</h4><p>依据是否满足条件，有选择地执行相应功能。</p><h4 id="5-1-3-循环控制"><a href="#5-1-3-循环控制" class="headerlink" title="5.1.3 循环控制"></a>5.1.3 循环控制</h4><p>依据条件是否满足，循环多次执行某段代码。</p><h3 id="5-2-if条件语句"><a href="#5-2-if条件语句" class="headerlink" title="5.2 if条件语句"></a>5.2 if条件语句</h3><p><code>if</code> 语句支持<strong>1个</strong>初始化语句，初始化语句与判断语句写在同一行中。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">if</span> a := <span class="hljs-number">10</span>; a == <span class="hljs-number">10</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>) <span class="hljs-comment">//yes</span>
	&#125;
&#125;</code></pre><p><code>a := 10</code> 是初始化语句，<code>a == 10</code>是判断语句。<br>这样可以非常好地控制变量的作用域：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">if</span> a := <span class="hljs-number">10</span>; a == <span class="hljs-number">10</span> &#123;	<span class="hljs-comment">//a只能在这个代码块中有效</span>
		fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>) <span class="hljs-comment">//yes</span>
	&#125;

	fmt.Println(a) <span class="hljs-comment">//undefined: a</span>
&#125;</code></pre><h3 id="5-3-switch"><a href="#5-3-switch" class="headerlink" title="5.3 switch"></a>5.3 switch</h3><p><code>if...else if...else</code> 另一种简洁灵活的写法。</p><h4 id="5-3-1-语法"><a href="#5-3-1-语法" class="headerlink" title="5.3.1 语法"></a>5.3.1 语法</h4><p>最基本的语法：</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 变量本身 &#123;
<span class="hljs-keyword">case</span> 变量的值<span class="hljs-number">1</span>:
	语句
<span class="hljs-keyword">case</span> 变量的值<span class="hljs-number">2</span>:
	语句
<span class="hljs-keyword">case</span> 变量的值n:
	语句
<span class="hljs-keyword">default</span>: <span class="hljs-comment">//default可以省略</span>
	语句
&#125;</code></pre><p>变量本身和下面 <code>case</code> 分支中的变量值进行比较（从上往下比较），匹配到了就进入对应的 <code>case</code> 分支中。<br><code>switch</code> 也支持<strong>1个</strong>初始化语句。<br>注意：<strong>一个 case 分支中的值，不能与其他 case 分支中的值重复！</strong></p><h4 id="5-3-2-break"><a href="#5-3-2-break" class="headerlink" title="5.3.2 break"></a>5.3.2 break</h4><p>默认情况下，<code>case</code> 语句中自带了 <code>break</code>。执行完一个 <code>case</code> 分支后，自动跳出当前整个 <code>switch</code>，不会自动向下执行其他 <code>case</code>。</p><h4 id="5-3-3-fallthrough"><a href="#5-3-3-fallthrough" class="headerlink" title="5.3.3 fallthrough"></a>5.3.3 fallthrough</h4><p>不判断下一个<code>case</code> 变量的值，无条件强制执行下去。<br><code>fallthrough</code>下面必须要接语句，无论是接 <code>case</code> 还是 <code>default</code>。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">switch</span> num := <span class="hljs-number">1</span>; num &#123; <span class="hljs-comment">//支持1个初始化语句，初始化语句和变量本身使用分号分隔</span>
	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
		fmt.Println(<span class="hljs-string">&quot;print 1&quot;</span>)
		<span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">//不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去</span>
	<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
		fmt.Println(<span class="hljs-string">&quot;print 2&quot;</span>)
		<span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">//不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去</span>
	<span class="hljs-keyword">default</span>:
		fmt.Println(<span class="hljs-string">&quot;print else&quot;</span>)
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">print 1</span>
<span class="hljs-comment">print 2</span>
<span class="hljs-comment">print else</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="5-3-4-根据case条件自行选择分支"><a href="#5-3-4-根据case条件自行选择分支" class="headerlink" title="5.3.4 根据case条件自行选择分支"></a>5.3.4 根据case条件自行选择分支</h4><p><code>switch</code> 后面不接变量本身，而是根据<code>case 条件的判断结果</code>自行去选择分支。<br>语法：</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> &#123; <span class="hljs-comment">//不接变量本身，根据各个case条件进行判断、选择</span>
<span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>: <span class="hljs-comment">//case后面放条件</span>
	语句
<span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>: <span class="hljs-comment">//case后面放条件</span>
	语句
<span class="hljs-keyword">case</span> 条件n: <span class="hljs-comment">//case后面放条件</span>
	语句
<span class="hljs-keyword">default</span>: <span class="hljs-comment">//default可以省略</span>
	语句
&#125;</code></pre><p>如果根据 <code>case</code> 条件的判断结果去自行选择分支，那么 <code>switch</code> 后面就不能接变量本身了：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	grade := <span class="hljs-number">80</span>
	<span class="hljs-keyword">switch</span> &#123; <span class="hljs-comment">//这里不写变量本身了</span>
	<span class="hljs-keyword">case</span> grade &gt; <span class="hljs-number">90</span>: <span class="hljs-comment">//case分支中判断是否满足条件，符合条件进入这个分支</span>
		fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)
	<span class="hljs-keyword">case</span> grade &gt;= <span class="hljs-number">80</span>: <span class="hljs-comment">//case中判断是否满足条件</span>
		fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)
	<span class="hljs-keyword">default</span>:
		fmt.Println(<span class="hljs-string">&quot;其他&quot;</span>)
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">良好</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="5-3-5-测试多个符合条件的值"><a href="#5-3-5-测试多个符合条件的值" class="headerlink" title="5.3.5 测试多个符合条件的值"></a>5.3.5 测试多个符合条件的值</h4><p><code>case</code> 语句中，可以同时写上多个可能符合条件的值，使用逗号分割它们。例如：<code>case 值1, 值2, 值3</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">switch</span> grade := <span class="hljs-number">70</span>; grade &#123;
	<span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:
		fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)
	<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>:
		fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)
	<span class="hljs-keyword">case</span> <span class="hljs-number">60</span>, <span class="hljs-number">70</span>:
		fmt.Println(<span class="hljs-string">&quot;及格&quot;</span>)
	<span class="hljs-keyword">default</span>:
		fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">及格</span>
<span class="hljs-comment">*/</span></code></pre><h3 id="5-4-for循环"><a href="#5-4-for循环" class="headerlink" title="5.4 for循环"></a>5.4 for循环</h3><p>Golang 中的循环只有 <code>for</code> 循环。</p><h4 id="5-4-1-基本语法"><a href="#5-4-1-基本语法" class="headerlink" title="5.4.1 基本语法"></a>5.4.1 基本语法</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//必须有一个main包</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入包含，必须要使用</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//for初始化条件; 判断条件; 条件变化&#123;</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">//1+2+3...+100 累加</span>

	sum := <span class="hljs-number">0</span>

	<span class="hljs-comment">//1) 初始化条件 i := 1</span>
	<span class="hljs-comment">//2) 判断条件是否为真，i &lt;= 100，如果为真，执行循环体，如果为假，跳出循环</span>
	<span class="hljs-comment">//3) 条件变化 i++</span>
	<span class="hljs-comment">//4) 重复2，3，4</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;
		sum += i
	&#125;
	fmt.Println(<span class="hljs-string">&quot;sum = &quot;</span>, sum)
&#125;</code></pre><h4 id="5-4-2-基本流程"><a href="#5-4-2-基本流程" class="headerlink" title="5.4.2 基本流程"></a>5.4.2 基本流程</h4><p>1.初始化条件。<br>2.判断条件是否为真，如果为真进入循环体内，如果为假则跳出循环。<br>3.执行条件变化的语句。<br>4.重复 2.3.4 步骤。</p><h4 id="5-4-3-range迭代"><a href="#5-4-3-range迭代" class="headerlink" title="5.4.3 range迭代"></a>5.4.3 range迭代</h4><p>一种自动实现的迭代器，常用于：数组、切片、通道。需要在 <code>for</code> 循环中使用。<br><code>range</code> 有两个返回值：第一个返回值是元素的下标；第二个返回值是元素自身的值。<br>示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//必须有一个main包</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入包含，必须要使用</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	str := <span class="hljs-string">&quot;abc&quot;</span>

	<span class="hljs-comment">//通过for打印每个字符</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;
		fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])
	&#125;

	<span class="hljs-comment">//迭代打印每个元素，默认返回2个值：一个是元素的位置，一个是元素本身</span>
	<span class="hljs-keyword">for</span> i, data := <span class="hljs-keyword">range</span> str &#123;
		fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, data)
	&#125;

	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> str &#123; <span class="hljs-comment">//第2个返回值，默认丢弃，返回元素的位置（下标）</span>
		fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])
	&#125;

	<span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> str &#123; <span class="hljs-comment">//第2个返回值，默认丢弃，返回元素的位置（下标）</span>
		fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])
	&#125;
&#125;


<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">str[0]=a</span>
<span class="hljs-comment">str[1]=b</span>
<span class="hljs-comment">str[2]=c</span>
<span class="hljs-comment">str[0]=a</span>
<span class="hljs-comment">str[1]=b</span>
<span class="hljs-comment">str[2]=c</span>
<span class="hljs-comment">str[0]=a</span>
<span class="hljs-comment">str[1]=b</span>
<span class="hljs-comment">str[2]=c</span>
<span class="hljs-comment">str[0]=a</span>
<span class="hljs-comment">str[1]=b</span>
<span class="hljs-comment">str[2]=c</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="5-4-4-几个for循环小案例"><a href="#5-4-4-几个for循环小案例" class="headerlink" title="5.4.4 几个for循环小案例"></a>5.4.4 几个for循环小案例</h4><h5 id="5-4-4-1-九九乘法表"><a href="#5-4-4-1-九九乘法表" class="headerlink" title="5.4.4.1 九九乘法表"></a>5.4.4.1 九九乘法表</h5><p>打印九九乘法表：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//外层控制共循环几次</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;

		<span class="hljs-comment">//里层控制每次循环需要计算几次</span>
		<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123;
			fmt.Printf(<span class="hljs-string">&quot;%d x %d = %d\t&quot;</span>, j, i, i*j) <span class="hljs-comment">//1*9的格式来显示</span>
		&#125;
		fmt.Println()
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">1 x 1 = 1</span>
<span class="hljs-comment">1 x 2 = 2       2 x 2 = 4</span>
<span class="hljs-comment">1 x 3 = 3       2 x 3 = 6       3 x 3 = 9</span>
<span class="hljs-comment">1 x 4 = 4       2 x 4 = 8       3 x 4 = 12      4 x 4 = 16</span>
<span class="hljs-comment">1 x 5 = 5       2 x 5 = 10      3 x 5 = 15      4 x 5 = 20      5 x 5 = 25</span>
<span class="hljs-comment">1 x 6 = 6       2 x 6 = 12      3 x 6 = 18      4 x 6 = 24      5 x 6 = 30      6 x 6 = 36</span>
<span class="hljs-comment">1 x 7 = 7       2 x 7 = 14      3 x 7 = 21      4 x 7 = 28      5 x 7 = 35      6 x 7 = 42      7 x 7 = 49</span>
<span class="hljs-comment">1 x 8 = 8       2 x 8 = 16      3 x 8 = 24      4 x 8 = 32      5 x 8 = 40      6 x 8 = 48      7 x 8 = 56      8 x 8 = 64</span>
<span class="hljs-comment">1 x 9 = 9       2 x 9 = 18      3 x 9 = 27      4 x 9 = 36      5 x 9 = 45      6 x 9 = 54      7 x 9 = 63      8 x 9 = 72      9 x 9 = 81</span>
<span class="hljs-comment">*/</span></code></pre><h5 id="5-4-4-2-冒泡排序"><a href="#5-4-4-2-冒泡排序" class="headerlink" title="5.4.4.2 冒泡排序"></a>5.4.4.2 冒泡排序</h5><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bubbling</span><span class="hljs-params">(sli []<span class="hljs-keyword">int</span>)</span></span> &#123;
	length := <span class="hljs-built_in">len</span>(sli)

	<span class="hljs-comment">//外层控制共循环几次</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length<span class="hljs-number">-1</span>; i++ &#123;

		<span class="hljs-comment">//里层控制每个元素都参与比较</span>
		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length<span class="hljs-number">-1</span>; j++ &#123;
			<span class="hljs-keyword">if</span> sli[i] &lt; sli[j] &#123; <span class="hljs-comment">//策略：大的数字放在前面</span>
				sli[i], sli[j] = sli[j], sli[i]
			&#125;
		&#125;
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	sli := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;
	fmt.Println(<span class="hljs-string">&quot;before bubbling:&quot;</span>, sli)
	Bubbling(sli)
	fmt.Println(<span class="hljs-string">&quot;after bubbling:&quot;</span>, sli)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">before bubbling: [5 9 10 3 6 1 0 7 8 4 2 0]</span>
<span class="hljs-comment">after bubbling: [10 9 8 7 6 5 4 3 2 1 0 0]</span>
<span class="hljs-comment">*/</span></code></pre><h3 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h3><h4 id="5-5-1-break"><a href="#5-5-1-break" class="headerlink" title="5.5.1 break"></a>5.5.1 break</h4><p><code>break</code> 可以用在 <code>for</code>、<code>switch</code>、<code>select</code>。</p><h4 id="5-5-2-continue"><a href="#5-5-2-continue" class="headerlink" title="5.5.2 continue"></a>5.5.2 continue</h4><p><code>continue</code> 只能用在 <code>for</code> 循环中！</p><h4 id="5-5-3-break和continue不能同时出现在同一级语句块中"><a href="#5-5-3-break和continue不能同时出现在同一级语句块中" class="headerlink" title="5.5.3 break和continue不能同时出现在同一级语句块中"></a>5.5.3 break和continue不能同时出现在同一级语句块中</h4><p><code>break</code> 和 <code>continue</code> 同时出现在同一级语句块中，就会自相矛盾，导致另一个语句无法到达！</p><h3 id="5-6-goto"><a href="#5-6-goto" class="headerlink" title="5.6 goto"></a>5.6 goto</h3><p><code>goto</code> 可以在任何地方使用，但不能跨函数使用。<br><strong>不建议使用，因为会破坏程序的结构</strong>！</p><h4 id="5-6-1-goto不能跨函数使用"><a href="#5-6-1-goto不能跨函数使用" class="headerlink" title="5.6.1 goto不能跨函数使用"></a>5.6.1 goto不能跨函数使用</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testFunc</span><span class="hljs-params">()</span></span> &#123;
END:
	fmt.Println(<span class="hljs-string">&quot;this is testFunc.&quot;</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">goto</span> END
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">.\main.go:6:1: label END defined and not used</span>
<span class="hljs-comment">.\main.go:11:7: label END not defined</span>
<span class="hljs-comment">*/</span></code></pre><h4 id="5-6-2-goto无条件跳转"><a href="#5-6-2-goto无条件跳转" class="headerlink" title="5.6.2 goto无条件跳转"></a>5.6.2 goto无条件跳转</h4><p>程序遇到 <code>goto</code> 语句，将会无条件强制跳转。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(<span class="hljs-string">&quot;111&quot;</span>)

	<span class="hljs-keyword">goto</span> END <span class="hljs-comment">//自定义标签名，无条件强制跳转去该标签的所在代码块</span>

	fmt.Println(<span class="hljs-string">&quot;3333&quot;</span>) <span class="hljs-comment">//此行代码永远无法到达</span>

END:
	fmt.Println(<span class="hljs-string">&quot;END target&quot;</span>)
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">111</span>
<span class="hljs-comment">END target</span>
<span class="hljs-comment">*/</span></code></pre><p>尝试将上面代码中的 END 标签和其代码块放到 main() 函数的第一行，会发生什么情况？<br>程序进入死循环，没完没了地一直在跳转。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
END:
	fmt.Println(<span class="hljs-string">&quot;END target&quot;</span>)

	fmt.Println(<span class="hljs-string">&quot;111&quot;</span>)

	<span class="hljs-keyword">goto</span> END

	fmt.Println(<span class="hljs-string">&quot;3333&quot;</span>)
&#125;</code></pre><h4 id="5-6-3-goto-的使用场景示例"><a href="#5-6-3-goto-的使用场景示例" class="headerlink" title="5.6.3 goto 的使用场景示例"></a>5.6.3 goto 的使用场景示例</h4><p>有这么一个场景：打印 1 ~ 10，不能用 <code>for</code> 循环。<br>用 <code>goto</code> 就能很容易实现需求：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	n := <span class="hljs-number">1</span>

LOOP: <span class="hljs-comment">// 定义 goto 的标签，以及实现代码逻辑</span>
	fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, n)
	n++

	<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">10</span> &#123;
		<span class="hljs-keyword">goto</span> LOOP <span class="hljs-comment">// 跳转到该标签</span>
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">1 2 3 4 5 6 7 8 9 10 </span>
<span class="hljs-comment">*/</span></code></pre><p>以上代码，也是运用了循环的思维模式，只是换了跳转的方式而已。<br>还有一种方式就是递归：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">10</span> &#123;
		fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, n)
		n++
		main()
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">运行结果：</span>
<span class="hljs-comment">1 2 3 4 5 6 7 8 9 10</span>
<span class="hljs-comment">*/</span></code></pre><p>递归是循环的另一种表现形式。</p><h2 id="六、值类型-amp-amp-引用类型"><a href="#六、值类型-amp-amp-引用类型" class="headerlink" title="六、值类型 &amp;&amp; 引用类型"></a>六、值类型 &amp;&amp; 引用类型</h2><h3 id="6-1-值类型"><a href="#6-1-值类型" class="headerlink" title="6.1 值类型"></a>6.1 值类型</h3><pre><code class="hljs go"><span class="hljs-keyword">bool</span>
<span class="hljs-keyword">int</span>(<span class="hljs-number">32</span> or <span class="hljs-number">64</span>), <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>
<span class="hljs-keyword">uint</span>(<span class="hljs-number">32</span> or <span class="hljs-number">64</span>), <span class="hljs-keyword">uint8</span>(<span class="hljs-keyword">byte</span>), <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>
<span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span>
<span class="hljs-keyword">string</span>
<span class="hljs-keyword">complex64</span>, <span class="hljs-keyword">complex128</span>
array <span class="hljs-comment">// 固定长度的数组</span></code></pre><h3 id="6-2-引用类型"><a href="#6-2-引用类型" class="headerlink" title="6.2 引用类型"></a>6.2 引用类型</h3><p>Golang 中，只有这几个引用类型：</p><pre><code class="hljs go">slice      <span class="hljs-comment">// 切片</span>
<span class="hljs-keyword">map</span> 	   <span class="hljs-comment">// HashMap</span>
pointer    <span class="hljs-comment">//指针类型</span>
channel    <span class="hljs-comment">//管道（通道）</span>
<span class="hljs-keyword">interface</span>  <span class="hljs-comment">//接口</span>
function   <span class="hljs-comment">//函数</span></code></pre></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/">编程之美</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Golang/">Golang</a></div></div><p class="note note-warning"><strong>本文作者: </strong><a href="/">iceH</a><br><strong>本文链接: </strong><a href="http://www.secice.cn/p/f6d90fce">http://www.secice.cn/p/f6d90fce</a><br><strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/p/8fdd12c0"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Golang学习之函数与工程管理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/p/5a00e178"><span class="hidden-mobile">红队攻防学习之内网渗透基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="vcomments"></div><script type="text/javascript">Fluid.utils.waitElementVisible("vcomments",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.14/Valine.min.js",(function(){new Valine({el:"#vcomments",app_id:"MnjV8raNBztIVGGKiicFL3Sq-MdYXbMMI",app_key:"hS70MmgmzDqbMSkSAfkDe42h",placeholder:"留下你的小脚印吧...",path:window.location.pathname,avatar:"wavatar",meta:["nick","mail"],pageSize:"10",lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a></noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-custom mx-auto"><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/img/psb.gif" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:300px;height:150px"></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><span>iceH</span> <i class="iconfont icon-love"></i> <span>一条啥也不会的咸鱼！</span></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:200}),NProgress.start(),document.addEventListener("DOMContentLoaded",(function(){window.NProgress&&window.NProgress.inc()})),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js"></script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/js/qipao.js"></script><script src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/js/jingtaisidai.js"></script><script src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/js/dianjichuzi.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script></body></html>